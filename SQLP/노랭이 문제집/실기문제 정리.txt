실기 1
아래와 같은 월별 지점 메출 테이블을 읽어서 우측과 같은 형식 즉 각 지점별로 판매월과 함께 증가하는 누적매출(running total)을 구하는 SQL을 두가지 방식으로 작성해라
1. 윈도우 함수를 이용한 방식으로 작성
```
select 지점
     , 판매월
     , 매출
     , sum(매출) over (partition by 지점 order by 판매월) 누적매출
  from 월별지점매출  
```
또는 
```
select 지점
     , 판매월
     , 매출
     , sum(매출) over (partition by 지점 order by 판매월 range between unbounded preceding and current row) 누적매출
  from 월별지점매출; 
```
2. 윈도우 함수나 스칼라 서브쿼리를 지원하지 않는 DBMS에서 활용할 수 있는 방식으로 작성(단 전체범위처리에 최적화된 방식으로 작성할 것)

```
select t1.지점
     , min(t1.매출) 매출
     , sum(t2.매출) 누적매출
  from 월별지점매출 t1, 월별지점매출 t2
 where t2.지점 = t1.지점
   and t2.판매월 <= t1.판매월
group by t1.지점, t1.판매월
order by t1.지점, t1.판매월;
```
또는
```
select t1.지점
     , t1.판매월
     , sum(t2.매출) 누적매출
  from 월별지점매출 t1, 월별지점매출 t2
 where t2.지점 = t1.지점
   and t2.판매월 <= t1.판매월
group by t1.지점, t1.판매월, t1.매출
order by t1.지점, t1.판매월;
```
해설
- 누적 매출(running total)을 구할 때 윈도우 함수를 지원하는 DBMS 버전이라면 윈도우 함수가 가장 효과적이고 성능도 빠름
윈도우 함수를 사용할 떄는 partition by 절을 정확히 작성하는 것이 무엇보다 중요함
윈도우 함수를 지원하는 DBMS버전이라면 부등호 조인을 이용해 누적 매출을 구할 수 있음
스칼라 서브쿼리를 이용하는 방법도 있지만, 전체 범위 처리에 결코 효과적이지 못함


실기 2
아래 SQL 과 트레이스 결과를 분석해서 개선된 SQL을 작성해라
1. 원하는 실행계획이 정확히 나오도록 힌트를 함께 기술할 것
2. 최적화 인덱스 구성방안도 제시해라
```

create index 고객_idx on 고객(거주지역코드, 고객명);
create index 주문_idx on 주문(고객번호, 주문일시);

select /*+ leading(c) use_nl(o) index(c 고객) index(o 주문_idx)*/
from 고객 c, 주문 o
where o.주문일시 between to_date('20150301'.'yyyymmdd')
and to_date('20150314235959','yyyymmddhh24miss')
and o.고객번호 = c.고객번호
and (c.거주지역코드, c.고객명) in (('02','김철수'), ('05','홍길동'))
order by o.주문일시, c.고객명
```

고객 20여건을 읽어 주문과 조인한 후 최종적으로 5건을 출력하는 SQL문임
소량 데이터를 조인할 때는 가급적 인덱스를 이용한 NL 조인을 쓴다

고객 테이블에 인덱스를 사용하려면 거주지역코드와 고객명을 가공하지 않아야 함
문자열로 결합한 부분을 아래와 같이 변경하면 됨

and (c.거주지역코드, c.고객명) in (('02','김철수'),('05', 홍길동))

or 또는 UNION ALL 방식을 사용해도 성능은 같음. OR조건을 사용할 때는 가급적 USE_CONCAT힌트를 같이 사용하는 것이 좋음
인덱스는 거주지역코드 + 고객명 또는 고객명 + 거주지역코드  순으로 구성하면 됨

인덱스를 이용해 주문 테이블과 NL 조인하려면 고객번호 + 주문일시 순으로 인덱스를 구성해야 함
주문일시 + 고객번호 순으로 인덱스를 구성해도 인덱스 사용은 가능하나 Between 조건이 선두컬럼이므로 매우 비효율적임

실기 3
같은 데이터를 두번 읽지 않고도 같은 결과집합을 출력하도록 아래 두 SQL 을 각각 재작성해라
(단 부분범위처리 불가능한 상황임, 즉 , 전체범위처리 기준으로 튜닝)
- 주문일자의 데이터 타입은 문자형 8자리
- 거래 업체는 10000개
- 월 평균 주문 건수는 100만건

1번 답안
SELECT 주문번호, 업체번호, 주문일자, 주문금액
     , count(*) over (partition by 업체번호) 총주문횟수
     , avg(주문금액) over (partition by 업체번호) 평균주문금액
     , max(주문금액) over (partition by 업체번호) 최대주문금액
 from 주문
where 주문일자 like '201509%'
order by 평균주문금액 desc


2번답안
SELECT 주문번호, 업체번호, 주문일자, 주문금액
FROM (
     select row_number() over (partition by 업체번호 order by 주문번호 desc) rnum
     from 주문
     where 주문일자 like '201509%'
)
where rnum = 1


2번 답안 -2
select 주문번호, 업체번호, 주문일자, 주문금액
from (
     select max(주문번호) over (partition by 업체번호) 마지막 주문번호
     from 주문
     where 주문일자 like '201509%'
)
where 주문번호 = 마지막 주문번호

실무적으로 활용도가 매우 높은 윈도우 함수를 적절히 구사할 줄 아는지 확인하는 단순한 문제임
참고로 SQL2는 모범답안 1이 제일 효과적 모범답안 2에 비해 소트 공간을 덜 사용하기 때문임


실기 4
주문 테이블 구조는 아래와 같으며 파티셔닝하지 않음

하루 주문 건수는 평균 2만 건이며 10년치 데이터가 저장되어 있음
주문 데이터를 조회하는 화면은 아래와 같음. 고객번호는 입력하지 않을 수 있으나, 주문일자는 항상 입력해야 함
주문일자로는 보통 3일을 입력하며, 최대 1주일까지 입력할 수 있음
1. 조회버튼을 누를 때 수행할 최적의 SQL을 작성해라
개발 정책 상 Dynamic SQL은 사용할 수 없음
주문일시 기준 역순으로 정렬해야 하며, 부분범위 처리는 허용되지 않음, 즉 조회된 결과 집합 전체를 그리드에 출력해야 함
2. 최적의 인덱스 구상안을 제시해라

모범답안 1
select 고객번호, 주문일시, 주문금액, 우편번호, 배송지
from 주문
where 고객번호 = nvl(:cust_no, 고객번호)
and 주문일시 >= to_date(:ord_dt1, 'yyyymmdd')
and 주문일시 < to_date(:ord_dt2, 'yyyymmdd') + 1
order by 주문일시 desc

모범답안 2
select 고객번호, 주문일시, 주문금액, 우편번호 배송지
from 주문
where 고객번호 = decode (:cust_no, null, 고객번호, :cust_no)
and 주문일시 >= to_date(:ord_dt1 , 'yyyymmdd')
and 주문일시 < to_date(:ord_dt2, 'yyyymmdd') + 1
order by 주문일시 desc

모범답안 3
select 고객번호, 주문일시, 주문금액, 우편번호, 배송지
from 주문
where :cust_no is not null
and 고객번호 = :cust_no
and 주문일시 >= to_date(:ord_dt1, 'yyyymmdd')
and 주문일시 < to_date(:ord_dt2, 'yyyymmdd') + 1
union all
select 고객번호, 주문일시, 주문금액, 우편번호, 배송지
from 주문
where :cust_no is null
and 주문일시 >= to_date(:ord_dt1, 'yyyymmdd')
and 주문일시 >= to_date(:ord_dt2, 'yyyymmdd') + 1
order by 2 desc

인덱스 구성안
X01 : 고객번호 + 주문일시
X02 : 주문일시

해설

옵션조건에 대한 최적 SQL 작성능력을 확인하는 문제임
고객번호처럼 조회조건 포함 여부를 사용자가 선택할 수 있는 옵션조건을 처리할 때 모범답안 3처럼 UNION ALL을 사용하면 가장 확실한 성능을 보장할 수 있음
오라클의 경우 NVL 또는 DECODE를 사용하면 옵티마이저가 UNION ALL 방식으로 자동 변환해줌
오라클도 모든 NV/DECODE를 UNION ALL로 변환해 주지는 않음
또한 조건절 컬럼이 NULL 허용 컬럼일 떄 NVL/DECODE를 사용하면 결과집합에 오류가 발생함
대개 옵션 조건이 여러 개이고 그 중 NULL 허용 컬럼을 포함할 수 있으므로 실무적으로 NVL/DECODE와 UNION ALL을 적절히 혼용해야 SQL을 최적화할 수 있음
다행히 본 문제에서는 옵션 조건이 하나뿐이고, Not Null 컬럼이므로 NVL/DECODE 사용이 가장 효과적임
프로그램 사용자가 고객번호를 입력할 때 가장 최적으로 수행하려면 인덱스를 고객번호 + 주문일시 순으로 구성해야 함
고객번호를 입력하지 않을 때는 주문일시만으로 조회하므로 인덱스를 주문일시 단일컬럼으로 구성하면 최적임
인덱스를 주문일시 + 고객번호 순으로 구성하면 2가지 케이스를 모두 처리할 수 있음
하지만, 특정 고객을 조회하고자 할 때마다 인덱스에서 평균적으로 60000건을 스캔해야 하므로 매우 비효율적임
주문일자에 최대 1주일까지 입력할 수 있다고 했으므로 이때는 140000건을 스캔해야 함
실무적으로 많이 사용하는 옵션조건 처리방안이 2가지 있음
첫째로 아래와 같이 OR 조건을 사용하는 방법
문제는 OR 조건을 사용했으므로 고객번호를 인덱스 조건으로 사용할 수 없다는 점
인덱스를 사용하면 