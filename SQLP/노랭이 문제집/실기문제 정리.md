실기 1
아래와 같은 월별 지점 메출 테이블을 읽어서 우측과 같은 형식 즉 각 지점별로 판매월과 함께 증가하는 누적매출(running total)을 구하는 SQL을 두가지 방식으로 작성해라
1. 윈도우 함수를 이용한 방식으로 작성
```
select 지점
     , 판매월
     , 매출
     , sum(매출) over (partition by 지점 order by 판매월) 누적매출
  from 월별지점매출  
```
또는 
```
select 지점
     , 판매월
     , 매출
     , sum(매출) over (partition by 지점 order by 판매월 range between unbounded preceding and current row) 누적매출
  from 월별지점매출; 
```
2. 윈도우 함수나 스칼라 서브쿼리를 지원하지 않는 DBMS에서 활용할 수 있는 방식으로 작성(단 전체범위처리에 최적화된 방식으로 작성할 것)

```
select t1.지점
     , min(t1.매출) 매출
     , sum(t2.매출) 누적매출
  from 월별지점매출 t1, 월별지점매출 t2
 where t2.지점 = t1.지점
   and t2.판매월 <= t1.판매월
group by t1.지점, t1.판매월
order by t1.지점, t1.판매월;
```
또는
```
select t1.지점
     , t1.판매월
     , sum(t2.매출) 누적매출
  from 월별지점매출 t1, 월별지점매출 t2
 where t2.지점 = t1.지점
   and t2.판매월 <= t1.판매월
group by t1.지점, t1.판매월, t1.매출
order by t1.지점, t1.판매월;
```
해설
- 누적 매출(running total)을 구할 때 윈도우 함수를 지원하는 DBMS 버전이라면 윈도우 함수가 가장 효과적이고 성능도 빠름
윈도우 함수를 사용할 떄는 partition by 절을 정확히 작성하는 것이 무엇보다 중요함
윈도우 함수를 지원하는 DBMS버전이라면 부등호 조인을 이용해 누적 매출을 구할 수 있음
스칼라 서브쿼리를 이용하는 방법도 있지만, 전체 범위 처리에 결코 효과적이지 못함


실기 2
아래 SQL 과 트레이스 결과를 분석해서 개선된 SQL을 작성해라
1. 원하는 실행계획이 정확히 나오도록 힌트를 함께 기술할 것
2. 최적화 인덱스 구성방안도 제시해라
```

create index 고객_idx on 고객(거주지역코드, 고객명);
create index 주문_idx on 주문(고객번호, 주문일시);

select /*+ leading(c) use_nl(o) index(c 고객) index(o 주문_idx)*/
from 고객 c, 주문 o
where o.주문일시 between to_date('20150301'.'yyyymmdd')
and to_date('20150314235959','yyyymmddhh24miss')
and o.고객번호 = c.고객번호
and (c.거주지역코드, c.고객명) in (('02','김철수'), ('05','홍길동'))
order by o.주문일시, c.고객명
```

고객 20여건을 읽어 주문과 조인한 후 최종적으로 5건을 출력하는 SQL문임
소량 데이터를 조인할 때는 가급적 인덱스를 이용한 NL 조인을 쓴다

고객 테이블에 인덱스를 사용하려면 거주지역코드와 고객명을 가공하지 않아야 함
문자열로 결합한 부분을 아래와 같이 변경하면 됨

and (c.거주지역코드, c.고객명) in (('02','김철수'),('05', 홍길동))

or 또는 UNION ALL 방식을 사용해도 성능은 같음. OR조건을 사용할 때는 가급적 USE_CONCAT힌트를 같이 사용하는 것이 좋음
인덱스는 거주지역코드 + 고객명 또는 고객명 + 거주지역코드  순으로 구성하면 됨

인덱스를 이용해 주문 테이블과 NL 조인하려면 고객번호 + 주문일시 순으로 인덱스를 구성해야 함
주문일시 + 고객번호 순으로 인덱스를 구성해도 인덱스 사용은 가능하나 Between 조건이 선두컬럼이므로 매우 비효율적임

실기 3
같은 데이터를 두번 읽지 않고도 같은 결과집합을 출력하도록 아래 두 SQL 을 각각 재작성해라
(단 부분범위처리 불가능한 상황임, 즉 , 전체범위처리 기준으로 튜닝)
- 주문일자의 데이터 타입은 문자형 8자리
- 거래 업체는 10000개
- 월 평균 주문 건수는 100만건

1번 답안
SELECT 주문번호, 업체번호, 주문일자, 주문금액
     , count(*) over (partition by 업체번호) 총주문횟수
     , avg(주문금액) over (partition by 업체번호) 평균주문금액
     , max(주문금액) over (partition by 업체번호) 최대주문금액
 from 주문
where 주문일자 like '201509%'
order by 평균주문금액 desc


2번답안
SELECT 주문번호, 업체번호, 주문일자, 주문금액
FROM (
     select row_number() over (partition by 업체번호 order by 주문번호 desc) rnum
     from 주문
     where 주문일자 like '201509%'
)
where rnum = 1


2번 답안 -2
select 주문번호, 업체번호, 주문일자, 주문금액
from (
     select max(주문번호) over (partition by 업체번호) 마지막 주문번호
     from 주문
     where 주문일자 like '201509%'
)
where 주문번호 = 마지막 주문번호

실무적으로 활용도가 매우 높은 윈도우 함수를 적절히 구사할 줄 아는지 확인하는 단순한 문제임
참고로 SQL2는 모범답안 1이 제일 효과적 모범답안 2에 비해 소트 공간을 덜 사용하기 때문임


실기 4
주문 테이블 구조는 아래와 같으며 파티셔닝하지 않음

하루 주문 건수는 평균 2만 건이며 10년치 데이터가 저장되어 있음
주문 데이터를 조회하는 화면은 아래와 같음. 고객번호는 입력하지 않을 수 있으나, 주문일자는 항상 입력해야 함
주문일자로는 보통 3일을 입력하며, 최대 1주일까지 입력할 수 있음
1. 조회버튼을 누를 때 수행할 최적의 SQL을 작성해라
개발 정책 상 Dynamic SQL은 사용할 수 없음
주문일시 기준 역순으로 정렬해야 하며, 부분범위 처리는 허용되지 않음, 즉 조회된 결과 집합 전체를 그리드에 출력해야 함
2. 최적의 인덱스 구상안을 제시해라

모범답안 1
select 고객번호, 주문일시, 주문금액, 우편번호, 배송지
from 주문
where 고객번호 = nvl(:cust_no, 고객번호)
and 주문일시 >= to_date(:ord_dt1, 'yyyymmdd')
and 주문일시 < to_date(:ord_dt2, 'yyyymmdd') + 1
order by 주문일시 desc

모범답안 2
select 고객번호, 주문일시, 주문금액, 우편번호 배송지
from 주문
where 고객번호 = decode (:cust_no, null, 고객번호, :cust_no)
and 주문일시 >= to_date(:ord_dt1 , 'yyyymmdd')
and 주문일시 < to_date(:ord_dt2, 'yyyymmdd') + 1
order by 주문일시 desc

모범답안 3
select 고객번호, 주문일시, 주문금액, 우편번호, 배송지
from 주문
where :cust_no is not null
and 고객번호 = :cust_no
and 주문일시 >= to_date(:ord_dt1, 'yyyymmdd')
and 주문일시 < to_date(:ord_dt2, 'yyyymmdd') + 1
union all
select 고객번호, 주문일시, 주문금액, 우편번호, 배송지
from 주문
where :cust_no is null
and 주문일시 >= to_date(:ord_dt1, 'yyyymmdd')
and 주문일시 >= to_date(:ord_dt2, 'yyyymmdd') + 1
order by 2 desc

인덱스 구성안
X01 : 고객번호 + 주문일시
X02 : 주문일시

해설

옵션조건에 대한 최적 SQL 작성능력을 확인하는 문제임
고객번호처럼 조회조건 포함 여부를 사용자가 선택할 수 있는 옵션조건을 처리할 때 모범답안 3처럼 UNION ALL을 사용하면 가장 확실한 성능을 보장할 수 있음
오라클의 경우 NVL 또는 DECODE를 사용하면 옵티마이저가 UNION ALL 방식으로 자동 변환해줌
오라클도 모든 NV/DECODE를 UNION ALL로 변환해 주지는 않음
또한 조건절 컬럼이 NULL 허용 컬럼일 떄 NVL/DECODE를 사용하면 결과집합에 오류가 발생함
대개 옵션 조건이 여러 개이고 그 중 NULL 허용 컬럼을 포함할 수 있으므로 실무적으로 NVL/DECODE와 UNION ALL을 적절히 혼용해야 SQL을 최적화할 수 있음
다행히 본 문제에서는 옵션 조건이 하나뿐이고, Not Null 컬럼이므로 NVL/DECODE 사용이 가장 효과적임
프로그램 사용자가 고객번호를 입력할 때 가장 최적으로 수행하려면 인덱스를 고객번호 + 주문일시 순으로 구성해야 함
고객번호를 입력하지 않을 때는 주문일시만으로 조회하므로 인덱스를 주문일시 단일컬럼으로 구성하면 최적임
인덱스를 주문일시 + 고객번호 순으로 구성하면 2가지 케이스를 모두 처리할 수 있음
하지만, 특정 고객을 조회하고자 할 때마다 인덱스에서 평균적으로 60000건을 스캔해야 하므로 매우 비효율적임
주문일자에 최대 1주일까지 입력할 수 있다고 했으므로 이때는 140000건을 스캔해야 함
실무적으로 많이 사용하는 옵션조건 처리방안이 2가지 있음
첫째로 아래와 같이 OR 조건을 사용하는 방법
문제는 OR 조건을 사용했으므로 고객번호를 인덱스 조건으로 사용할 수 없다는 점
인덱스를 사용하려면 주문일시 인덱스를 사용해야 하므로 사용자가 고객번호를 입력하더라도 주문일시 조건에 해당하는 데이터를 모두 액세스 하게 됨
따라서 고객번호처럼 변별력이 좋아 인덱스 활용성이 높은 컬럼에 OR 조건을 사용해선 안됨

```
select 고객번호, 주문일시, 주문금액, 우편번호, 배송지
  from 주문
 where (고객번호 = :cust_no :cust_no is null)
   and 주문일시 >= to_date(:ord_dt1, 'yyyymmdd')
   and 주문일시 < to_date(:ord_dt2, 'yyyymmdd') + 1
 order by 주문일시 desc
```

둘째, 아래와 같이 LIKE 조건을 사용하는 방법임
문제는 고객번호가 Number 형인 상황에서 LIKE 조건을 사용해지면 묵시적 형변환이 발생한다는 점임
따라서 고객번호를 선두로 갖는 인덱스로는 Index Range Scan이 불가능함
Indes Range Scan이 가능하게 하려면 주문일시 + 고객번호 순으로 인덱스를 만들어야 하므로, 인덱스 스캔 과정에 많은 비효율이 발생함

```
select 고객번호, 주문일시, 주문금액, 우편번호, 배송지
  from 주문
 where 고객번호 like :cust_no || '%'
   and 주문일시 >= to_date(:ord_dt1, 'yyyymmdd')
   and 주문일시 < to_date(:ord_dt2, 'yyyymmdd') + 1
order by 주문일시 desc
```

실기문제 5

데이터 모델은 아래와 같음

고객                       고객접속이력
고객번호                    접속일시
고객명                     고객번호
등록일시         -------   접속경로 
고객상태코드                  ...
연락처                      ...
주소                       ...

고객상태코드  = 'AC'인 고객을 조회해서 증록일시, 고객번호 순으로 출력하고자 함
출력하고자 하는 항목은 아래 그래드와 같고 가장 우측 최근접속일시는 최근 한달 이내 마지막 접속 일시를 의미
접속 이력이 없다면 Null을 출력함
한달 전 날짜를 구하는 함수 -> trunc(add_month(sysdate, -1))

조회 다음 버튼을 누르면 매번 20건씩 데이터를 읽어 그래드 화면에 추가하는 방식으로 화면 페이징 처리를 구현해야 하고, 파일로 출력 버튼을 누르면 전체 조회 데이터 파일로 일괄 저장하도록 구현
두 조회 버튼에 대한 최적의 SQL을 각각 작성, 최적의 인덱스 구성안


요건
각 조회버튼에 대한 성능요건
조회.다음 : 응답속도를 빠르게 튜닝하는 것이 가낭 중요
파일로 출력 : 전체 처리속도와 시스템 리소스 사용량을 최소화하는 것이 가장 중요

조회/다음 버튼 클릭 시 화면 페이징 처리 요건
조회/다음 버튼을 계속 눌려 뒤쪽 페이지로 많이 이동하는 경우가 간혹 있지만, 대개 3페이지 이내만 조히하고 멈추는 업무임(-> 페이지마다 인덱스 스캔 시작점을 찾기 위해 Union ALL 방식으로 복잡하게 구현하지 않아도 된다는 의미)
페이징 방식으로 조회하는 동안 새로운 데이터가 등로고디거나 기존 데이터가 삭제되는 경우를 고려하지 않아도 됨
향후에 혹시 인덱스 구성이 변경되더라도 결과 집합은 정확히 보장되도록 구현해야 함

View Merging Join Predicate Pushdown 등 Query Transformation이 작동하지 않는 DBMS 버전을 사용 중

인덱스 설계 시, 성능에 도움이 안되는 컬럼을 추가하면 오히려 감점이 될 수 있으므로 주의한다

병렬처리 불가

답안
[페이징 처리용 SQL]
select a.고객번호
     , a.고객명
     , a.등록일시
     , a.연락처
     , a.주소
     , (select max(접속일시)
          from 고객접속이력
         where 고객번호 = a.고객번호
           and 접속일자 >= trunc(add_months(sysdate, -1)) 최근접속일시
     )
 from (
     select rownum as no, a.*
       from (
          select 고객번호, 고객명, 등록일시, 연락처, 주소
            from 고객
           where 고객상태코드 = 'AC'
           order by 등록일시, 고객번호
       ) a
     where rownum <= :page * 20
 ) a
 where no >= (:page-1) * 20 + 1

파일 출력용 SQL
select a.고객번호, a.고객명, a.등록일시, a.연락처, a.주소, b.최근접속일시
  from 고객 a
     , (
          select 고객번호
               , max(접속일시) 최근접속일시
            from 고객접속이력
           where 접속일지 >= trunc(add_month(syusdate, -1))
           group by 고객번호
     )b
where a.고객상태코드 = 'AC'
  and b.고객번호 = a.고객번호
order by a.등록일시, a.고객번호

인덱스 설계
고객 인덱스 : 고객상태코드 + 등록일시 + 고객번호
고객접속이력 인덱스 : 고객번호 + 접속일시

해설
1.
화면 페이징 처리용 SQL을 정확히 작성해야 함
온라인 화면 페이징 처리용 SQL은 최초 응답속도 최적화(first_rows)목표에 맞게 SQL을 작성해야 함
인덱스를 이용해 부분범위 처리가 가능하도록 구현해야 함
모범답안으로 제시한 SQL의 유일한 단점은 앞 페이지에서 읽은 데이터를 다시 읽어야 하므로 뒤 페이지로 이동할수록 블록 I/O가 늘어난다는 점
하지만 뒤쪽 페이지로 이동하는 경우가 흔치 않다는 요건을 명시하였으므로 표준적인 페이지 처리 방안으로 가장 적합함
실제 대부분 시스템에서 이 방식을 사용하고 있음

참고로 앞 페이지에서 읽은 데이터를 다시 읽지 않게 구현하려면 UNION ALL 방식으로 매우 복잡하게 구현해야 함
실제 구현해 본 독자라면 order by를 명시할 수 없다는 사실을 알 것임
sort order by 연산이 나타나므로 의도했던 바와 다르게 전체범위처리가 불가피해기지기 때문임
결국 order by 절을 생략한 채 index 힌트를 이용해 정렬된 겨로가집합을 얻게 됨
향후에 혹시 인덱스 구성이 변경되기라도 하면 정확한 결과집합을 보장할 수 없게 되므로 시스템 운영 과정에 주의가 필요함

2.
화면페이징 처리용 SQL에서 최근접속일시는 맨 바깥쪽 SELECT-LIST에서 스칼라 서브쿼리로 구현해야 함
화면에서 출력하는 20건에 대해서만 스칼라 서브쿼리를 수행하도록 하기 위함임

3.
파일출력용 SQL을 정확히 작성해야 함 전체 데이터 출력용 SQL은 전체 응답속도 최적홤 목표에 맞게 SQL을 작성해야 함

4.
고객 인덱스를 정확히 설계해야 함
파일 출력용 SQL은 인덱스를 사용하면 오히려 비효율적임
따라서 인덱스는 화면 페이징 처리용 SQL에 최적화되도록 설계해야 한다
고객상태코드로 인덱스를 Range Scan하려면 선두 컬럼은 고객상태코드여야 함
부분범위 처리가 가능하게 하려면, order by절 컬럼인 등록일시, 고객번호를 뒤쪽에 추가하면 됨

5.
고객접속이력 인덱스를 정확히 설계해야 함
'='조건인 고객번호를 선두에 두고, 부등호 조건인 접속일지를 뒤쪽에 추가하면 됨

실기문제 6

주문 배송 고객 정보를 ㅇ릭어 주문배송 테이블에 입력하는 야간 배치 프로그램을 튜닝하려고 함
대상 주문 데이터는 2016년 6월부터 8월까지 3개월치임
월별 주문 건수는 1000만건
월별 배송 건수는 900만건임
배송은 주문이 완료된 후에 시작됨 고객 수는 500만명임

고객(고객번호, 고객명, 고객 연락처, 등록일시)
주문(주문번호, 주문일자, 주문고객번호, 주문상품수, 주문금액, 주문상태코드, 할인금액, 배송지주소코드, 배송지주소상세)
배송(배송번호, 주문번호, 배송일자, 배송상태코드, 배송업체번호, 배송기사연락처)

고객-주문은 1:N
주문-배송은 1:1

파티션 구성
주문 : 주문일자 기준 월단위 Range 파티션
배송 : 배송일자 기준 월단위 Range 파티션

인덱스 구성
주문테이블
주문_PK : 주문번호
주문_N1 : 주문상태번호 + 주문일자 -> Local Partition
주문_N2 : 주문고객번호 + 주문일자 -> Local Partition

배송테이블
배송_PK : 배송번호
배송_N1 : 주문번호 + 배송일자 -> Local Partition
배송_N2 : 배송일자 + 배송상태코드 -> Local Partition

고객테이블
고객_PK : 고객번호
고객_N1 : 고객명 + 고객번호

아래 병렬 SQL과 예상실행계획을 분석해 가장 빠르게 수행할 수 있도록 SQL 을 재작성해라
- 옵티마이저 힌트 변경이 필요하면 SQL 문장에 정확히 기술
- 야간 배치용 SQL이므로 다른 트랜잭션에 의한 동시 DML 없음
- 세션 파라미터 변경이 필요하면 설정 값 제시
- 인덱스 구성 변경이 필요하면 변경안 제시
- 파티션 구성은 변경 불가
- 시스템 운영 정책상 허용된 최대 Parellel Degree = 4

```
insert into 주문배송 t
select /*+ leading(o) use_nl(d) index(d) full(o) parallel(o 4)*/
       o.주문번호, o.주문일자, o.주문상품수, o.주문상태코드, o.주문고객번호
     , (select 고객명 from 고객 where 고객번호 = o.주문고객번호) 고객명
     , d.배송번호, d.배송일자, d.배송상태코드, d.배송업체번호, d.배송기사연락처
  from 주문 o, 배송 d
 where o.주문일자 between '20160601' and '20160831'
   and o.주문번호 = d.주문번호
```

답안

```
alter sessiobn enable parallel dml;

insert /*+ parallel(t 4)*/ into 주문배송 t
select /*+ leading(d) use_hash(o) use_hash(c)
           full(o) full(d) index_ffx(c)
           parallel(o 4) parallel(d 4) parallel_index(c 4)
       */
       o.주문번호, o.주문일자, o.주문상품수, o.주문상태코드, o.주문고객번호, c.고객명
       , d.배송번호, d.배송일자, d.배송상태코드, d.배송업체번호, d.배송기사연락처
  from 주문 o, 배송 d, 고객 c
 where o.주문일자 between '20160601' and '20160831'
   and o.주문번호 = d.주문번호
   and d.배송일자 >= '20160601'
   and c.고객번호 = o.주문고객번호
```
해설
1.
다른 트랜잭션에 의한 동시 DML이 없는 야간 배치용 SQL이므로 병렬 DML 활용이 가능함
병렬로 Insert 하려면 우선 아래와 같이 parall DML을 활성화해야 함

```
alter session enable parallel dml;
```

Oracle 11gR2부터는 enable_parallel_dml 힌트도 제공됨
parallel DML을 활성화 한 상태에서 insert 바로 뒤에 parallel 힌트를 추가하면 도ㅠㅣㅁ
3000만건 정도라면 Direct Path Load 기능만 활용해도 충분히 빠르게 Insert 할 수 있음
Direct Path Load 기능을 사용하려면 insert 바로 뒤에 append 힌트를 추가하면 됨
참고로 parallel Insert는 따로 append 힌트를 사용하지 않아도 기본적으로 Direct Path Load 방식으로 작동함

2.
인덱스를 이용한 NL 조인은 소량 데이터를 조인하는데 적합함
수십만건 이상 데이터를 조인할 때는 캐시 히트율이 좋지 않는 한 결코 빠른 성능을 기대할 수 없음
3000만 건에 이르는 데이터를 조인하면서 캐시 히트율이 좋기를 기대할 수는 없음
따라서 주문, 배송을 Full Scan과 해시 조인으로 유도해야 함
조건만으로 3개월치를 조회하는데 인덱스를 이용할 하등의 이유가 없음
예를 들어 어떤 초등학교에서 1층부터 6층까지 각 층을 한학년씩 사용한다고 한다
설문조사를 위해 3학년 학생 전체를 만나고자 할 떄 교무실에 비치된 학적부가 필요할까? 3층 전체를 스캔하는 것이 가장 빠름

3.
배송 테이블은 배송일자 기준으로 Range 파이션된 상태인데, 배송일자가 조건절에 없음
따라서 Full Scan으로 처리한다면 전체 파티션을 읽어야 함
3000만건 조인하기 위해 수십억 건을 읽어야 할 수도 있음
이 문제를 어떻게 해결할 수 있는가?
배송은 주문이 완료된 후에 시작된다는 데서 힌트를 얻을 수 있음
배송일자는 주문일자보다 크고 주문일자는 20160601보다 큼
따라서 배송일자도 20160601보다 큼
아래 조건절을 추가해 주면 전체 파티션을 읽지 않아도 됨

and 배송일자 >= '20160601'

설령 이 조건절을 추가하지 않아 전체 파티션을 읽더라도 인덱스를 이용한 NL 조인보다 Full Scan 해서 조인이 빠름

4.
스칼라 서브쿼리는 NL조인과 같은 방식으로 작동함
스칼라 서브쿼리는 입력 값과 결과 값이 PGA에 캐싱한다는 점이 다름
따라서 입력값 종류가 적을 떄 실제 조인 횟수를 줄여줌으로써 성능을 기대할 수 있음
여기서 고객 수가 500만명 이라고 명시함
스칼라 서브쿼리 캐싱효과가 도움이 되지 않는 상황임
따라서 고객에 대한 스칼라 서브쿼리를 일반 조인문으로 변경한 후 해시 조인으로 유도해야 함

5.
해시 조인이라고 해서 항상 Full Scan으로 처리해야 하는 것은 아니지만, 고객 테이블에는 조인 외에 다른 조건절이 없으므로 Full Scan을 피할 수 없음
그리고 고객명과 고객번호만 읽으면 되는 상황이므로 테이블 전체를 스캔할 필요 없이 고객_NL 인덱스를 Fast Full Scan 방식으로 처리하면 됨
인덱스 전체를 스캔하므로 인덱스 컬럼 순서 변경은 불필요함

6.
온라인 트랜잭션이 없는 야간 배치용 SQL이고 3000만건에 이르는 대용량 데이터를 조인해야 하므로 병렬처리를 활용하지 않을 이유가 없음
주문, 배송 테이블에 parallel 힌트를 사용하면 됨
고객 테이블은 인덱스만 읽도록 유도했으므로 병렬 처리를 위해 parallel_index 힌트를 사용해야 함(최근 버전에는 테이블이나 인덱스명을 지정하지 않고 아래와 같이 Degree 만 지정한 parallel 힌트를 사용할 수 있음)