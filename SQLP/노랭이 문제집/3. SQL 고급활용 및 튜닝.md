## SQL 고급 활용 및 튜닝

### 과목 3 SQL고급 활용 및 튜닝 내용입니다.

#### 1 데이터베이스 연결에 관한 내용
- 답 : 1 다중 사용자 환경에서 서버와 클라이언트간 연결 상태를 지속하면, 서버 자원 낭비를 하게됨
- 그렇다고 SQL을 수행할 때 마다 연결 요청을 반복하면 서버 프로세스의 생성과 해제도 반복하므로 성능에 좋지 않음
- 따라서 OLTP 성 애플리케이션에선 Connection Pooling기법 활용이 필수적
- 키워드 : Connection Pooling

#### 2 Oracle 이나 SQL server같은 데이터 베이스의 저장구조로 설명한 것중 부적절한 것
- 답 3 익스텐트 내 블록은 인접하나 익스텐트 끼리는 인접함
- 키워드 : 저장구조

#### 3 Redo 로그의 매커니즘 용어들에 대한 설명
- 답 1 Write Ahead Logging : 버퍼 캐시 블록을 갱신하기 전에 변경사항을 먼저 로그 버퍼에 기록해야하며, Dirty 버퍼를 디스크에 기록하기 전에 해당 로그 엔트리를 먼저 로그 파일에 기록해야함
#### 그외
- Log Force at Commit : 로그 버퍼를 주기적으로 로그 파일에 기록하되 늦어도 커밋 시점에는 반드시 기록해야 함을 뜻함
- Fast Commit : 사용자의 갱신 내용이 메모리 상의 버퍼 블록에만 기록된 채 아직 디스크에 기록되지 않았지만, Redo 로그를 믿고 빠르게 커밋을 완료하는 것을 의미
- delayed block cleanout : 오라클만의 독특한 매커닞므으로 변경된 블록을 커밋 시점에 바로 Cleanout(로우 Lock 정보 해제, 커밋 정보 기록)하지 않고 그대로 두었다가 나중에 해당 블록을 처음 읽는 세션에 의해 정리되도록 하는 것을 말함
- 키워드 : Redo 로그 및 정의

#### 4 메모리 구조에 대한 설명
- 답 4 Table Full Scan한 데이터 블록은 LRU end에 위치하기 때문에 버퍼 캐시에 오래 머물지 않음
- 키워드 : 메모리구조

#### 5 Response Time Analysis 성능관리 방법론을 설명할 때 아래 괄호안에 들어갈 가장 적절한 용어
- 답 1 CPU 2 Queue
- Response Time = Service Time + Wait Time = CPU Time + Queue Time

#### 6 하드 파싱의 발생 횟수, SQL 커서의 재사용성에 대한 내용
- 소프트파싱 : SQL 과 실행계획을 캐시에서 찾아 곧바로 실행단계로 넘어가는 경우
- 하드파싱 : SQL과 실행계획을 캐시에서 찾지 못해 최적화 과정을 거치고 나서 실행단계로 넘어가는 경우
- 답 1회 SQL 커서의 공유와 재사용성에 관한 문제임, 캐싱된 SQL 커서는 반복 재사용할 수 있을 뿐만 아니라 여러 세션 간 공유될 수 있음

#### 7 SQL 파싱에 관한 문제
- 캐시에서 SQL 과 실행계획을 식별하는 식별자는 SQL문장 그 자체이다. 따라서 옵티마이저는 문자 하나만 달라도 서로 다른 SQL로 인식해 각각 하드파싱을 일으키고 다른 캐시 공간을 사용함
- 답 1 : 1~3은. SQL 텍스트가 달라 하드파싱은 각각 일어나지만 의미상 차이가 없으므로 실행계획은 같음

#### 8 Literal 상수 조건을 사용하는 것이 더 낫거나, 바인드 변수를 사용하려고 애쓰지 않아도 되는 경우사용자의 입력 조건이 매우 다양해 조건절을 동적으로 구성하더라도, 조건절 비교만큼은 바인드 변수를 사용하려고 노력해야한다
- 답 3 
- 바인드변수 : 파라미터 Driven 방식으로 SQL을 작성하는 방법이 제공되는데 SQL과 실행계획을 여러개 캐싱하지 않고 하나를 반복 재사용하므로 파싱 소요시간과 메모리 사용량을 줄여줌

#### 9 쿼리 실행시 문제점
- Dynamic SQL 방식으로 코딩했지만, 바인드 변수를 사용했으므로, 불필요한 하드파싱이 많다고 말하기는 힘듬
- 바인드 변수를 사용했으므로 컬럼 히스토그램은 활용하지 못하나, 레코드 건수, 컬럼 값의 종류 등을 활용해 실행계획을 수립함
- 답 1, 2

#### 10 SQL 작성 방식에 대한 설명
- Static SQL은 PreCompile 과정을 거치므로 런타임시 안정적인 프로그램 Build가 가능함
- Dynamic SQL을 사용하면 애플리케이션 커서 캐싱이 작동하지 않는 경우가 있음
- 답 4 루프(Loop) 내에서 반복적으로 수행되는 SQL에 Dynamic SQL을 사용하면, 공유 메모리에서 캐싱된 SQL을 공유하지 못해 하드파싱이 반복적으로 일어남

#### 11 데이터베이스 Call 에대한 설명
- Parse Call : SQL 파싱을 요청하는 Call
- Execute Call : SQL 실행을 요청하는 Call
- Fetch Call : SELECT문의 결과 데이터 전송을 요청하는 Call
- 답 1, 3
- SELECT 문장을 수행할 땐 Parse Execute Fetch 순으로 Call 이 발생
- Group By 결과집합을 만드는 과정에서의 I/O 는 첫번째 Fetch Call 단계에서 일어남

#### 12 다음 중 SQL 트레이스에서 얻은 아래 Call statistics를 통해 얻을 수 있는 것
- Order by, groub by 등 데이터 정렬이 필요한 연산이 Call statistics를 판단할 수 없음

#### 13 부분범위 처리에 대한 설명
- 모든 데이터 처리가 서버 내에서 이루어지는 프로그램에선 부분범위 처리에 의한 성능 개선 효과가 일어나지 않음
- 답 2 Insert Into … SELECT 문장에서도 인덱스를 잘 활용하면 부분범위 처리에 의한 성능 개선 효과를 얻을 수 있다

#### 14 사용자 정의 함수의 성능 특성에 대한 설명
- 답 2,3
- SQL 을 포함하지 않은 형태의 사용자 정의 함수라도 문맥전환(Context switch)에 의한 부하가 발생하므로, 성능 저하가 발생함
- 작은 코드 테이블로부터. 코드명을 가져오는 경우 사용자 정의 함수보다는 스칼라 서브쿼리를 사용하여 캐싱 효과를 누리는 것이 성능상 유리
#### 사용자 정의 함수 프로시저는
- 내장함수처럼 Native코드로 완전 컴파일된 형태가 아니어서 가상머신 같은 별도의 실행엔진을 통해 실행됨
- 실행될때마다 컨텍스트 스위칭이 일어나며, 이 때문에 내장함수를 호출할 때와 비교해 성능을 상당히 떨어드림

#### 15 오라클에서 DB저장형 함수(사용자 정의 함수)를 사용할 때 성능이 저하되는 원인에 대한 내용
- 답 1 함수는 실행할때마다 컴파일하진 않는다.

#### 16 두 SQL 의 수행 성능을 비교한 내용
- 가입일자, 고객명을 선두로 갖는 인덱스를 사용한다면 ‘가’ SQL은 인덱스만 읽고 처리를 완료하므로 블록 I/O가 더 적게 발생함
- 가입일자만으로 구성된 단일 컬럼 인덱스를 사용한다면 두 SQL모두 테이블 액세스가 불가피하므로 블록 I/O는 똑같음
- ‘가’ SQL은 소트 공간에 고객명만 저장하면 되지만, ’나‘ SQL은 모든 컬럼을 저장해야 하므로 더 많은 소트 공간을 사용함
- ’나‘ SQL을 수행하면 조건절을 만족하는 모든 컬럼을 클라이언트에게 전송해야 하므로 네트워크 트래픽이 더 많이 발생

#### 17 I/O효율화 튜닝 방안으로 적절하지 않은 것
- 3 변경이 거의 없는 테이블까지 매일 통계정보를 수집할 필요가 없다
- 그외
- 필요한 최소 블록만 읽도록 쿼리를 작성함
- 전략적인 인덱스 구성은 물론 DBMS가 제공하는 다양한 기능을 활용
- 필요하다면 옵티마이저 힌트를 사용해 최적의 액세스 경로로 유도

#### 18 블록 I/O에 대한 설명으로 가장 부적절한 것
- 2 DIrect path i/O는 일반적으로 병렬 쿼리로 Full Scan을 수행할 때 발생함
#### 그외
- Single Block I/O는  한번에 I/O Call에 하나의 데이터 블록만 읽어 메모리에 적재하는 방식임
- MultiBlock I/O는 I/O Call이 필요한 시점에, 인접한 블록들을 같이 읽어 메모리에 적재하는 방식

#### 19 데이터베이스 I/O 원리를 설명한 것으로 가장 부적절한 것
- Multiblock I/O방식으로 읽더라도 Extent 범위를 넘어서까지 읽지는 않는다.
- 따라서 작은 Extent로 구성된 테이블을 Full Table Scan하면 I/O Call이 더 많이 발생함
- 반면 인덱스를 통한 테이블 액세스 시 Single Block I/O 방식을 사용하므로 Extent 크기가 I/O Call 횟수에 영향을 미치지 않음

#### 20 데이터베이스 I/O원리에 대한 설명으로 가장 부적절한 것
- 답 3 테이블 블록을 Scan할 때는 Sequential I/O 방식을, 인덱스블록을 스캔(Scan)할 때는 Random i/o 방식을 사용

#### I/O 튜닝의 핵심원리
- Sequential 액세스에 의한 선택 비중을 높임
- Random 액세스 발생량을 줄임

#### 21 Lock 경합에 의한 성능 저하를 최소화하기 위해 개발팀에 제시한 가이드라인으로 부적절한 것
- 답 3 select 문장에 for update문장을 사용하지 말것
- for update를 써야할때는 있는데, 성능을 이유로 이를 사용 못하게 한다면 데이터 정합성을 해칠 수 있다. 성능보다 중요한 것은 데이터 정합성임
- no wait이나 wait 옵션을 잘 활용하면, select for update 문장을 통해 오히려 동시성을 높일 수도 있음

#### 22 MS-SQL Server에서 아래 Update문과 블록킹 없이 동시 수행이 가능한 SQL문
- 블로킹이란 Lock 경합이 발생해 특정 세션이 작업을 진행하지 못하고 멈춰 선 상태를 말함
- 공유 Lock끼리는 호환되기 때문에 블로킹이 발생하지 않음
- 공유 Lock과 배타적 Lock은 호환되지 않아 블로킹이 발생할 수 있음
- 답 4 insert into emp (empno, ename, deptno, sal) values (8014, ‘이정훈‘, 40, 4000)
- —> 서로 간섭이 없이 수행이 가능한 쿼리끼리ㅇ

#### 23 PL/SQL -> MS - SQL Server T-SQL로 변환 For update 구문을 대신하기 위해 사용할 SQL Server 힌트로 적절한 것은?
- 답 1 from 고객 with(holdlock)
- 3 from 고객 with (ReadPast)
- READ PAST는 Lock이 걸린 행은 읽기 않고 건너뛰도록 하는 힌트
- TABLOCK은 테이블레벨 Lock을 설정하고자 할 때 사용하는 힌트
<br/>
- SQL Server의 공유 Lock은 트랜잭션이나 쿼리 수행이 완료될 때 까지 유지되는 것이 아니라 다음 레코드가 읽히면 곧바로 해제됨
- 단, 기본 트랜잭션 격리성 수준을 변경하지 않고도 트랜잭션 내에서 공유 Lock이 유지되도록 하려면 테이블 힌트로 Holdlock을 지정하면 됨
- 두 트랜잭션은 상대편 트랜잭션에 의한 공유 Lock이 해제되기만을 기다리는 교착상태를 방지하려곤SQL Server는 갱신 Lock을 두게 되었고, 이 기능을 사용하려면 updlock힌트를 지정하면 된다.

#### 24 아래와 같은 락(Lock)모니터링 결과가 발생할 수 있는 SQL로 가장 적절한 것

- 답 3 insert /*+APPEND*/ into EMP SELECT * FROM SCOTT.EMP;
- 테이블 Lock(TM Lock)이 Exclusive 모드이므로 Append모드로 입력한 3번 SQL 실행 후 Lock 발생현환을 모니터링한 결과임

#### 25 두 세션에서 각각 UPDATE문을 수행한 후의 오라클 Lock 관련 조회결과이다
- ㄱ ㄴ에 들어갈 내용
- 2 Row-X(SX) Exclusive
- Update 문은 TM Lock은 호환성이 있는 Row-X (SX)모드로, TX Lock은 호환성이 없는 Exclusive모드로 lock을 획득한다.

#### 26 트랜잭션의 특징으로 연결한 것
- 4 영속성-라, 일관성-나
- 트랜잭션의 주요 특징으로 원자성(atomicity), 일관성(Consistency), 격리성(Isolation), 영속성(Durability)이며 영문 첫글자를 따서 ACID라고 함

#### 27 100번 세션과 200번 세션에서 쿼리를 순차적으로 실행했을 때 가, 나
- 답 4 가 5, 나 1
<br/>

- 100번 세션의 트랜잭션 격리성 수준을 Serializable Read로 설정하였으므로 쿼리(1)은 5건이 출력되고 쿼리(2)는 Commit이 수행되어 트랜잭션 격리성 수준이 Read Committed 이므로 200세션의 결과가 반영되어 1건이 출력됨

- 낮은 단계에서 격리성 수준에서 발생할 수 있는 현상들
#### 1 dirty Read
- 다른 트랜잭션에 의해 수정됐지만 아직 커밋되지 않은 데이터를 읽는 것을 말함
#### 2 Non-Repeatable Read
- 한 트랜잭션 내에서 같은 쿼리를 두번 수행했는데 그 사이 다른 트랜잭션이 값을 수정 또는 삭제하는 바람에 두 쿼리 결과가 다르게 나타나는 현상
#### 3 Phantom Read
- 한 트랜잭션 내에서 같은 쿼리를 두번 수행했는데, 첫 번째 쿼리에서 없던 유령(Phantom)레코드가 두번째 쿼리에서 나타나는 현상을 말함

#### 28 대부분 DBMS가 채택하고 있는 기본 트랜잭션 격리성 수준(Transaction Isolation Level) 인 것
- 답 2 Read Committed
- 대부분 DBMS가 Read Committed을 기본 트랜잭션 격리성 수준으로 채택하고 있으므로 Dirty Read가 발생할까 걱정하지 않아도 되지만, Non-Repeatable Read, Phantom Read 현상에 대해선 세심한 주의가 필요하다.

#### 29 트랜잭션 동시성 제어에 대한 설명으로 부적절한 것
- 트랜잭션 격리성 수준
- Read Uncommitted
  - 트랜잭션에서 처리중인 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용
- Read Committed
  - 트랜잭션이 커밋되어 확정된 데이터만 다른 트랜잭션이 읽도록 허용함으로 Dirty Read를 방지해줌
- Repeatable Read
  - 트랜잭션 내에서 쿼리를 두번 이상 수행할 때 첫번째 쿼리에 있던 레코드가 사라지거나 값이 바뀌는 현상을 방지해줌
- Serializable Read
  - 트랜잭션 내에서 쿼리를 두번 이상 수행할 때 첫번째 쿼리에 있던 레코드가 사라지거나 값이 바뀌지 않음은 물론 새로운 레코드가 나타나지도 않음
<br/>

- 답 3 트랜잭션 격리성 수준(Transaction Isolation Level)을 상향 조정할수록 일관성은 높아지지만 동시성은 낮아짐

#### 30 EMP 테이블 7788번 사원의 SAL 값이 현재 1000인 상황에서 아래 TX1, TX2 두개의 트랜잭션이 동시에 수행됨.
- 양쪽 트랜잭션이 모두 완료된 시점에서 7788번 사원의 SAL값은 Oracle과 SQL Server 에서 각각 얼마인지 작성하라
  - 답 2000, 3000
- Oracle은 Update문장이 시작되는 시점을 기준으로 갱신 대상 레코드를 식별하므로 TX2 트랜잭션의 Update는 실패함
- 따라서 TX1 트랜잭션의 결과가 7788사원의 최종 결과가 됨
- SQL Server에서 TX2 트랜잭션은 TX1 트랜잭션이 완료될 떄 까지 기다림
- TX1이 끝났을 때 7788사원의 SAL값은 2000이므로 TX2 트랜잭션이 정상적으로 진행해 값을 3000으로 바꿈

#### 31 다중버전 동시성 제어(Multiversion Concurrency Control, 이하 MVCC)모델을 채택하는 DBMS가 늘고 있다. 다음 중 DBMS의 읽기 일관성 메커니즘을 설명한 것으로 부적절한 것은?
- 답 3 MVCC 모델은 기본적으로 완벽한 트랜잭션 수준 일관성을 보장함
- MVCC 모델은 문장 수준의 읽기 일관성을 완벽히 보장하지만, 트랜잭션 수준의 읽기 일관성을 보장하진 않음

### 옵티마이저 원리

#### 32 비용기반 옵티마이저(CBO)는 쿼리 최적화 과정에 비용(Cost)를 계산
- 비용과 거리가 먼것은?
- 답 2 데이터베이스 Call 발생량도 옵팉마이저의 중요한 비용 요소이다

#### 규칙기반 옵티마이저
- 다른말로 휴리스틱 옵티마이저라고 부름
- 미리 정해 놓은 규칙에 따라 액세스 경로를 평가하고 실행계획을 선택함
- 여기서 규칙이란 액세스 경로별 우선순위로, 인덱스 구조 연산자, 조건절 형태가 순위를 결정짓는 주 요인임

#### 33 규칙기반 옵티마이저가 사용하는 규칙으로 가장 부적절한 것은
- 해설 비용기반 옵티마이저가 사용하는 규칙을 찾으면 된다.
- 답 4 직급의 종류 갯수는 CBO가 사용하는 대표적인 규칙이다.

#### 34 전체범위 최적화(ALL_ROWS)방식의 옵티마이저 모드에 대한 설명으로 거리가 먼것
- 답 4 가장 빠른 응답속도를 목표로 한다.
- 전체범위 최적화는 빠른 Response Time보다 Throughput 중심으로 최적화를 시행

#### 35 비용기반 옵티마이저가(Cost-Based Optimizer)가 사용하는 비용 계산식
- (NDV = Number Of Distinct Value)
- 1 선택도 = 1 / NDV
- 4 선택도 = 카디널리티 = 총 로우수/NDV. 
- 선택도 -> 카디널리티 -> 비용 -> 액세스 방식, 조인 순서, 조인 방법 등 결정
카디널리티
- = 총로우수 * 선택도 = num_rows/num_distinct


#### 36 통계 정보 수집 시 부적절한 것
- 답 2 표본의 크기 : 가능 한 많은 양의 데이터를 읽도록 하게함

#### 37 동일한 결과를 반환하는 SQL 에서 가장 효율적인 것
- 답 2 문제 참고
- 3번은 View Merging이 발생하므로 함수호출 횟수가 1번과 같음
- 4번은 스칼라 서브쿼리의 캐싱효과를 이용해 함수 호출 횟수를 줄이려 했지만, 상품 테이블에서는 상품코드는 Unique하기 때문에 캐싱 효과가 없고 오히려 캐시를 탐색하는 비용만 추가됨
- 2번은 ROWNUM을 이용해 VIew Merging을 방지했으므로 성능 개선에 도움이 됨

#### 38 Oracle에서 no_merge 힌트를 사용하지 않고도 아래 SQL문에 뷰 머징이 발생하지 않게 하려고한다. ㄱ에들어갈 키워드 문제 내 쿼리 참조할것
- 답 2 ROWNUM
- 힌트를 사용하지 않고 뷰 머징을 하는 방법
- 집합 연산자(union, union all, intersect, minus)
- Connect by 절
- rownum pseudo 칼럼
- select-list에 집계함수(avg, count, max, min, sum)
- 분석 함수(Analytic Function)

#### 39 뷰 머징을 불가능하게 하는 경우
- 답 2 뷰 안에 Group By를 사용한 경우
- Group by 를 포함한 뷰는 자주 Merging이 발생

#### 40 SQL 에 대한 설명
- 문제 내 쿼리 확인
- 답 3 : emp 테이블에 deptno + job으로 구성된 인덱스를 만들면, job과 deptno 에 대한 조건 모두 인덱스 액세스 조건으로 사용가능함

#### 41 아래 SQL을 처리하는데 있어 옵티마이저가 선택할 수 있는 옵션
- 답 1 해당 답안 방식으로 처리할 경우, Cartesian Product가 발생할 수 있다.
- 1 두 인라인 뷰(Inline view)를 풀어 (VIew merging) 고객번호 조인을 먼저 처리한 후에 고객번호 group by하면서 과금액과 수납액을 구함.

#### 42 트레이스 결과에 따른 튜닝방안
- 쿼리는 책 참조
- 쿼리상 ERD에서 주문과 고객은 M:1 관계이고, 주문 테이블 고객번호 Null 값은 허용하지 않는다.
- SQL문에서 조인 조건 외에 어디서도 고객 테이블을 참조하지 않고 있음
- 따라서 고객과의 조인은 불필요하다.
- 답 4

#### 43 수평적 탐색과 수직적 탐색중 수평적 탐색의 시작지점 값
- 답 2 인덱스 정렬 순서 상 deptno = 20 and sal = 2000 조건을 만족하는 첫번 째 레코드
- 인덱스 정렬 순서 상 deptno and sal = 2000 조건을 만족하는 첫번 째 레코드에서부터 탐색을 시작함
- comm 조건이 less than or equal 인 점에 주목하자.
- comm 조건이 more than or equal이면, deptno = 20 and sal = 2000 뭉 comm = 100조건을 만족하는 첫번째 레코드에서부터 스캔을 시작함

#### 44 다음 중 아래와 같은 인덱스 상황에서 index Range scan이 불가능한 SQL은?
```
Create index emp_idx on emp(deptno, job, ename);
```
- index range scan은 인덱스 루트 블록에서 리프 블록까지 수직적으로 탐색한 후에 리프 블록을 필요한 범위만 스캔하는 방식
- 답 4 책 쿼리 참조
- Index Range Scan이 가능하려면 인덱스 선두 컬럼이 조건절에 사용되어야 한다

#### 45 다음 중 힌트를 사용하더라도 index skip scan방식으로 실행되지 않는 SQL인 것은?
```
create index 고객_x01 on 고객(거주지역, 성별, 가입일자);
create index 고객_x02 on 고객(고객등급, 생일);
```
- 답 4 
```
select * from 고객
where 고객등급 in (‘A’,’B’,’C’)
And 생일 = ‘0326’
```
- index Skip scan을 활용하려면 인덱스 선행 컬럼이 누락됐거나, 부등호, between, like 같은 범위검색 조건이어야 함
- 1번의 경우, 인덱스 선두 컬럼이 사용됐지만 성별 칼럼이 조건에서 누락됐으므로 index skip scan활용이 가능함

#### index skip scan
- 루트 또는 브랜치 블록에서 읽은 칼럼 값 정보를 이용해 조건에 부합하는 레코드를 포함할 “가능성이 있는” 하위 블록(브랜치, 또는 리프)만 골라서 액세스하는 방식

#### index full scan
- 수직적 탐색 없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식으로, 대개는 데이터 검색을 위한 최적의 인덱스가 없을 때 차선으로 선택됨

#### index unique scan
- 수직적 탐색으로만 데이터를 찾는 스캔방식으로 unique 인덱스를“=”조건으로 탐색하는 경우에 작동함

index fast full scan은
index full scan보다 빠름
Index fast full scan이 index full scan보다 빠른 이유는 인덱스 트리 구조를 무시하고, 인덱스 세그먼트 전체를 Multiblock Read방식으로 스캔하기 때문


#### 46 다음 중 인덱스 구성이 아래와 같을 때 SQL을 처리하는 방법

```
create index emp_x01 on emp(deptno, sal);

select empno, ename, deptno, sal
from emp
where sal between 2000 and 4000
```
- 답 : 2,4
  - sal 컬럼을 선두로 갖는 인덱스가 없으므로 range scan은 사용할 수 없다.
  - fast full scan은 인덱스에 포함된 칼럼으로만 조회할 때 사용

#### 47 다음 중 비트맵 인덱스에 대한 설명으로 가장 부적절한 것음?
- 답 1 B*tree 인덱스에 비해 테이블 Random 액세스를 획기적으로 줄여주므로 성별처럼 Distinct Value 개수가 적은 컬럼애도 좋은성능을냄
  - 성별처럼 Distinct Value 개수가 적은 컬럼에 사용할 때 B*tree 인덱스보다 훨씬 적은 공간을 차지하기 때문에 유리하지만, 테이블 Random액세스 발생 측면에선 그다지 잇점이 없다.
#### 비트맵 인덱스
- 비트맵 인덱스는 Lock에 의한 DML 부하가 심한 것이 단점이다
- 레코드 하나만 변경되더라도 해당 비트맵 범위에 속한 모든 레코드에 Lock이 걸림
- OLTP성 환경에 비트맵 인덱스를 쓸 수 없는 이유가 여기 있다
- 비트맵 인덱스는 읽기 위주의 대용량 DW(특히, OLAP) 환경에 아주 적합하다.

#### 48 다음 SQL을 처리하기에 가장 효율적인 인덱스 구성을 고르시오
- 쿼리 책 참조
  - 답 2 계좌번호 + 주문일자 + 지점코드
  - 계좌번호 = , 지점번호 between 조건만으로도 충분히 스캔범위를 줄일 수 있다.

#### 49 다음 중 아래 SQL문을 튜닝하기 위한 분석을 진행 중 분석한 내용으로 가장 부적절한 것은?
- 3 SQL문장에 [배송상태 = 'ING'] 조건절이 없다면 테이블은 액세스 하지 않아도 된다.
  - 배송상태 = 'ING' 조건절이 없더라도 고객ID, 연락처, 고객 등급을 읽기 위해 테이블을 액세스해야 한다.

#### 50 성능 향상을 위해 아래 왼쪽 SQL을 오른쪽과 같이 변환한다. 인덱스 구성을 보기와 같이 1234순으로 바꿔가며 SQL을 실행할 때, 오른쪽 변환된 SQL의 블록 I/O가 오히려 늘어나는 인덱스 구성을 2개 고르시오
- 답 1, 3
  - 1 가입일자
  - 1번과 같은 인덱스 구성에서 SQL을 오른쪽과 같이 변환하면 인덱스에서 가입일자 LIKE 조건에 해당하는 범위를 2번 스캔함
    - 고객등급을 테이블에서 필터링하므로 테이블 Random액세스량도 2배 증가함
  - 2번과 같은 인덱스 구성에서는 SQL을 변환하기 전 후 블록 I/O 발생량이 거의 동일
  - 3번과 같은 인덱스 구성에서는 고객 등급을 인덱스에서 필터링하므로 테이블 Random액세스량은 늘지 않지만, 인덱스에서 같은 범위를 2번 스캔하므로 블록 I/O가 오히려 늘어난다
  - 4번과 같은 인덱스구성에서는 SQL을 변환한 후 블록 I/O 발생량이 크게 줄어듬

#### 51 아래 트레이스 결과를 가장 적절히 설명한 보기 2가지
- 답 2,4
  - TAB1_X01 인덱스의 클러스터링 팩터는 매우 나쁜 상태이다. 테이블 액세스 횟수만큼 블록 I/O가 발생하는 것을 통해 이를 알 수 있다.
  - 511개 인덱스 블록을 스캔했는데, 이것은 인덱스 스캔 과정에서 얻는 266, 476개 레코드 수에 비하면 그리 큰 수치는 아님
  - 비효율이 크기 않다는 뜻임.
  - TAB1_X01 인덱스 컬럼 순서를 조정하면 블록 I/O가 약간 감소할 수 있을지 모르지만, 전체 성능에 미치는 영향은 크지 않을 것
- 2 TAB1_X01 인덱스 컬럼을 추가하면 성능을 높이는 데 매우 큰 도움이 됨
- 4 CPU Time과 Elapsed Time 간 39초 가량 차이가 발생한 이유는 27000여 개 디스크 블록을 읽기 위한 I/O Call 과정에 발생한 대기 현상때문일 가능성이 가장 높음

##### 인덱스 설계를 위해 고려해야 할 요소
- 쿼리 수행 빈도
- 업무상 중요도
- 클러스터링 팩터
- 데이터량
- DML 부하(= 기존 인덱스 개수, 초당 DML 발생량, 자주 갱신되는 칼럼 포함 여부 등)
- 저장공간
- 인데긋 관리 비용 등

#### 52 다음 중 SQL에 사용된 다양한 액세스 유형을 분석해 시스템 전체적인 관점에서 전략적인 인덱스 설계를 하려고 함, 결합 인덱스 키 칼럼을 선정하는데 있어 가장 중요한 선택 기준 두가지를 순서대로 나열한 것.
- 답 3 : 인덱스를 설계하는 가장 중요한 선택 기준은, 조건절에 항상 또는 자주 사용되는지 여부와 '='

#### 53 다음 아래 인덱스 구성과 SQL을 고려할 때 실행계획 맨 아래(ID=5) 주문_IDX 인덱스의액세스 조건으로 가장 적절한 것?
- 책 쿼리 참조
- 답 3
  - 상품코드는 인덱스 구성컬럼이 아니므로 주문 테이블 액세스(ID=1) 단계의 필터조건임

#### 54 SQL 트레이스를 수집한 결과 Row Source Operation이 아래와 같았음 튜닝을 위해 가장 우선적으로 검토할 사항으로 가장 적절한 것
- 책 쿼리 참조
- 답 2 고객_IDX 인덱스에 칼럼을 추가함
  - 고객_IDX가 연령 고객 등급 구성이라면 순서를 바꿨을 때 액세스량 개선 가능

#### 55 테이블 인덱스 구성은 아래와 같다. INDEX RANGE SCAN으로 데이터를 액세스할 수 있는 SQL로 가장 적절한 것?
- 책 보기 확인
- 답 3 SELECT * FROM 고객 WHERE 직업코드 IS NULL
  - 직업코드 조건으로 인덱스를 Range Scan하려면 직업코드를 선두로 갖는 인덱스여야 함
  - 고객_X01 인덱스가 여기에 해당함
  - 인덱스 구성컬럼 중 하나라도 NOT NULL이면 IS NULL 조회에 인덱스를 사용할 수 있다.
  - 따라서 직업코드 IS NULL 조회에 고객_X01인덱스를 사용할 수 있다.

#### 56 Oracle에서 TAB1 TAB2 순으로 NL 조인하도록 유도하고 싶다. 다음 중 ㄱ안에 넣을 바른 힌트 사용법?
- 책 쿼리 확인
- 답 1, 3
  - 1 ORDERED USE_NL(B)
  - 3 LEADING(A USE_NL(B)
- 테이블 Alias가 있는 상황에선 반드시 Alias를 사용해야 함


#### 57 hasn join에 대한 설명으로 가장 부적절한 것
- 답 2,3
- 2 일반저긍로 큰 집합으로 해시 테이블을 생성하고서 작은 집합을 읽으면서 이 해시 테이블을 탐색하는 게 유리하다
- 3 OLTP환경에서 수행빈도가 아주 높은 쿼리라도 부담 없이 사용할 수 있다

#### hash join 성능을 좌우하는 키 포인트
- 1 한쪽 테이블이 가용 메모리에 담길 정도로 충분히 작아야 함
- 2 built input 해시 칼럼에 중복 값이 거의 없어야 함

#### hash join 선택 기준
조인 칼럼이 적당한 인덱스가 없어 NL Join이 비효율 적일 때
조인 칼럼에 인덱스가 있더라도 NL Join드라이빙 집합에서 Inner 쪽 집합으로의 조인 액세스량이 많아 Random액세스 부하가 심할 때
Sort merge join 하기에는 두 테이블이 너무 커 소트 부하가 심할 때
수행 빈도가 낮고 쿼리 수행시간이 오래 걸리는 대용량 테이블을 조인할 때

#### 스칼라서브쿼리
- 서브쿼리중 함수처럼 한 레코드당 정확히 하나의 값만을 리턴하는 서브쿼리를 스칼리 서브쿼리라고 함
- 스칼라 서브쿼리는 주로 select-lost 에서 사용되나 몇 가지 예외사항을 뺀다면 칼럼이 올 수 있는 대부분의 위치에서 사용 가능함

#### 58 다음중 스칼라 서브쿼리의 특징을 설명한 것으로 가장 부적절한 것

- 답 4 입력 값과 출력 값을 Shared pool 에 있는 Result cache에 캐싱했다가 같은 입력 값에 대해서는 캐상된 값을 리턴함으로 조인 부하를 줄여준다
- Result Cache가 아니라 PGA에 캐싱한다.

#### 59 다음 중 아래 SQL1 와 SQL2의 실행계획에 대한 설명으로 부적절한 것
- 쿼리 참조
- 답 3 SQL2 는 v_판매시작일자 변수에 오랜 과거일자를 입력할 때 보다 최근일자를 입력할 때 비효율이 더 적다

- 해설 : 대량 집합을 기준으로 NL조인하면 많은 랜덤 I/O가 발생한다.
- SQL1에서 판매시작일자 조건을 만족하는 상품 건수가 적다면, 일별매출보다 상품 테이블을 먼저 드라이빙 하는게 유리할 수 있다.
- SQL2에서 v_판매일자시작 변수에 최근일자를 입력하면 판매시작일자 조건을 만족하는 상품건수가 적어지므로 그만큼 비효율이 커짐. 기준일자 Between 조건에 해당하는 많은 일별 매출데이터를 읽고 Group By처리까지 마쳤는데, 상품 테이블과 조인하는 과정에 많은 데이터가 필터링되기 때문

#### 60 다음 중 아래와 같은 SQL에서 가능한 조인 방법
- 답 : 2 nested loop join, sort merge join
- 해설 : 다른 방법인 hash join의 경우 = 조건일때만 가능하다. 현재쿼리에서 나머지는 다 가능

#### 61 고객 테이블 2개의 변경이력이 있음
- 시작일자, 종료일자는 선분이력으로 관리되고 즉 시작일자에는 이력 레코드생성일자, 종료일자에는 처음99991231로 입력되었다 다음 번 새 이력 레코드가 생성되는 순간 바로 전 일자로 갱신됨
- 세테이블에서 이름이 홍길동인 고객의 1998 05 29 일자 고객등급과 전화번호를 조회하려고하면 아래 ㄱ에 들어갈 조건절로 적절한 것
- 쿼리 책 참고
- 답  3 선분 이력 각각을 between으로 조회하면 됨

#### 62 다음 중 Local 파티션 인덱스의 특징과 거리가 먼 것
- 3 local 파티션 인덱스의 경우, 테이블 파티션 키(=인덱스 파티션 키)가 인덱스 키 선두 컬럼에 위치해야함 예를들어 테이블과 인덱스 파티션키가 ‘주문일자’면 local 파티션 인덱스 키는 ‘주문일자‘로 시작해야 함

#### local 파티션 인덱스
- 테이블 파티션과 1:1로 대응되도록 파티셔닝한 인덱스
- 인덱스 파티션 키를 사용자가 따로 지정하지 않으며, 테이블과 1:1관계를 유지하도록 DBMS가 자동으로 관리해줌
- SQL server 에선 정렬된(aligned) 파티션 인덱스라고 부름

#### 63 우리가 개발하고자 하는 시스템은 업무적으로 7~9월에 매출이 집중돼 있다. 매출 연월일 기준으로 파티션에 데이터를 고르게 분산저장하고자 한다면, 다음중 사용할 파티션 전략은?

- 1 range 파티션
- 2 list 파티션

- list 파티셔닝과 Range 파티셔닝 모두 가능하다. Range 파티셔닝의 경우, 예를들어 
- 매년 1~3 4~6 7,8,9,10~12월 6개로 파티셔닝하면 됨
- hash 파티셔닝은 정해진 파티션 갯수로 파티션 키 값에 따라 EDMS가 기계적으로 분할 저장하기 때문에 월별 매출 특성을 고려한 파티셔닝을 하기가 곤란함

### Oracle이 지원하는 파티션 유형
- 1 Range 파티셔닝
  - 파티션 키 값이 범위(Range)로 분할
  - 파티셔닝의 가장 일반적인 형태이며, 주로 날짜 칼럼을 기준으로 함예) 판매 데이터를 월별로 분할
- 2 hash 파티셔닝
  - 파티션 키 값에 해시 함수를 적용하고 거기서 반환된 값으로 파티션 매핑
  - 데이터가 모든 파티션에 고르게 분산되도록 DBMS가 관리
  - 파티션 키의 데이터 분포가 고른 칼럼이어야 효과적
- -> 고객번호 주문일련번호
- 병렬처리 시 성능효과 극대화
- DML 경합 분산에 효과적
- 3 List 파티셔닝
  - 불연속적인 값의 목록을 각 파티션에 지정
  - 순서와 상관없이 사용자가 미리 정한 그룹핑 기준에 따라 데이터 분할 저장

- 4 Comotsite 파티셔닝
  - Range나 List 파티션 내에 또 다른 서브 파티션(Range Hash List)구성
  - Range + List 또는 List + hash 등
  - Range나 List 파티션이 갖는 이점 + 각 서브 파티션 구성의 이점

#### 64 테이블 tab1에 다음과 같은 데이터가 존재할 경우 올바르게 설명한 것
- 3 select sum(col2 + col3 ) from tab1 의 결과는 90이다

- 컬럼끼리 연산할 때 null을 포함하면 결과는 null이다
- 레코드끼리 연산할 때 null을 포함하면 null이 아니며 이유는 null을 연산에서 제외하기 때문

- 소트와 관련된 오퍼레이션 유형
- 1 sort aggregate
  - 전체 로우를 대상으로 집게를 수행할 때 나타나며, oracle 실행계획에 sort라는 표현이 사용됐지만, 실제 소트가 발생하지 않는다

- 2 sort order buy
  - 정렬된 결과집합을 얻고자 할 때

- 3 sort group by
  - Sorting 알고리즘을 사용해 그룹별 집계를 수행할 때 나타남

- 4 sort unique
  - 선택된 결과집합에서 중복 레코드를 제거하고자 할때 나타남
  - Union 연산자나 아래와 같이 Distinct 연산자를 사용할 때가 대표적

- 5 sort join
  - sort merge join을 수행할 때 나타남

- 6 window sort
  - 윈도우 함수를 수행할 때 나타남

#### 65 다음 중 아래 실행계획과 보기의 SQL을 서로 연결할 때 보기 SQL 중 실행계획이 없는것은?
- 답 4 select empno, ename, sal, avg(sal), over(partition by deptno) from emp;
- 윈도우 함수가 사용된 SQL실행계획에서는 WINDOW sort 오퍼레이션이 나타남

#### 66 다음중 정렬(sort) 오퍼레이션을 포함하지 않는 SQL문
- 답 2 
```
select * from emp where deptno = 20
Union all
Select * from emp where deptno = 30
```
- union all 은 정렬 오퍼레이션을 발생시키지 않음
- 4번 option구문은 오라클 ordered use_merge 에 해당하는 ms-sql server 힌트임
- sort merge 조인이므로 정렬 오퍼레이션이 발생함

#### 67 다음 중 아래 ERD와 DIctionary 조회 결과를 고려할 때 보기 중 union 대신 union all을 사용해도 가능한 것으로 가장 적절한 것
- 답 4 
```
select empno, job, mgr from emp where deptno = 10
Union
Select empno, job, mgr from emp where deptno = 20;
```
- union을 union all로 대체하려면 아래 두 조건을 만족해야함
- 1번은 위아래 두 집합이 배타적이어야함
- 2번은 위아래 각 집합에 중복값이 없어야 함
- 3번은 위애라 두 집합이 서로 배타적이지만 각 집합에 중복값이 있을 수 있음
- 4번은 pk 컬럼을 포함하기 때문에 모든 레코드가 완전 배타적

#### 68 모니터링 결과 아래 쿼리의 수행 빈도가 가장 높아 시스템에 미치는 영향이 큰 것으로 조사됨, 당음 중 고려할 튜닝 방안으로 부적절한것은?
- 답 1 rownum 조건을 인라인 뷰 안에 사용함
  - 1번 방식으로 처리할 경우 결과가 틀릴 수 있음

#### 69 다음 중 아래 고객과 고객변경이력 테이블에서 전체 고객을 대상으로 2010년 12월 4일자 이력을 조회하려고 할 때 가장 효과적인 것
- 책 내 그림, 쿼리 참조
- 답 3 1번은 Random 액세스 방식이므로 전체 고객을 대상으로 조회할 대 비효율 적. 2번은 고객 변경 이력 테이블을 2번 액세스 하는 비효율이 있음
4번은 Top - N 쿼리 알고리즘이 작동하지 않아 3번에 비해 소트 부하가 있음

#### 70 아래 SQL은 v_주식선물구분 바인드 변수 입력에 따라 선택적으로 주식 우러별 시세 또는 선물월별시세 테이블에 데이터를 입력함.
- 실행 정보와 같이 바인드 변수를 입력하고 쿼리를 100번 (SID=100)과 200번 (SID = 200) 세션에서 순차적으로 수행하였을 때 200번 세션의 상태로 올바른 것?
- 쿼리 책 참고
- 답 3 TM락을 Exclusive 모드로 요청하고 대기함
- Insert ALL구분에 Append 힌트를 사용하면, 모든 테이블에 Exclusive 모드의 TM락이 설정됨

#### 오라클에서 Direct path insert방식으로 데이터를 입력하는 방법
- insert select 문장에 /*+ append*/힌트 사용
- 병렬모드로 insert
- direct 옵션을 지정하고 SQL *Loader(sqlldr)로 데이터 로드
- CTAS(create table as select) 수행

#### 71 다음 중 오라클에서 아래와 같이 nologging옵션과 append 힌트를 사용하여 대용량 데이터를 insert할 때 극적인 성능개선 효과를 가져오는 원리를 설명하는데 가장 부적절한 것
- 쿼리 책 참조
- 답 1 lock을 사용하지 않고 빠르게 입력
- append모드로 insert 하면 exclusive모드 테이블 lock이 걸림 

#### 72 다음 중 DML 튜닝 방안으로 가장 부적절한 것은?
- 답 2
  - 대량의 데이터를 빠르게 UPDATE하기 위해 테이블은 nologging모드로 변경하고 작업을 시작함
- nologging모드는 INSERT문일 때만 기능이 작동한다.
- 대량의 데이터를 일반 Update문으로 갱신하면 상당히 오랜 시간이 소요될 수 있다.
- 다음과 같은 이유 떄문이며 DELETE문도 마찬가지임
  - 테이블 데이터를 갱신하는 본연의 작업
  - 인덱스 데이터까지 갱신
  - 버퍼 캐시에 없는 블록을 디스크에서 읽어 버퍼 캐시에 적재한 후 갱신
- 내부적으로 Redo와 Undo정보 생성
- 블록에 빈 공간이 없으면 새 블록 할당
  - (Row -> Migration)

#### 73 다음 중 (a), (b) 두 SQL에 대한 설명으로 부적절한 것?
- 책 쿼리 참조
- 답 3 둘다 해시 방식으로 조인한다면 아무리 처리량이 많아도 성능에 차이가 없다.
- (A)의 서브쿼리를 세미조인 방식으로 변경해도 조인에 참여하는 테이블이 더 많으므로 (B)보다 I/O가 더 많이 발생함

#### 74 야간에 단독으로 DML을 수행하는 대용량 배치 프로그램 속도를 향상시키려고 한다. 다음 중 고려할만한 튜닝 방안으로 가장 부적절한 것?
- 3 Oracle이면 update문을 수행하기 전에 테이블을 nologging모드로 변경함
- Oracle에서 nologging기능은 insert문장에만 효과가 있다.

#### 75 다음 중 테이블 또는 인덱스를 파티셔닝하는 이유로 가장 부적절한 것?
- 2 저장 효율 개선
  
#### 파티셔닝이 필요한 이유
- 관리적 측면
  - 파티션 단위 백업, 추가, 삭제, 변경
- 성능적 측면
  - 파티션 단위 조회 및 DML 수행, 경합 및 부하 분산

#### 76 다음 중 파티션에 대한 설명으로 가장 부적절한 것?
- 3 파티션 컬럼에 대한 검색 조건을(변수가 아닌) 상수값으로 제공해야 Partition Pruning이 작동함
- 파티션 컬럼에 대한 검색조건을 바인드 변수로 제공하더라도 Partition Pruning은 작동함

#### 77 다음 중 아래와 같이 주문 테이블을 생성하고 주문 데이터가 월 평균 100만 건이라고 가정할 때, 보기 중 블록 I/O측면에서 비효율이 없는 SQL을 2개 고르시오
- 책 쿼리 참조
- 답 1,2
- 3은 파티션 키 칼럼을 가공했으므로 모든 파티션을 Full Scan 하게 된다.
- 4은 주문 테이블이 월단위로 파티션돼 있는데, 일 단위로 조회 조건을 제공하므로 각 월에 속한 일자 갯수만큼 파티션 full Scan을 반복하게 됨

#### 78 거래 테이블이 아래와 같을 때, 다음 중 Local Prefixed 파티션 인덱스로 가장 적절한것?
- 책 쿼리 참조
- 답 1 create index 거래_N1 on 거래(거래일시) local;

#### 파티션 인덱스
- Local Prefix 파티션 인덱스
- Local NonPrefixed 파티션 인덱스
- Global Prefixed 파티션 인덱스
- Global NonPrefixed 파티션 인덱스(-> Oracke Not Support)
- 비파티션 인덱스

#### 79 다음 중 아래 DDL 스크립트를 보고 보기 중 거래_IDX1과 거래_IDX2 인덱스 각각에 해당하는 가장 적절한 인덱스 유형을 2개 고르시오
- 책 쿼리 참조
- 답 1,4
- 1 Global Prefixed
- 4 Local NOnprefixed
- Global 파티션 인덱스인 거래_IDX1의 파티션 키는 거래일자이고 파티션 키가 인덱스 선두컬럼이므로 Prefixed 파티션임
- 거래_IDX2는 Local 인덱스이므로 파티션 키는 거래일자가 됨 파티션 키가 인덱스 선두컬럼이 아니므로 Nonprefixed 파티션임

#### 80 배치 프로그램 튜닝 방안으로 부적절한 것?
- 답 1 시스템 사용자의 업무가 종료되자마자, 동시에 수행 가능한 모든 배치 프로그램을 집중적으로 수행함으로 총 소요시간을 단축함
- 같은 시간대에 수많은 프로그램이 집중적으로 수행되면 총 수행시간이 더 늘어남
- 자원(cpu, memory, Disk등)과 Lock(Latch와 같은 내부 Lock 포함)에 대한 경합이 발생하면서 프로세스가 실제 일한 시간보다 대기하는시간이 더 많아지기 때문

#### 배치 프로그램의 특징
- 사용자와 상호작용없이
- 대량의 데이터를 처리하는
- 일련의 작업들을 묶어
- 정기적으로 반복수행하거나
- 정해진 규칙에 따라 자동으로 수행

#### 81 다음 중 오라클 병렬 프로세싱에 대한 설명으로 부적절한 것
- 답 4 병렬 UPDate는 Redo Log를 생성하지 않는다.
- 테이블을 nologging모드로 바꾸면 Redo Log가 생성되지 않도록 할 수 있지만, 이 기능은 append 또는 parallel 힌트를 사용해 DIrect Load insert할 때만 작동함

#### 82 생략

#### 옵티마이저의 선택을 무시하고 사용자가 직접 조인을 위한 데이터 분배 방식을 결정할 수 있음
- 옵티마이저가 파티션된 테이블을 적절히 활용하지 못하고 동적 재분하을 시도할 때
- 기존 파티션 키를 무시하고 다른 키 값으로 동적 재분할하고 싶을 떄
- 통계정보가 부정확하거나 통계정보를 제공하기 어려운 상황(-> 옵티마이저가 잘못된 판단을 하기 쉬운 상황)에서 실행계획을 고정시키고자 할 떄
- 기타 여러가지 이유로 데이터 분배방식을 변경하고자 할 떄