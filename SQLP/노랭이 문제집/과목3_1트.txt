1. 1(o)
2. 3(O)--> 블록과 익스텐트를 햇갈리지말것
3. 1(O)
- Log Force at Commit : 로그 버퍼를 주기적으로 로그 파일에 기록하되 늦어도 커밋 시점에는 반드시 기록해야 함을 뜻함
- Fast Commit : 사용자의 갱신 내용이 메모리 상의 버퍼 블록에만 기록된 채 아직 디스크에 기록되지 않았지만, Redo 로그를 믿고 빠르게 커밋을 완료하는 것을 의미
- delayed block cleanout : 오라클만의 독특한 매커닞므으로 변경된 블록을 커밋 시점에 바로 Cleanout(로우 Lock 정보 해제, 커밋 정보 기록)하지 않고 그대로 두었다가 나중에 해당 블록을 처음 읽는 세션에 의해 정리되도록 하는 것을 말함
- 키워드 : Redo 로그 및 정의
외워놓자
4. 4(o) -> LRU는 나중게 먼저 처리된다는 뜻이므로 오래 머무르진않음
5. 1,4 (o) -> CPU 랑 큐인데 답지가 이상함
6. 2 (x, 1) -> 하드파싱1회 다만 바인드쿼리일경우 여러번 써도되네
7. 3 (1) -> 1~3은 하드파싱은 각각 일어나겠지만 실행계획이 같아 같은 캐시 공간을 사용함
8. 3 (o) -> 조건절이(쿼리 자체가) 바뀌는 사항은 바인드변수랑 무관
9. 2,3 (x, 1,2) -> 애초에 Dynamic SQL 이라 하드파싱이 거의 없겠네
10. 4 (O) -> 바인드변수로 쿼리하나잘짜면 하드파싱이 일어날 필요가 없으
11. 1. 3(O) -> Fetch Parse Execute 
12. 2 (O) -> 해당 쿼리가 통계치만으로 Group by Order by를 했는지 알 수 없음
13. 4 (x, 2) -> 서버에서 처리되는 프로그램에선 부분범위 처리에 의한 성능 개선이 안됨 
14. 2,3 (o) -> 아무튼 함수는 부하가 있어서 성능저하가 있음 사용자 정의 함수보단 스칼라 쿼리로 부하를 줄이는게 좋다.
15. 2 (x, 1) -> 실행할때마다 컴파일 하지 않아서 쓸모없는 말이다.
16. 4 (o) -> 애초에 잡히는 인덱스 차이가심함
17. 3 (o) -> 용량 아까운 짓은 하지 말자
18. 2 (o) -> Direct I/O 자체가 Full Scan일때 발생됨 인덱스를 통해 액세스하진않음
19. 3 (x, 4) -> extent 크기와 상관없이 I/O 콜이 많이 발생됨
20. 3 (O) - >테이블 블록스캔과, 인덱스 블록의 창를 이해한다.
21. 3 (O) -> select for update 를 쓸때 오히려 더 동시성을 높일 수 있음
22. 4 (O) -> 대충 간섭 없으면 다 좋음
23. 2 (x, 1,3)
-> 와 for update를 대신쓰는 락은 HOLDLOCK이랑 READPAST구나 
24. 4(x, 3)
-> exclusive모드이므로 Append 모드로 입력한 3번 SQL 입력 후 Lock 발생현황을 모니터링한것
25. 3(x, 2)
-> update문이  TM Lock 호환성이 있는 ROw-X(SX)모드로, TX Lock은 호환성이 없는 Exclusive모드로 Lock을 획득함
26. 4(O)
27. 2(x, 4)
100은 격리성 수준을 Serializable Read로 해놔서 5건
200은 Read Commit이므로 1건

- 낮은 단계에서 격리성 수준에서 발생할 수 있는 현상들
#### 1 dirty Read
- 다른 트랜잭션에 의해 수정됐지만 아직 커밋되지 않은 데이터를 읽는 것을 말함
#### 2 Non-Repeatable Read
- 한 트랜잭션 내에서 같은 쿼리를 두번 수행했는데 그 사이 다른 트랜잭션이 값을 수정 또는 삭제하는 바람에 두 쿼리 결과가 다르게 나타나는 현상
#### 3 Phantom Read
- 한 트랜잭션 내에서 같은 쿼리를 두번 수행했는데, 첫 번째 쿼리에서 없던 유령(Phantom)레코드가 두번째 쿼리에서 나타나는 현상을 말함

28. 2(O)
기본 트랜잭션 격리성 수준은 Read committed다 외우자
따라서 Dirty Read가 발생할 이유는 없지만, Non-Repeatable Read, Phantom REad 현상에 대해서는 주의가 필요함

29. 4(x, 3)
트랜잭션 격리성 수준을 상향 조정할 수록 일괁성은 높아지나 동시성은 낮아짐
30. 2000
- Oracle에서는 Update문이 시작되는 시점을 기준으로 갱신 대상 레코드를 식별하므로 TX2트랜잭션의 Update는 실패함
- 그러므로 TX1 트랜잭션의 결과각 7788사원의 최종 결과가 됨
- SQL Server에서는 TX2 트랜잭션은 TX1 트랜잭션이 완료 될 때 까지 기다림
31. 4(x, 3)
- MVCC 모델은 기본적을 완벽한 트랜잭션 수준 일관성을 보장함
- MVCC 모델은 문장 수준의 읽기 일관성을 완벽히 보장하나 트랜잭션 수준의 일기 읽관성을 보장하진 않음

32. 4(x, 2)
- 데이터베이스 CAll 발생량도 옵티마이저는 중요한 비용 요소임

33. 2(x, 4)
- 비용이 쓰는 옵티마이저를 찾으면 됨
- 직급의 종류 갯수는 CBO가 사용하는 규칙임

34. 1(x, 4)
- 전체범위 최적화는 빠른 응답보다 포괄적인 중심으로 최적화를 진행함

35. 1, 4(O)
- 답을 외운다.

36. 2
- 표본은 많은 데이터가 필요 없음

37. 3(x, 2)
- 3: View Merging 발생으로 함수 호출횟수가 같음
- 4: 스칼라 서브쿼리의 캐싱 효과를 이용해 함수 호출 횟수를 줄이려 했지만 상품 테이블에서는 상품코드는 Unique하기 때문에 캐싱 효과가 없음
- 2: ROWNUM을 이용해 View Merging을 방지했으므로 성능 개선에 도움이 됨
38. 2(O)
힌트를 사용하지 않고 뷰 머징을 하는 방법
- 집합 연산자(union, union all, intersect, minus)
- Connect by 절
- rownum pseudo 칼럼
- select-list에 집계함수(avg, count, max, min, sum)
- 분석 함수(Analytic Function)
39. 2(O)
- 뷰 안에 Group by를 사용한 경우 자주 View Merging이 발생함
40. 4(x, 3)
- 왜찍음 단순한건데

41. 4(x, 1)
1을 하면 카디션 프로덕트가 될수가 있어서 비효율적이다.

42. 2(x, 4)


43. 3(x, 2)
- more than or equal 이어야 3개 조건을 만족하는 스캔을 시작함
- 해당 쿼리는 less than or equal임
44. 2(x, 4)
- 수직적으로 탐색한 후 리프 블록을 범위 스캔하는 방식임
- 인덱스 선두 컬럼이 조건절에서 만족해야 됨

45. 3(x, 4)
- index Skip Scan을 활용하려면 인덱스 선행 컬럼이 누락됐거나 부등호, between like 같은 범위검색 조건이어야 함
- 즉 =조건일때는 안됨

#### index skip scan
- 루트 또는 브랜치 블록에서 읽은 칼럼 값 정보를 이용해 조건에 부합하는 레코드를 포함할 “가능성이 있는” 하위 블록(브랜치, 또는 리프)만 골라서 액세스하는 방식

#### index full scan
- 수직적 탐색 없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식으로, 대개는 데이터 검색을 위한 최적의 인덱스가 없을 때 차선으로 선택됨

#### index unique scan
- 수직적 탐색으로만 데이터를 찾는 스캔방식으로 unique 인덱스를“=”조건으로 탐색하는 경우에 작동함

index fast full scan은
index full scan보다 빠름
Index fast full scan이 index full scan보다 빠른 이유는 인덱스 트리 구조를 무시하고, 인덱스 세그먼트 전체를 Multiblock Read방식으로 스캔하기 때문


46. 1(x, 2,4)
- sal 을 선두로 갖는 index가 없으므로 range scan은 안됨
- fast full scan은 인덱스에 포함된 칼럼으로만 됨(아무튼 인덱스가 있어야됨)

47. 2(x, 1)
- B*tree 보다 테이블 random 액세스를 줄여준다
- 성별처럼 Distinct 갯수가 적을때 좋은 성능을 낸다.

#### 비트맵 인덱스
- 비트맵 인덱스는 Lock에 의한 DML 부하가 심한 것이 단점이다
- 레코드 하나만 변경되더라도 해당 비트맵 범위에 속한 모든 레코드에 Lock이 걸림
- OLTP성 환경에 비트맵 인덱스를 쓸 수 없는 이유가 여기 있다
- 비트맵 인덱스는 읽기 위주의 대용량 DW(특히, OLAP) 환경에 아주 적합하다.

48. 4(x, 2)
- 계좌, 지점번호 between 만으로 스캔범위를 줄일 수 있음
49. 4(x, 3)
- ING가 없더러도 스캔은 하게 됨
50. 3(x, 1,3)
- 1은 일단 가입일자 범위가 늘어나므로 I/O가 늘어날 수밖에 없음 포함인지까진 생각 못함
51. 3(x, 2,4)
- 일단 해당 실행계획은 클러스터링 팩터가 매우 안좋은상태
- 컬럼 순서를 조정해도 의미가 없다.
##### 인덱스 설계를 위해 고려해야 할 요소
- 쿼리 수행 빈도
- 업무상 중요도
- 클러스터링 팩터
- 데이터량
- DML 부하(= 기존 인덱스 개수, 초당 DML 발생량, 자주 갱신되는 칼럼 포함 여부 등)
- 저장공간
- 인덱스 관리 비용 등

52. 3(o)
- 
53. 3(o)
- 상품코드는 인덱스 구성컬럼이 아니므로 주문 테이블 액세스 단게의 필터조건
54. 2(o)
- 고객 테이블에서 스캔이 많으므로 그것을 줄이면 I/O 칼럼개선이 됨
55. 2(x, 3)
- - 답 3 SELECT * FROM 고객 WHERE 직업코드 IS NULL
  - 직업코드 조건으로 인덱스를 Range Scan하려면 직업코드를 선두로 갖는 인덱스여야 함
  - 고객_X01 인덱스가 여기에 해당함
  - 인덱스 구성컬럼 중 하나라도 NOT NULL이면 IS NULL 조회에 인덱스를 사용할 수 있다.
  - 따라서 직업코드 IS NULL 조회에 고객_X01인덱스를 사용할 수 있다.
56. 3(x,1,3)
- 문제를 자세히 읽자
- 1번인지 알고있었잖음
57. 2,3(o)
- 작-> 큰 순으로가야됨
- OLTP수행빈도가 높은곳에서는 앵간하면 안됨

#### hash join 성능을 좌우하는 키 포인트
- 1 한쪽 테이블이 가용 메모리에 담길 정도로 충분히 작아야 함
- 2 built input 해시 칼럼에 중복 값이 거의 없어야 함

#### hash join 선택 기준
조인 칼럼이 적당한 인덱스가 없어 NL Join이 비효율 적일 때
조인 칼럼에 인덱스가 있더라도 NL Join드라이빙 집합에서 Inner 쪽 집합으로의 조인 액세스량이 많아 Random액세스 부하가 심할 때
Sort merge join 하기에는 두 테이블이 너무 커 소트 부하가 심할 때
수행 빈도가 낮고 쿼리 수행시간이 오래 걸리는 대용량 테이블을 조인할 때

#### 스칼라서브쿼리
- 서브쿼리중 함수처럼 한 레코드당 정확히 하나의 값만을 리턴하는 서브쿼리를 스칼리 서브쿼리라고 함
- 스칼라 서브쿼리는 주로 select-lost 에서 사용되나 몇 가지 예외사항을 뺀다면 칼럼이 올 수 있는 대부분의 위치에서 사용 가능함


58. 4(o)
- Result Cache가 아니라 PGA임
59. 3(o)
- 해설 : 대량 집합을 기준으로 NL조인하면 많은 랜덤 I/O가 발생한다.
- SQL1에서 판매시작일자 조건을 만족하는 상품 건수가 적다면, 일별매출보다 상품 테이블을 먼저 드라이빙 하는게 유리할 수 있다.
- SQL2에서 v_판매일자시작 변수에 최근일자를 입력하면 판매시작일자 조건을 만족하는 상품건수가 적어지므로 그만큼 비효율이 커짐. 기준일자 Between 조건에 해당하는 많은 일별 매출데이터를 읽고 Group By처리까지 마쳤는데, 상품 테이블과 조인하는 과정에 많은 데이터가 필터링되기 때문

60. 2(O)
- 다른 방법인 Hash Join은 키가 있어야 하므로 =조건일때만 가능
61. 3(O`)
- 선분 이력을 between 으로 조회하면 됨
62. 3(o)
- local 파티션 인덱스의 경우 테이블파티션 키가 인덱스 키 선두 컬럼에 위치해야함
#### local 파티션 인덱스
- 테이블 파티션과 1:1로 대응되도록 파티셔닝한 인덱스
- 인덱스 파티션 키를 사용자가 따로 지정하지 않으며, 테이블과 1:1관계를 유지하도록 DBMS가 자동으로 관리해줌
- SQL server 에선 정렬된(aligned) 파티

63. 1,3(x, 1,2)
- 해시는 기간 조회에는 적절하지 않네
 list 파티셔닝과 Range 파티셔닝 모두 가능하다. Range 파티셔닝의 경우, 예를들어 
- 매년 1~3 4~6 7,8,9,10~12월 6개로 파티셔닝하면 됨
- hash 파티셔닝은 정해진 파티션 갯수로 파티션 키 값에 따라 EDMS가 기계적으로 분할 저장하기 때문에 월별 매출 특성을 고려한 파티셔닝을 하기가 곤란함

### Oracle이 지원하는 파티션 유형
- 1 Range 파티셔닝
  - 파티션 키 값이 범위(Range)로 분할
  - 파티셔닝의 가장 일반적인 형태이며, 주로 날짜 칼럼을 기준으로 함예) 판매 데이터를 월별로 분할
- 2 hash 파티셔닝
  - 파티션 키 값에 해시 함수를 적용하고 거기서 반환된 값으로 파티션 매핑
  - 데이터가 모든 파티션에 고르게 분산되도록 DBMS가 관리
  - 파티션 키의 데이터 분포가 고른 칼럼이어야 효과적
- -> 고객번호 주문일련번호
- 병렬처리 시 성능효과 극대화
- DML 경합 분산에 효과적
- 3 List 파티셔닝
  - 불연속적인 값의 목록을 각 파티션에 지정
  - 순서와 상관없이 사용자가 미리 정한 그룹핑 기준에 따라 데이터 분할 저장

- 4 Comotsite 파티셔닝
  - Range나 List 파티션 내에 또 다른 서브 파티션(Range Hash List)구성
  - Range + List 또는 List + hash 등
  - Range나 List 파티션이 갖는 이점 + 각 서브 파티션 구성의 이점

64. 1(x, 3)

- 컬럼끼리 연산할 때 null을 포함하면 결과는 null이다
- 레코드끼리 연산할 때 null을 포함하면 null이 아니며 이유는 null을 연산에서 제외하기 때문

- 소트와 관련된 오퍼레이션 유형
- 1 sort aggregate
  - 전체 로우를 대상으로 집게를 수행할 때 나타나며, oracle 실행계획에 sort라는 표현이 사용됐지만, 실제 소트가 발생하지 않는다

- 2 sort order buy
  - 정렬된 결과집합을 얻고자 할 때

- 3 sort group by
  - Sorting 알고리즘을 사용해 그룹별 집계를 수행할 때 나타남

- 4 sort unique
  - 선택된 결과집합에서 중복 레코드를 제거하고자 할때 나타남
  - Union 연산자나 아래와 같이 Distinct 연산자를 사용할 때가 대표적

- 5 sort join
  - sort merge join을 수행할 때 나타남

- 6 window sort
  - 윈도우 함수를 수행할 때 나타남

65. 4(o)
- 윈도우 함수가 사용된 SQL실행계획에서는 WINDOW sort 오퍼레이션이 나타남

66. 4(x, 2)
- 아니 왜 4번고름 눈나쁨?
67. 1(x, 4)
- 1은 위아래가 배타적, 2는 위아래각 집합에 중복이 없어야됨, 3은 위아래 둘다 배타적이나 각 집합에 중복이 있을 수 있음, 4는 PK를 포함하므로 모든 레코드가 배타적
68. 3(x, 1)
- 1번으로 하면 결과가 틀릴수도 있음
69. 3 (o)
- 1은 랜덤액세스로 전체 고객대상으로는 비효율
- 2는 고객 변경 이력 테이블을 2번액세스 해야됨
- 5는 Top -N 쿼리 알고리즘이 작동하지 않아 부하가 있을 수 있다.
70. 2(x, 3)
- Insert ALL구문에 Append 힌트를 쓰면 모든 테이블에서 Exclusive 모드의 TM 락이 설정됨

#### 오라클에서 Direct path insert방식으로 데이터를 입력하는 방법
- insert select 문장에 /*+ append*/힌트 사용
- 병렬모드로 insert
- direct 옵션을 지정하고 SQL *Loader(sqlldr)로 데이터 로드
- CTAS(create table as select) 수행

71. 2(x, 1)
- lock을 사용하지 않고 빠르게 입력함
- append 모드로 insert 하면 exclusive 모드 테이블 Lock 이 걸림
72. 3(x, 2)
  - 대량의 데이터를 빠르게 UPDATE하기 위해 테이블은 nologging모드로 변경하고 작업을 시작함
- nologging모드는 INSERT문일 때만 기능이 작동한다.
- 대량의 데이터를 일반 Update문으로 갱신하면 상당히 오랜 시간이 소요될 수 있다.
- 다음과 같은 이유 떄문이며 DELETE문도 마찬가지임
  - 테이블 데이터를 갱신하는 본연의 작업
  - 인덱스 데이터까지 갱신
  - 버퍼 캐시에 없는 블록을 디스크에서 읽어 버퍼 캐시에 적재한 후 갱신
- 내부적으로 Redo와 Undo정보 생성
- 블록에 빈 공간이 없으면 새 블록 할당
  - (Row -> Migration)
73. 1(x, 3)
- a의 서브쿼리로 세미조인 방시긍로 변경해도 조인에 참여한 ㄴ테이블이 많아서 B보다 부하가 더 발생함
74. 4(x, 3)
- nologging기능은 insert에만 효과적임
75. 4(x, 2)
#### 파티셔닝이 필요한 이유
- 관리적 측면
  - 파티션 단위 백업, 추가, 삭제, 변경
- 성능적 측면
  - 파티션 단위 조회 및 DML 수행, 경합 및 부하 분산
- 저장효율개선은 필요치 않음
76. 2(x, 3)
- 파티션 컬럼에 대한 검색조건을 바인드 변수로 제공하더라도 Partition Pruning은 작동함
77. 1, 2(o)
- 3은 파티션 키 칼럼을 가공했으므로 모든 파티션을 Full Scan 하게 된다.
- 4은 주문 테이블이 월단위로 파티션돼 있는데, 일 단위로 조회 조건을 제공하므로 각 월에 속한 일자 갯수만큼 파티션 full Scan을 반복하게 됨
78. 1(o)
#### 파티션 인덱스
- Local Prefix 파티션 인덱스
- Local NonPrefixed 파티션 인덱스
- Global Prefixed 파티션 인덱스
- Global NonPrefixed 파티션 인덱스(-> Oracke Not Support)
- 비파티션 인덱스

79. 1,4(o)
- Global 파티션 인덱스인 거래_IDX1의 파티션 키는 거래일자이고 파티션 키가 인덱스 선두컬럼이므로 Prefixed 파티션임
- 거래_IDX2는 Local 인덱스이므로 파티션 키는 거래일자가 됨 파티션 키가 인덱스 선두컬럼이 아니므로 Nonprefixed 파티션임
80. 4(x, 1)
- 같은 시간대에 수많은 프로그램이 집중적으로 수행되면 총 수행시간이 더 늘어남
- 자원(cpu, memory, Disk등)과 Lock(Latch와 같은 내부 Lock 포함)에 대한 경합이 발생하면서 프로세스가 실제 일한 시간보다 대기하는시간이 더 많아지기 때문

- 사용자와 상호작용없이
- 대량의 데이터를 처리하는
- 일련의 작업들을 묶어
- 정기적으로 반복수행하거나
- 정해진 규칙에 따라 자동으로 수행

81. 1(x, 4)
- 테이블을 nologging모드로 바꾸면 Redo Log가 생성되지 않도록 할 수 있지만, 이 기능은 append 또는 parallel 힌트를 사용해 DIrect Load insert할 때만 작동함

82. 3
