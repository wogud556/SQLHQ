1.
2
모델링의 특징으로는 추상화, 단순화, 정확화 등이 있다.

2.
3
데이터모델링의 주요 이유는 업무의 기초가 되는 정보들에 대해 일정한 표기법에 의해 표현함으로써
정보시스템 구축의 대상이 되는 업무 내용을 정확하게 분석하는 것이 목표
또한 실제 데이터베이스를 생성하여 개발 및 데이터관리에 사용하기 위한 것
단순 구축만을 위한 것이 아니라 데이터모델링 자체로서 업무를 설명하고 분석하는 부분에서
중요한 의미를 가지고 있다.

3.
3
데이터모델링을 할 때 유의할 사항은 3가지로, 중복, 비유연성, 비일관성이다.
중복 - 여러 장소에 같은 정보를 저장하는 잘못을 하지 않도록 한다
비유연성 - 데이터의 정의를 데이터의 사용 프로세스와 분리함으로써 데이터 혹은 프로세스의 작은 변화가
애플리케이션이나 데이터베이스에 중대한 변화를 일으킬 가능성을 줄인다
비일관성 - 데이터의 중복이 없더라도 비일관성은 발생할 수 있다. 서로 연관된 다른 데이터와 모순된다는 고려 없이
일련의 데이터를 수정할 수 있기 때문에, 상호연관관계에 대해 명확하게 정의하면 이런 위험을 예방할 수 있다.

4.
2
데이터의 정의를 데이터의 사용 프로세스와 분리하는 과정은 비유연성을 없애기 위한 것이다.
데이터간 상호관계를 명확하게 정의하는 것이 비일관성을 없애기 위한 것이고,
여러 장소의 데이터베이스에 같은 정보를 저장하지 않는 것이 중복을 피하는 것이다.

5.
1
개념적 데이터모델링은 추상화 수준이 높고, 업무 중심적, 포괄적인 수준의 모델링을 뜻한다.
특히 전사적 데이터 모델링, EA 수립할 때 많이 이용한다.
논리적 제이터 모델링은 시스템으로 구축하고자 하는 업무에 대해 Key, 속성, 관계 등을 정확하게 표현하여 재사용성을 높게 하는 것이다.
물리적 데이터 모델링 실제로 데이터베이스에 이식할 수 있도록 성능, 저장 등 물리적인 성격을 고려하여 설계하는 것이다.

6.
2
통합 관점의 스키마 구조를 표현한 것이 개념스키마이며, 데이터 모델링은 통합 관점의 뷰를 가지고 있는 
개념 스키마를 만들어 가는 과정으로 볼 수 있다.
개념스키마 - 데이터 베이스의 전체적인 논리 구조
내부스키마 - 물리적인 저장장치 입장에서 DB가 저장되는 방법(DB의 물리적 저장구조)을 기술한 것
외부스키마 - 실세계에 존재하는 데이터들을 어떤 형식, 구조, 배치화면을 통해 사용자에게 보여줄 것인지를 나타냄
+ 1개의 데이터베이스에는 여러 외부스키마가 존재할 수 있다.
외부스키마 > 개념스키마 - 내부스키마 - 물리적DB 순서대로 연결

7.
4
주문테이블은 고객테이블의 자식엔터티기 때문에, 반드시 부모엔터티가 필요하다.
하지만 부모엔터티는 자식엔터티가 존재하지 않아도 값을 입력할 수 있다.

8.
4
가장 중요한 엔터티를 왼쪽위에 위치하고 이것을 중심으로 다른 엔터티를 나열하면서 전개하는 것이
일반적인 사람의 눈이 따라가기에 편리한 데이터 모델이다.
ERD 작성순서는 엔터티 그리기, 배치, 관계설정, 관계명기술, 관계참여도, 필수여부이다.

9.
2
병원은 1개이므로 엔터티로 성립하지 않고, 이름과 주소는 엔터티의 속성으로 인식될 수 있다.
엔터티는 2개 이상의 속성과 2개 이상의 인스턴스를 거쳐 소위 면적으로 표현될 수 있어야 하는데
이 조건에 맞는 요소는 환자이다.

10.
3
엔터티의 특징 - 해당 업무에서 필요로 하고 관리하고자 하는 정보여야 한다
- 유일한 식별자에 의해 식별이 가능해야 한다
- 영속적으로 존재하는 두 개 이상의 인스턴스의 집합이어야 한다.
- 엔터티는 업무 프로세스에 의해 이용되어야 한다.
- 엔터티는 반드시 속성이 있어야 한다.
- 엔터티는 다른 엔터티와 최소 한 개 이상의 관계가 있어야 한다.
1개의 인스턴스만으로는 충분한 의미를 가질 수 없다. (관계가 핵심이 되어야 하기 때문에)

11.
1
관계는 필수!

12.
1
기본엔터티(키엔터티)는 그 업무에 원래 존재하는 정보로 다른 엔터티와는 관계 없이 독립적으로 생성이 가능하고
자신은 타 엔터티의 부모의 역할을 하게 된다. 그러므로 다른 엔터티로부터 주식별자를 상속받지 않고
자신의 고유한 주식별자를 가지게 된다.
중심엔터티는 기본엔터티로부터 발생하고, 업무의 중심적인 역할을 한다.
일반적으로 데이터양이 많고 다른 엔터티와의 관계를 통해 해우이 엔터티를 생성한다.
행위엔터티는 두 개 이상의 부모엔터티로부터 주로 발생되고, 엔터티의 내용이 자주 바뀌거나 데이터양이 자주 증감한다.
보통 분석초기단계보다 상세 설계단계나 프로세스와 상관모델링을 진행하면서 도출될 수 있다.

13.
1
엔터티를 명명하는 일반적인 기준
- 현업에서 사용하는 용어 사용
- 약어를 사용하지 않는다
- 단수명사를 사용한다
- 유일하게 이름이 부여되어야 한다
- 엔터티 생성의미대로 이름을 부여한다

14.
속성 (ATTRIBUTE)
속성은 사물의 본질적인 성질이다. 데이터 모델링의 관점에서 의미상 분리되지 않는 최소의 데이터 단위이고,
업무상 관리가 가능한 최소의 의미단위이고, 이것은 엔터티의 한 분야를 담당하고 있다.

15.
3
하나의 인스턴스에서 각각의 속성은 한 개의 속성값을 가져야 한다.
한개의 엔터티는 두 개 이상의 인스턴스의 집합이어야 한다
한 개의 엔터티는 두 개 이상의 속성을 갖는다
한 개의 속성은 한 개의 속성값을 갖는다
엔터티(과목) - 인스턴스(수학,영어,국어)
속성의 종류는 PK속성(엔터티를 유일하게 구분할 수 있는 속성), FK속성(관계에 포함된 속성), 일반 속성으로 나뉜다.

16.
3
이자율은 기본속성이다.
이자는 계산된 값으로 파생속성이다.
기본속성은 업무 분석을 통해 바로 정의한 속성
설계속성은 업무를 규칙화 하기 위해 새로 만들어지거나 변형된 속성 (ex 일련번호)
파생속성은 다른 속성에 영향을 받아 발생하는 속성(ex 계산된 값) 

17.
1
계산된 값 = 파생속성

18.
4
각 엔터티의 속성에 대해 어떤 유형의 값이 들어가는 지를 정의하는 개념은 도메인이다.

19.
3
속성의 명칭은 애매하지 않게, 복합명사를 사용하여 구체적으로 명명함으로써 전체 데이터 모델에서
유일성을 확보하는 것이 반정규화 ,통합 등을 할 때 혼란을 방지할 수 있음

20.
3,4
ERD에서는 존재에 의한 관계와 행위에 의한 관계를 구분하지 않는다.
반대로 UML(Unified Modeling Language)에는 클래스다이어그램의 관계 중 연관관계와 의존관계가 있고
실선과 점선의 표기법으로 다르게 표현이 된다. (클래스다이어그램에서는 존재와 행위에 의한 관계를 구분한다)

21.
2
관계의 표기법은 관계명 관계차수 관계선택사양으로 나뉜다.

22.
2
관계차수는 1:1, 1:M과 같이 관계의 기수성을 나타낸다.

23.
3
동사는 관계를 서술하는 업무기술서의 가장 중요한 사항이다.
따라서 업무기술서, 장표에 관계연결을 가능하게 하는 동사가 있는가?가 적절하다.

24.
4
두개의 엔터티 사이에 관심있는 연관규칙이 존재하는지, 정보의 조합이 발생하는지를 확인하고,
업무기술서, 장표에 관계연결에 대한 규칙이 서술되어있는지, 관계연결을 가능하게 하는 동사가 있는지를 확인해야
두 엔터티 사이에서 관계를 도출할 수 있다.

25.
4
주식별자에 의해 엔터티 내의 모든 인스턴스들이 유일하게 구분되어야 하고,
주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 하고,
지정된 주식별자의 값은 자주 변하지 않는 것이어야 하고
주식별자가 지정이 되면 반드시 값이 들어와야 한다.
엔터티 내에서 대표성을 가지면 주식별자, 아니면 보조식별자
엔터티 내에서 스스로 생성되었다면 내부식별자, 아니면 외부식별자
단일 속성으로 식별이 되는가에 따라 단일식별자, 아니면 복합식별자
원래 업무적 의미가 있는 식별자 속성을 대체하여 일련번호처럼 새롭게 만든 식별자는 인조식별자, 아니면 본질식별자

26.
4
사원 엔터티에서의 식별자는 사번이다.
사번은 대표성을 가지므로 주식별자이고, 엔터티 내에서 스스로 생성되었으므로 내부식별자이고,
단일 속성으로 식별이 되므로 단일식별자이고, 원래 업무적으로 부여되는 사원인스턴스의 본질적인 속성에 해당하므로
본질식별자이다.

27.
2
이름은 중복될 수 있으므로 식별자로 부적절하다.(동명이인)

28.
2
주식별자를 도출하기 위한 기준은
해당 업무에서 자주 이용되는지, 이름으로 기술되는 것들은 가능하면 배제, 복합으로 주식별자 구성시 속성 최소화
등이 있다.
주식별자의 특징으로 유일성(모든 인스턴스 구별), 최소성(속성 수는 유일성 만족하는 최소),
불변성(값은 변하지 않아야함), 존재성(NULL이 안된다)이 존재한다.

29.
4
부모엔터티의 주식별자를 자식에 이어 손자까지 계속 전해주기 위해서는 끈끈한 연관관계를 유지하기 위해
식별자관계를 사용해야 한다. (비식별자관계는 부모쪽의 관계 참여가 선택)
식별자관계는 실선, 비식별자관계는 점선

30.
2
부모엔터티의 인스턴스가 자식 엔터티와 함게 소멸되는 경우는 식별자관계이다.

31.
1
성능이 저하된 결과를 대상으로 문제발생 시점의 SQL을 중심으로 집중하여 튜닝을 하기보다는
애초에 설계단계의 데이터모델링때부터 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것이 좋다

32.
반정규화

데이터모델링의 순서는 정규화 정확히 수행 / 용량 산정 / 트랜잭션 유형 파악/ 용량과 트랜잭션에 따라 반정규화 수행 /
이력모델 조정, PK/FK 조정, 슈퍼타입/서브타입 조정 수행 / 성능 관점에서 데이터모델 검증 순서대로 한다.

33
4
데이터모델링의 순서
데이터 모델링을 할 때 정규화를 정확하게 수행한다
데이터베이스 용량산정을 수행한다
데이터베이스에 발생되는 트랜젝션의 유형을 파악한다
용량과 트랜잭션의 유형에 따라 반정규화를 수행한다
이력모델의 조정, PK/FK조정, 슈퍼타입/서브타입 조정 등을 수행한다
성능관점에서 데이터 모델을 검증한다

34
1
정규화는 오히려 성능을 향상하기 위한 하나의 방법이다

35
3
2차정규화, 그리고 종속성대로 각각 따로 테이블을 나눠야한다

36
3
2차정규화 / 매각기일은 일자별 매각물건에서 떨어져나왔으므로 1:M관계이다.(하나의 매각기일에는 여러 물건을 매각했을 수 있기 떄문이기도 하다)

37
4
반복적인 속성을 가지고 있다면, 속성이 겹치므로 도메인의 원자성의 원칙에 위배하는 테이블이 된다. 따라서 제1차 정규화를 수행하면 자연스럽게 더 빨라질 수 있다.

38
1
컬럼단위에서 중복되는 경우 1차 정규화가 필요한 엔터티이고, 1:M의 관계가 될 수 있다.

39
1
2차정규형을 만족하지 못하는 모습을 보여주고 있으므로 1차정규형 - 2차 정규화 대상이 된다.

40
1
다량데이터탐색은 인덱스가 아닌 다양한 물리 저장 기법을 활용하여 성능 개선을 유도할 수 있다. 다만 다량 데이터 탐색이 반복적으로 발생하면 반정규화를 고려해도 된다
이전 / 이후 레코드에 대한 탐색은 window function으로 가능하다
집계테이블 이외에도 다양한 유형에 대하여 반정규화 테이블 적용이 필요할 수 있다.

41
1
디스크I/O를 줄이기 위해 해당 칼럼들을 별도로 모아놓는 테이블을 만드는 반정규화기법은 부분테이블 추가에 해당한다.

42.
3
Foreign Key에 대한 속성 추가는 반정규화라고 보기보다는 데이터 모델링에서 관계를 연결할 때 나타나는 자연스러운 현상이다.

43
3
원하는 것이 주문 당 단가의 합이므로 주문 엔터티에 단가의 합을 계산한 칼럼을 추가하면 효과적인 반정규화이다.

44
1
다량의 조인이 일어나는 경우 당연히 하나의 테이블에 존재할 때보다 검색 시간이 길어진다.

45
3
한 테이블에 너무 많은 칼럼이 존재하면 데이터가 디스크 안에 넓게 분포하게 되고, 디스크 I/O가 대량으로 발생하고
이로 인해 성능이 저하될 수 있다. 따라서 트랜잭션이 접근하는 칼럼유형을 분석해서 자주 접근하는 칼럼과
그렇지 않은 칼럼을 구분하여 1:1로 테이블을 분리하면 디스크I/O가 줄어들어 성능을 향상시킬 수 있다.
NULL이 많으면 사용빈도가 낮은 칼럼이나 미래에 사용될 칼럼들을 모아 따로 1:1관계 엔터티로 분리하는 등
데이터 모델 설계 수정을 고려해보는 것이 좋다.

46
파티셔닝
대량의 데이터는 PK의 성격에 따라 논리적으로는 하나의 테이블이지만 물리적으로는 여러 개의 테이블로 분리할 수 있다.
지나치게 많은 조인이 걸려 데이터를 조회하는 것이 기술적으로 어려우면 VIEW를 사용하면 해결할 수도 있다.

47
2
3개를 동시에 조회하는 경우가 많으므로 세 테이블을 하나로 합치고, PK를 사건분류코드+사건번호로 지정한다.
사건분류코드는 따로 만들어준다.

48
4
트랜젝션은 항상 전체를 통합하여 분석 처리하는데 슈퍼-서브타입이 하나의 테이블로 통합되어 있으면
하나의 테이블에서 데이터를 읽어올 수 있기 때문에 성능이 좋아진다.
슈퍼타입 - 테이블을 하나로 뭉침
서브타입 - 여러개로 테이블을 쪼갬
서브타입은 엔터티를 통합하거나 분리하는 행위의 결과이다
슈퍼타입의 공통속성은 모든 서브타입으로 상속된다.

49
4
EQUAL조건이 갖아 앞으로 나오고, 범위를 조회하는 칼럼이 그 다음에 와야 가장 효율적이다.

50
2
위와 같은 논리로 EQUAL이 맨 앞, 범위가 그 뒤에 오면 좋다.

51
2,4
엔터티간에 논리적 관계가 있는 경우(업무적인 연관성이 있는 경우) 조인성능 향상을 위한 인덱스 생성이 필요하다.
FK제약조건은 관련 인스턴스간에 일관성을 보장하기 위해 설계된 제약조건을 구현할 수 있도록 DBMS가 제공하는
하나의 지원 기능으로 이해될 수 있다.
인덱스는 테이블의 데이터를 빠르게 검색할 수 있게 도와주는 객체(쿼리의 처리속도 향상!)
대신 인덱스를 생성할 추가공간 필요, 데이터 변경작업이 자주 일어나면 성능 저하 우려

52
4
GSI(Global Single Instance)는 통합된 한 개의 인스턴스, 통합 데이터베이스 구조를 의미하므로
분산데이터베이스와는 대치된다.
만약 자주 쓰는 경우 매번 통합데이터베이스를 방문하면 시간이 오래 걸리므로
분산 환경에 복제분산을 하는 방법으로 속도를 높일 수 있다. 백업 사이트 구성 역시 동일하다.