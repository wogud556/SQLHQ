# 옵티마이저 원리

## 옵티마이저 소개

### 옵티마이저란?
- SQL을 가장 빠르고 효율적으로 수행할 최적의 처리경로를 생성해주는 DBMS 내부의 핵심 엔진임
- 사용자가 구조화된 질의언어로 결과집합을 요구하면, 이를 생성하는데 필요한 처리 경로는 DBMS에 내장된 옵티마이저가 자동으로 생성해줌
- 옵티마이저가 생성한 SQL 처리 경로를 실행계획이라 부름
- 옵티마이저의 SQL 최적화 과정을 요약하면 다음과 같음
  - 사용자가 던진 쿼리수행을 위해 후보군이 될만한 실행계획을 가짐
  - 데이터 딕셔너리에 미리 수집해놓은 오브젝트를 통계 및 시스템 통계 정보를 이용해 각 실행계획의 예상 비용을 산정함
  - 각 실행계획을 비교해서 최저비용을 갖는 하나를 선택함

### 옵티마이저 종류
- 옵티마이저는 다음 두 가지로 나뉘며, 앞서 설명한 SQL 최적화 과정은 비용기반 옵티마이저에 관한 것

#### 규칙기반 옵티마이저
- 규칙기반 옵티마이저는 다른 말로 휴리스틱 옵티마이저라고 불림
- 미리 정해놓은 규칙에 따라 액세스 경로를 평가하고 실행계획을 선택함
- 여기서 규칙이란 액세스 경로별 우선순위로서 인덱스 구조, 연산자, 조건절 형태가 순위를 결정짓는 주요인임

#### 비용 기반 옵티마이저
- 비용 기반 옵티머이저는 말 그대로 비용을 기반으로 최적화를 수행함
- 여기서 비용이란 쿼리를 수행하는 데 소요되는 일량 또는 시간을 뜻함
- CBO가 실헹계획을 수립할 때 판단 기준이 되는 비용은 어디까지나 예상치임
- 미리 구해놓은 테이블과 인덱스에 대한 여러 통계정보를 기초로 각 오퍼레이션 단계별 예상 비용을 산정하고, 이를 합산한 총비용이 가장 낮은 실행계획을 선택함
- 비용을 산정할 때 사용되는 오브젝트 통계 항목으로는 레코드 개수, 블록 개수, 평균 행 길이 칼럼 값의 수, 칼럼 값 분포, 인덱스 높이, 클러스터링 팩터 같은 것을이 있음
- 오브젝트 통계 뿐만 아니라 최근에는 하드웨어적 특성을 반영한 시스템 통계 정보까지 이용함
- 역사가 오래된 Oracle은 RBO에서 출발하였으나, 다른 상품 RDBMS는 탄생 초기부터 CBO를 채택함
- Oracle 도 10G 버전부터 RBO에 대한 지원을 중단하였으므로 본서는 CBO를 중심으로 설명함
  - 스스로 학습하는 옵티마이저
    - 전통적으로 옵티마이저는 오브젝트 통계와 시스템 통계로부터 산정한 '예상' 비용만으로 실행계획을 수립해옴
    - 하지만 앞으로 예상치와 런타임 수행 결과를 비교하고, 예상치가 빗나갔을 때 실행계획을 조정하는 옵티마이저로 발전할 것
    - 최근에 발표된 각 DBMS 버전은 이미 이런 기능을 포함하고 있음

#### SQL 최적화 과정
- Oracle 기준으로, SQL 최적화 및 수행 과정을 좀 더 자세히 표현하면 아래와 같음
  - Parser로 SQL 파싱
  - 옵티마이저로 옵티마이징
    - 쿼리 변환
    - 추정 작업
    - 계획 생성
  - 실행계획을 토대로 Row Source 생성
  - SQL 엔진으로 실행

#### 서브 엔진별 역할
- Parser
  - SQL 문장을 이루는 개별 구성요소를 분석하고 파싱해서 파싱 트리를 만듬
  - 이 과정에서 사용자 SQL에 문법적 오류가 없는지 , 의미상 오류가 없는지 확인함
- Optimizer
  - Query Transformer
    - 파싱된 SQL을 좀 더 일반적이고 표준적인 형태로 변환
  - Estimator
    - 오브젝트 및 시스템 통계정보를 이용해 쿼리 수행 각 단계의 선택도, 카디널리티, 비용을 계산하고, 궁극적으로 실행계획 전체에 대한 총 비용을 계산해냄
  - Plan Generator
    - 하나의 쿼리를 수행하는 데 있어, 후보군이 될만한 실행계획들을 생성해 냄
  - Row-Source Generator
    - 옵티마이저가 생성한 실행계획을 SQL 엔진이 실제 실행할 수 있는 코드 형태로 포매팅함
  - SQL Engine
    - SQL을 실행함
- Oracle 뿐만 아니라 다른 DBMS도 비슷한 처리 과정을 통해 실행계획을 생성함
- 참고로 M.Jarke와 J.Koch가 펴낸 책에서는 쿼리 최적화 과정을 다음과 같이 설명하고 있는데 표에서 설명한 내용이 Parser와 Optimizer역할에 해당하는 내용이다.
  - 쿼리를 내부 표현방식으로 변환
  - 표준적인 형태로 변환
  - 후보군이 될만한 프로시저를 선택
  - 실행계획을 생성하고, 가장 비용이 적은 것을 선택

### 최적화 목표

#### 전체 처리속도 최적화
- 쿼리 최종 결과집합을 끝까지 읽는 것을 전제로, 시스템 리소스를 가장 적게 사용하는 실행계획을 선택함
- Oracle SQL Server 등을 포함해 대부분 DBMS의 기본 옵티마이저 모드는 전체 처리 속도 최적화에 맞춰져 있음
- Oracle에서 옵티마이저 모드를 바꾸는 방법은 다음과 같음

```
alter system set optimizer_mode = all_rows : 시스템 레벨 변경
alter session set optimizer_mode = all_rows: - 세션 레벨 변경
```

#### 최초 응답속도 최적화
- 전체 결과집합 중 일부만 읽다가 멈추는 것을 전제로, 가장 빠른 응답속도를 낼 수 있는 실행계획을 선택함
- 만약 이 모드에서 생성한 실행계획으로 데이터를 끝까지 읽는다면 전체 처리 속도 최적화 실행계획보다 더 빠른 리소스를 사용하고 전체 수행 속도도 느려질 수 있음
- Oracle 옵티마이저에게 최초 응답속도 최적화를 요구하려면 옵티마이저 모드를 first_rows로 바꿔주면 됨
- SQL 서버에서는 테이블 힌트로 fastfirstrow를 지정하면 됨
- Oracle에서 옵티마이저 모드를 first_rows_n으로 지정하면 예를들어 시스템 또는 세션 레벨에서 first_rows_10으로 지정하면 사용자가 전체 결과집합 중 처음 10개 로우만 ㅇ릭고 머추는 것을 전제로 가장 빠른 응답을 낼 수 있는 실행계획을 선택함
- 쿼리 레벨에서 힌트를 사용하려면 아래와 같이 하면 됨

```
select /*+ first_rows(10)*/
from t
where;
```

- SQL 서버에서는 쿼리 힌트로 fast 10을 지정하면 됨

```
select *
from t
where OPTION(fast 10);
```

## 2. 옵티마이저 행동에 영향을 미치는 요소

### SQㅣ