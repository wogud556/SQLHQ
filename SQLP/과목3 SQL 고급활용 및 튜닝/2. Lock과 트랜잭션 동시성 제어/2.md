## Lock과 트랜잭션 동시성 제어
- 트랜잭션은 업무 처리를 위한 논리적인 작업 단위임
- 작업의 논리적 단위가 단일연산이 아닐 수 있음
- 하나의 트랜댁션이 두개 이상의 갱신 연산 일 수 있음
- 은행의 "걔좌이체"트랜잭션을 예로 들면 하나의 예금 계좌에서 인출하여 다른 예금 계좌에 입금하는 일련의 작업을 하나의 단위로 수행헤야 함
- 데이터를 일관성 있게 처리하려면 트랜잭션에 속한 두개 이상의 갱신 연산을 동시에 실행할 수 있어야 하는데, 불행히도 이는 불가능한 일임
- 따라서 DBMS는 차선책을 사용하는데 즉 여러개의 갱신 연산이 하나의 작업처럼 전부 처리되거나 아예 하나도 처리되지 않도록 동시 실행을 구현함

## 1. 트랜잭션의 특징
- 데이터베이스의 갱신과 관련하여 트랜잭션은 아래와 같은 4가지 주요 특징을 가지며, 영문 첫 글자를 따서 ACID라고 부름
  - 원자성
    - 트랜잭션은 더이상 분해가 불가능한 업무의 최소 단위이므로 전부 처리되거나 아예 하나도 처리되지 않아야 함
  - 일관성
    - 일관된 상태에서 데이터베이스에서 하나의 트랜잭션을 성공저긍로 완료하고 나면 그 데이터베이스는 여전히 일관된 상태여야 함
    - 즉 트랜잭션 실행의 결과로 데이터베이스 상태가 모순되지 않아야 함
  - 격리성
    - 실행중인 트랜잭션의 중간결과를 다른 트랜잭션이 접근할 수 없음
  - 영속성
    - 트랜잭션이 일단 그 실행을 성공적으로 완료하면 그 결과는 데이터베이스에 영속적으로 저장됨

## 2. 트랜잭션 격리성
- 트랜잭션 격리성은 일관성가 마찬가지로 Lock을 강하게 오래 유지할수록 강화되고, Lock을 최소화할수록 약화됨
- 낮은 단계의 격리성 수준에서 어떤 현상들이 발생하는지부터 봐야 함

### 낮은 단계의 격리성 수준에서 발생할 수 있는 현상들

#### Dirty Read
- 다른 트랜잭션에 의해 수정됐지만, 아직 커밋되지 않은 데이터를 읽는 것을 말함
- 변경 후 아직 커밋되지 않은 값을 읽었을 때 변겨경을 가한 트랜잭션이 최종적으로 롤백된다면 그 값을 읽은 트랜잭션은 비일관된 상태에 놓이게 됨

#### Non-Repeatable Read
- 한 트랜잭션 내에서 같은 쿼리를 두번 수행됐는데, 그 사이에 다른 트랜잭션 값을 수정 또는 삭제하는 바람에 두 쿼리 결과가 다르게 나타나는 현상을 말함

### 트랜잭션 격리성 수준
- ANSI/ISO SQL 표준에서 정의한 4가지 트랜잭션 격리성 수준은 다음가 같음
- Read Uncommitted
  - 트랜잭션에서 처리 중인 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용
- Read Committed
  - 트랜잭션이 커밋되어 확장된 데이터만 다른 트랜잭션이 읽도록 허용함으로 Dirty Read를 방지해줌
  - 커밋된 데이터만 읽더라도 Non-Repeatable Read와 Phantom Read 현상을 막지는 못함
  - 읽는 시점에서 결과가 다를 수 있다는 것
  - 한 트랜잭션 내에서 쿼리를 두번 수행했는데 두 쿼리 사이에 다른 트랜잭션이 값을 변경/삭제하거나 새로운 레코드를 삽입하는 경우로서 TX1 트랜잭션을 참조하기 바람
- Repeatable Read
  - 트랜잭션 내에서 쿼리를 두 번 이상 수행할 떄 첫 번째 쿼리에 있던 레코드가 사라지거나 값이 바뀌는 현상을 방지해줌
  - 이 트랜잭션 격리성 수준이 Phantom Read 현상을 막지는 못함
  - 첫 번쨰 쿼리에 없던 새로운 레코드가 나타날 수 있다는 것임
  - 한 트랜잭션 내에서 쿼리를 두번 수행했는데 두 쿼리 사이에 다른 트랜잭션이 새로운 레코드를 삽입하는 경우로서 TX1 트랜잭션을 참조할 것
- Serialzable Read
  - 트랜잭션 내에서 쿼리를 두 번 이상 수행할 때 첫 번째 쿼리에 있던 레코드가 사라지거나 값이 바뀌지 않음은 물론 새로운 레코드가 나타나지도 않음
- 트랜잭션 격리성 수준은 ISO에서 정한 분류 기준일 뿐, 모든 DBMS가 4가지 레벨을 다 지원하지는 않음
- 예를 들어 SQL Server와 DB2는 4가지 레벨을 다 지원하나, Oracle 은 Read Commited 와 Serializable Read만 지원함(Oracle 에서 Repeatable Read를 구현하려면 For Update문을 구현하면 됨)
- 대부분 DBMS가 Read Committed를 기본 트랜잭션 격리성 수준으로 채택하고 있으므로 Dirty Read가 발생할 까 걱정하지 않아도 되지만, Non-RepeatableR Read, Phantom Read 현상에 대한 세심한 주의가 필요함
- 그런 현상이 발생하지 않도록 DBMS 제공 기능을 이용할 수 있지만, 많은 경우 개발자가 직접 구현해 주어야 하기 때문임
- 다중 트랜잭션 환경에서 DBMS가 제공하는 기능을 이용해 동시성을 제어하려면 트랜잭션 시작 전에 명시적으로 Set Transaction 명령어를 수행하면 됨
- 아래는 트랜잭션 격리성 수준을 Serializable Read로 상향 조정하는 예시
```
set transaction isolation level read serializable;
```
- 트랜잭션 격리성 수준을 Repeatable Read나 Serializable Read로 올리면 ISO에서 정한 기준을 만족해야 하며 대부분 DBMS가 이를 구현하기 위해 Locking 메커니즘에 의존함
- 좀 더 위까지 유지하는 방식을 사용함
- 앞서 보았던 그림을 예롤들어 TX1 트랜잭션을 Repetable Read모드에서 실행했다고 하자 , 그러면 t1 시점에 1번 쿼리에서 설정한 공유 Lock을 t6시점까지 유지하므로 Tx2의 2번 update는 t6시점까지 대기해야 함
- 문제는 동시성임 한건씩 읽어 처리할 때는 잘 느끼지 못하는 수준이겠지만, 대량의 데이터를 읽어 처리할 때는 동시성이 심각하게 나빠짐
- 완벽한 데이터 일관성 유지를 위해 심지어 테이블 레벨을 걸어야 할 때도 있음
- 이에 대한 대안으로 다중버전 동시성 제어를 채택하는 DBMS가 조금씩 늘고 있음
- 스냅샷 격리성 수준이라고 불리는 이 방식을 한마디로 요약하면 현재 진행중인 트랜잭션에 의해 변경된 데이터를 읽고자할때 변경 이전 상태로 되돌린 버전을 읽는 것임
- 변경이 아직 확정되지 않은 값을 읽으려는 것이 아니라 공유 Lock을 설정하지 않아도 됨
- 따라서 읽는 세션과 변경하는 세션이 서로 간섭현상을 일으키지 않음
- TX2 트랜잭션에 의해 새로운 고객이 등록되더라도 TX1은 트랜잭션은 그 값을 무시함
- 트랜잭션 내내 자신이 시작된 T1시점을 기준으로 읽기 떄문에 데이터 일관성은 물론 높은 동시성을 유지할 수 있음
- DBMS는 다수의 사용자를 가정함
- 따라서 동시에 작용하는 다중 트랜잭션의 상호 간섭 작용에서 데이터베이스를 보호할 수 있어야 하며, 이를 동시성 제어라고 함
- 동시성을 제어할 수 있도록 하기 위해 모든 DBMS가 공통적으로 Lock기능을 제공함
- 여러 사용자가 데이터를 동시에 액세스하는 것처럼 보이지만, 내부적으로 하나씩 실행되도록 트랜잭션을 직렬화 하는 것
- 또한 set transaction 명령어를 이용해 트랜잭션 격리성 수주능ㄹ 조정할 수 있는 기능도 제공함
- DBMS마다 구현 방식이 다르나 SQL Server 를 예로 들면 기본 트랜잭션 격리성 수준인 Read Committed 상태에선 레코드를 읽고 다음 레코드를 이동하자마자 공유 Lock을 해제하지만, Repeatable Read로 올리면 트랜잭션을 커밋될 때 까지 공유 Lock을 유지함
- 동시성 제어가 어려운 이유가 바로 여기에 있는데 동시성과 일관성은 트레이드 오프 관계인 것
- 즉 동시성을 높이려고 Lock의 사용을 최소화하면 일관성을 유지하기 어렵고, 일관성을 높이려고 Lock을 적극적으로 사용하면 동시성이 저하됨
- 따라서 동시성 제어의목표는 동시에 실행되는 트랜잭션 수를 최대화 하면서도 입력 수정 삭제 검색 시 데터 무결성이 유지되도록 하는 데에 있음
- 동시성과 일관성의 상관관계는 반비례하다.
- 데이터베이스 개발자들이 간과해선 안되는 중요한 사실은, DBMS가 제공하는 set transaction 명령어로써 모든 동시성 제어 문제를 해결할 수 없다는 점
- n-tier 아키텍쳐가 지배적인 요즘 같은 애플리케이션 환경에서 특히 그렇다
- 예를 들어 사용자가 자신의 계좌에서 잔고를 확인하고 인출을 완료할 때 까지의 논리적인 작업 단위를 하나의 트랜잭션으로 처리하고자 할 때, 잔고를 확인하는 SQL과 인출하는 SQL이 서로 다른 연결을 통해 처리될 수 있기 때문
- DB와 연결하기 위해 사용하는 라이브러리나 그리드 컴포넌트가 동시성 제어 기능을 제공하기도 하지만, 많은 경우 트랜잭션의 동시성을 개발자가 직접 구현해야만 함
- 동시성 제어 기법에는 비관적 동시성 제어와 낙관적 동시성 제어 두가지가 있음

## 1. 비관적 동시성 제어 vs. 낙관적 동시성 제어

### 비관적 동시성 제어
- 비관적 동시성 제어에서느 사용자들이 같은 데이터를 동시에 수정할 것이라고 가정함
- 따라서 데이터를 읽는 시점에 Lock을 걸고 트랜잭션이 완료될 떄 까지 이를 유지함
```
select 적립포인트, 방문횟수, 최근방문일시, 구매실적
from 고객
where 고객번호 = :cust_num for update; - 새로운 적립포인트 계산 

update 고객 set 적립포인트 =: 적립포인트 
where 고객번호 = :cust_num;
```
- select 시점에 Lock을 거는 비관적 동시성 제어는 자칫 시스템 동시성을 심각하게 떨어뜨릴 우려가 있음
- 그러므로 아래와 같이 wait 또는 nowait 옵셔능ㄹ 함꼐 사용하는 것이 바람직함
```
for update nowait -> 대기 없이 Exceptionㅇ르 던짐 for update wait 3 -> 3초 대기 후 Exception을 던짐
```
- SQL Server에서도 for update 절을 사용할 수 있지만 커서를 명시적으로 선언할 때만 가능
- 따라서 SQL 에서 비관적 동시성 제어를 구현할 때는 holdlock이나 updlock 힌트를 사용하는 것이 편리하며, 이에 대한 구체적인 활용 사례는 1집에서 공유 Lock갱신 Lock과 함께 이어 설명한다.

### 낙관적 동시성 제어
- 낙관적 동시성 제어에선 사용자들이 같으 ㄴ데이터를 동시에 수정하지 않을 것이라고 가정함
- 따라서 데이터를 읽을 때는 Lock을 설정하지 않음
- 대신 수정 싲머에 다른 사용자에 의해 값이 변경됐는지를 반드시 검사해야 함
- 아래는 낙관적 동시성 제어의 구현 예시임

```
select 적립포인트, 방문횟수, 최근방문일시, 구매실적 into a, b, C,d from 고객 Where 고객번호 =:custnum; - 새로운 적립포인트 계산 update 고객 Set 적립포 인트= 적립포인트 where 고객번호= custnum and 적립포인트 = a and 방문횟수=b and 최근방문일시 = c and 구매실적 =:d; if sql%rowcount= 0 then alert ('다른 사용자에 의해 변경되었습니다.'); end if;
```
- 최종 변경일시를 관리하는 칼럼이 있다면, 아래와 같이 좀 더 간단하게 구현할 수 있다.
```
select 적립포인트, 방문횟수, 최근방문일시, 구매실적, 변경일시 into :a, b, c, d, mod_dt from 고객 where 고객번호 = :custnum; - 새로운 적립포인트 계산 upd ate 고객 set 적립포인트 =:적립포인트, 변경일시=SYSDATE where 고객번호 =:custnum and 변경일시 =:mod_dt ;> 최종 변경일시가 앞서 읽은 값과 같은지 비교
```

## 2. 다중버전 동시성 제어

### 일반적인 Locking 매커니즘의 문제점
- 동시성 제어의 목표는 동시에 실행되는 트랜잭션 수를 최대화 하면서도, 입력 수정 삭제, 검색 시 데이터 무결성이 유지되도록 증명하는 데에 있다고 함
- 그런데 읽기 작업에 공유 Lock을 사용하는 일반적인 Locking 매커니즘에서는 읽기 작업과 쓰기 작업이 서로 방해를 일으키기 떄문에 종종 동시성에 문제가 생기곤 함
- 또한 데이터 일관성에 문제가 생기는 경우도 있어 이를 해결하려면 Lock을 더 오랫동안 유지하거나 테이블 레벨 lock을 사용해야 하므로 동시성을 더 심각하게 떨어뜨리는 결과를 낳음

### 다중버전 동시성 제어
- 읽기 작업과 쓰기 작업이 서로 방해해 동시성을 떨어뜨리고, 공유 Lock을 사용함이도 불구 데이터 일관성이 훼손될 수 있는 문제를 해결하려고 Oracle은 버전 3부터 다중버전 동시성 제어 메커니즘을 사용해왔다.
- MS SQL Server도 2005 버전부터 IBM DB2도 9.7 버전부터 이 동시성 제어 메커니즘을 제공하기 시작한다
- 이처럼 DBMS 벤더들이 MVCC 모델을 채택하는 이유는 동시성과 일관성을 동시에 높이려는 노력의 일환임
- MVCC 메커니즘을 간단히 요약하면 다음과 같음
  - 데이터를 변경할 때 마다 그 변경사항을 Undo 영역에 저장해둔다
  - 데이터를 읽다가 쿼리 시작지점 이후에 변경된 값을 발겮아면, Undo 영역에 저장된 정보들을 이용해 쿼리(또는 트랜잭션)시작 시점의 일관성 있는 버전을 생성하고 그것을 읽음
- 쿼리 도중 배타적 Lock이 걸린 즉 변경이 진행 중인 레코드를 만나더라도 대기하지 않기 때문에 동시성 측면에서 매우 유리함
- 사용자에게 제공되는 데이터의 기준 시점이 쿼리 시작 시점으로 고정되기 때문에 일관성 측면에서도 유리함
- MVCC에 장점만 있는 것이 아님
- Undo 블록 I/O, CR Copy 생성, CR 블록 캐싱 같은 부가적인 작업 때문에 생기는 오버헤드도 무시할 수 없다
- 참고로 Oracle은 Undo 세그먼트에 저장하고, SQL Server는 tempdb에 저장함
- MVCC를 이용한 읽기 일관성에는 문장수준과 트랜잭션 수준 2가지가 있음

### 문장 수준 읽기 일관성
- 문장수준 읽기 일관성은 다른 트랜잭션에 의해 데이터의 추가, 변경 삭제가 발생하더라도 단일 SQL문 내에서 일관성 있게 값을 읽는 것을 말함
- 일관성 기준 시점은 쿼리 시작 시점이 됨
- 10023 시점에 시작된 쿼리가 10023 시점 이후에 변경된 데이터 블록을 만났을 떄 Rollback 세그먼트에 저장된 정보를 이용해 10023 이전 시점으로 되돌리고서 값을 읽는 것을 표현하고 있음
- SQL Server 에서 문장수준 읽기 일관성 모드로 DB를 운영하려면 아래 명령을 수행해주면 됨
```
alter database <데이터베이스 이름>  set read_committed_snapshot on;
```

### 트랜잭션 수준 읽기
- 트랜잭션 수준 읽기 일관성은 다른 트랜잭션에 의해 데이터의 추가 변경, 삭제가 발생하더라도 트랜잭션 내에서 일관성 있게 값을 읽는 것을 말함
- 기본 트랜잭션 격리성 수준에서 완벽한 문장수준의 읽기 일관성을 보장하는 MVCC 메커니증도 트랜잭션 수준의 읽기 일관성은 보장하지 않음
- 물론 일반적인 Locking 메커니즘도 트랜잭션 수준의 읽기 일관성을 보장하지 않음
- 트랜잭션 수준으로 완벽한 읽기 일관성을 보장받으려면 격리성 수준을 Serializable Read로 올려주어야 함
- 트랜잭션 격리성 수준을 Serializable Read로 상향 조정하면, 일관성 기준 시점은 트랜잭션 시작 시점이 됨
- 물론 트랜잭션이 진행되는 동안 자신이 발생시킨 변경사항을 그대로 읽음
- SQL Server에서 트랜잭션 읽기기 알관성 모드로 DB를 운영하려면 먼저 아래 명령을 수행해 주어야 함
```
lter database <데이터베이스 이름> set allow_snapshot_isolation on;
```
- 트랜잭션을 시작하기 전에 트랜잭션 격리성 수준을 아래와 같이 'snapshot'으로 변경해주면 됨

```
set transaction isolation level snapshot begin tran select ...: update ... : commit;
```

### Snapshot too old
- 세상에 공짜는 없다
- Undo 데이터를 활용함으로 높은 수준의 동시성과 읽기 일관성을 유지하는 대신, 일반적인 Locking 메커니즘에 없는 Snapshot too old 에러가 MVCC에서 발생함
- 대용량 데이터를 처리할 때 종종 개발자를 괴롭히는 것으로 악명 높은 이 에러는 Undo 영역에 저장된 Undo 정보가 다른 트랜잭션에 의해 재사용되 필요한 CR copy을 생성할 수 없을 때 발생함
- 이 에러의 발생 가능성을 줄이기 위해 DBMS 벤더 측의 노력이 계속되고 있지만, 아직 완벽한 해결책은 마련되지 못하고 있음
- 따라서 이를 회피하기 위한 DBA또는 개발자의 노력이 여전히 필요한 상태임
- Snapshot too old 에러 발생 가능성을 줄이는 법은 다음과 같음
  1. Undo 영역의 크기를 증가시킴
  2. 불필요하게 커밋을 자주 수행하지 않음
  3. fetch across commit 형태의 프로그램 작성을 피해 다른 방식으로 구현함 ANSI 표준에 따르면 커밋 이전에 열려 있던 커서는 더는 Fetch 하면 안됨 다른방법을 찾는다
  4. 트랜잭션이 몰리는 시간대에 오래 걸리는 쿼리가 같이 수행되지 않도록 나누어 읽고 단계적으로 실행할 수 있도록 코딩함. SnapShot too old 발생 가능성을 줄일 뿐 아니라 문제가 발생을할 때 특정 부분에서 다시 시작할 수 있어 유리함. 물론 그렇게 해도 읽기 일관성이 문제가 없을 때만 적용해야 함
  5. 오랜시간 걸쳐 같은 블록을 여러번 방문하는 Nested Loop 형태의 조인문 또는 인덱스를 경유한 테이블 액세스를 수반하는 프로그램이 있는지 체크하고 이를 회피할 수 있는 방법을 찾음
  6. 소트 부하를 감수하더라도 order by 등을 강제로 삽입해 소트 연산이 발생하도록 함
  7. 대량 업데이트 후에 곧바로 해당 테이블 또는 인덱스를 Full scan 하도록 쿼리를 수행하는 것도 하나의 해결방안이 될 수 잇음
```
select /*+ full(t) */ count(*) from table_name t
select count(*) from table_name where index_column > 0
```