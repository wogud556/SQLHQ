## 1.Lock 기본

### Lock이란?
- 고가의 DBMS를 사용하는 이유로는 성능, 관리의 편이성 등 여러가지 측면이 있지만, 무엇보다 트랜잭션 처리 능력이 가장 기본적이고 핵심적인 요소라고 할 수 있음
- 같은 자원을 액세스하려는 다중 트랜잭션 환경에서 데이터베이스의 읽관성과 무결성을 유지하려면 트랜잭션의 순차적 진행을 보장할 수 있는 직렬화 장치가 필요함
- 영화관 좌석을 예약하는 시스템을 예를 들면 두 명이 동시에 좌석을 요청할 때 정확히 한 명만 좌석을 배정받도록 할 수 있어야 함
- 이런 직렬화가 가능하도록 하기 위해 모든 DBMS가 공통적으로 사용하는 매커니즘이 Lock이다
- 중요한 것은 DBMS마다 Lock을 구현하는 방식과 세부적인 기능이 많이 다르다는 사실임
- 따라서 자신이 사용하고 있는 DBMS만의 독특한 Lock 매커니즘을 정확히 이해하지 못한 상태에선 결코고품질 데이터베이스를 구축할 수 없음

### 공유 Lock과 배타적 Lock
- DBMS는 각 트랜잭션의 오퍼레이션별로 적당한 수준의 Lock을 자동으로 설정함
- 필요한 경우 일부 Lock에 대해서는 사용자가 직접 제어하는 방법도 제공함
- 가장 기본이 되는 LocK 모드는 공유 LocK과 배타적 Lock임

#### 공유 Lock
- 공유 Lock은 데이터를 읽고자 할때 사용됨
- 다른 공유 Lock과는 호환되지만 배타적 lock과는 호환되지 않음
- 호환된다는 말은 한 리소스에 두개 이상의 Lock을 동시에 설정할 수 있음을 뜻함
- 다시 말해 공유 Lock을 설정한 리소스에 다른 트랜잭션이 추가로 공유 Lock을 설정할 수 있지만 배타적 Lock은 불가능함
- 따라서 자신이 읽고 있는 리소스를 다른 사용자가 동시에 읽을 수는 있어도 변경은 불가능함
- 반대로 다른 사용자가 읽고 있는 리소스를 동시에 읽을 수는 있어도 변경 중인 리소스를 동시에 읽을 수는 없음

#### 배타적 Lock
- 배타적 Lock은 데이터를 변경하고자 할 때 사용되며, 트랜잭션이 완료될 때 까지 유지됨
- 말 그대로 배타적이기 때문에 그 Lock이 해제될 때 까지는 다른 트랜잭션은 해당 리소스에 접근할 수 없음
- 변경이 불가능할 뿐 아니라 읽기도 불가능함
- 반대로 다른 트랜잭션에 의해 Lock이 설정된 리소스는 그것이 공유 Lock이든 배타적 Lock을 동시에 설정할 수 없음

### 블로킹과 교착상태

#### 블로킹
- 블로킹은 Lock 경합이 발생해 특정 세션이 작업을 진행하지 못하고 멈춰 선 상태를 말함
- 공유 Lock끼리는 호환되기 대문에 블로킹이 발생하지 않음
- 공유 Lock과 배타적 Lock은 호환되지 않아 블로킹이 발생할 수 있다
- 배타적 Lock끼리는 당연히 호환되지 않음
- 블로킹 상태를 해소하는 방법은 커밋 뿐임
- 즉 Lock 경합이 발생하면 먼저 Lock을 설정한 트랜잭션이 완료될 떄 까지 후행 트랜잭션은 기다려야 하며, 이런 현상이 자주 나타난다면 사용자가 느끼는 애플리케이션 성능이 좋을 리 없음
- Lock에 의한 성능 저하를 최소화하는 방안을 살펴본다
  - 트랜잭션의 원자성을 훼손하지 않는 선에서 트랜잭션을 가능한 짧게 정의하려는 노력이 필요함
    - Oracle은 데이터를 읽을 때 공유 Lock을 사용하지 않기 때문에 다른 DBMS에 비해 상대적으로 Lock 경합이 적게 발생함
    - 그렇더라도 배타적 Lock 끼리 발생하는 경합은 피하지 못하므로 불필요하게 트랜잭션을 길게 정의해선 안됨
  - 같은 데이터를 갱신하는 트랜잭션이 동시에 수행되지 않도록 설계하는 것도 중요함
    - 특히 트랜잭션이 활발한 주간에 대용량 갱신 작업을 수행해선 안됨
  - 주간에 대용량 갱신 작업이 불가피 하다면 블로킹 현상에 의해 사용자가 무한정 기다리지 않도록 적절한 프로그래밍 기법을 도입해야 함
    - 예를 들어 SQL Server 에서는 세션 레벨에서 LOCK_TIMEOUT을 설정할 수 있음
    - 아래는 Lock에 의한 대기 시간이 최대 2초를 넘지 않도록 설정한 것
  ```
  set lock_timeout 2000
  ``` 
  - Oracle이라면 update/delete문장을 수행하기 전에 nowait나 wait 옵션을 지정한 select -- for update문을 먼저 수행해 봄으로써 Lock이 설정됐는지 체크할 수 있고, 발생한 예외사항(exception)에 따라 적절한 조치를 취할 수 있음
```
select * from t where no = 1 for update nowait 대기 없이 Exception 던짐
SELECT * FROM T where no = 1 for update wait 3 -> 3초 대기 후 Exception을 던짐
```
  - 트랜잭션 격리성 수준을 불필요하게 상향 조정하지 않음
  - 트랜잭션을 잘 설계하고 대기 현상을 피하는 프로그래밍 기법을 적용하기 앞서, SQL 문장이 가장 빠른 시간 내에 처리를 완료하도록 하는 것이 Lock 튜닝의 기본이고 효과도 가장 확실함

#### 교착상태
- 교착상태는 두 세션이 각각 Lock을 설정한 리소스를 서로 액세스하려고 마주보며 진행하는 상황을 말하며, 둘 중 하나가 뒤로 물러나지 않으면 영영 풀릴 수 없음
- 흔히 좁은 골목길에 두 대의 차량이 마주 선 것에 비유하곤 함
- 교착상태가 발생하면 DBMS가 둘 중 한 세션에 에러를 발생시킴으로써 문제를 해결하는데, 이를 방지하려면 어떻게 해야하나?
- 조금 전 설명한 Lock 튜닝 방안은 교착상태 발생 가능성을 줄이는 방안이기도 함
- 여러 테이블을 액세스하면서 발생하는 교착상태는 테이블 접근 순서를 같게 처리하면 피할 수 있음
- 예를 들어 마스터 테이블과 상세 테이블 둘 다 갱신할 때 마스터 테이블 다음에 상세 테이블을 갱신하기로 규칙을 정하고, 모든 애플리케이션 개발자가 이 규칙을 지킨다면, 교착상태는 발생하지 않을 것
- SQL Server라면 잠시 후 설명할 갱신 Lock을 사용함으로써 교착 상태 발생 가능성을 줄일 수 있음

## SQL Server Lock

### Lock 종류

#### 공유 Lock
- SQL Server의 공유 Lock은 트랜잭션이나 쿼리 수행이 완료될 때 까지 유지되는 것이 아니라 다음 레코드가 읽히면 곧바로 해제됨
- 단 기본 트랜잭션 격리 성 수준에서만 그렇다
- 격리성 수준을 변경하지 않고도 트랜잭션 내에서 공유 Lock이 유지되도록 하려면 아래와 같이 테이블 힌트로 holdlock을 지정하면 됨
- 트랜잭션 격리성 수준에 대해서는 다음 절에서 설명함
```
begin tran
select 적립포인트, 방문횟수, 최근방문일시, 구매실적
  from 고객
  with (holdlock)
 where 고객번호 = :cust_num 새로운 
```
- 나중에 변경할 목적으로 레코드를 읽을 때는 반드시 위와 같은 패턴으로 트랜잭션을 처리해야 함
- 위 사례에서 방문횟수, 최근방문일시, 구매실적에 따라 새로운 적립 포인트를 계산하는데, 만약 고객 데이터를 읽고 적립 포인트를 변경하기 전에 다른 트랜잭션이 해당 고객 데이터를 변경한다면 적립 포인트가 비일관된 상태에 놓일 수 있기 때문임

#### 배타적 Lock
- 1항에서 설명한 내용과 같음

#### 갱신 Lock
- 앞서 공유 Lock을 설명하면서 예시로 하던 적립포인트 변경 프로그램을 공교롭게도 두 트랜잭션이 동시에 수행된다고 가정한다
- 그것도 같은 고객에 대해서 말임
- 두 트랜잭션 모두 처음에는 공유 Lock을 설정하다가 적립 포인트를 변경하기 직전에 배타적 Lock을 설정하려고 할 것임
- 두 트랜잭션은 상대편 트랜잭셩에 의한 공유 Lock이 해제되기만을 기다리는 교착상태에 빠지게 됨
- 이런 잠재적인 교착상태를 방지하려고 SQL Server는 갱신(update)Lock을 두게 되었고, 이 기능을 사용하려면 아래와 같이 updlock힌트를 지정하면 됨

#### 의도 Lock
- 특정 로우에 Lock을 설정하면 그와 동시에 상위 레벨 개체에 내부적으로 의도 Lock이 설정됨
- Lock을 설정하려는 개체의 하위 레벨에서 선행 트랜잭션이 어떤 작업을 수행 중인지를 알리는 용도로 사용되며, 일종의 푯말(Flag)이라고 할 수 있음
- 예를 들어, 구조를 변경하기 위해 테이블을 잠그려 할 때 그 하위의 모든 페이지나 익스텐트, 심지어 로우에 어떤 Lock이 설정돼 있는지를 일일이 검사해야 한다면 좀처럼 작업이 끝나지 않을 수 있음
- 의도 Lock은 그런 현상을 방지해 줌
- 즉 해당 테입르에 어떤 모드의 의도 Lock이 설정돼 있는지 보고도 작업을 진행할 지 아니면 기다릴지를 결정할 수 있음

#### 스키마 Lock
- 테이블 스키마에 의존적인 작업을 수행할 때 사용됨
  - Sch-S(Schema Stability)
    - SQL을 컴파일 하면서 오브젝트 스키마를 참조할 때 발생, 읽는 스키마 정보가 수정되거나 삭제되지 못하도록 함
  - Sch-M(Schema Modification)
    - 테이블 구조를 변경하는 DDL 문을 수행할 때 발생하며, 수정 중인 스키마 정보를 다른 세션이 참조하지 못하도록 함

#### Bulk Update Lock
- 테이블 Lock의 일종으로, 테이블에 데이터를 Bulk Copy 할 때 발생함. 병렬 데이터 로딩을 허용하지만 일반적인 트랜잭션 작업은 허용되지 않음

### Lock 레벨과 Escalation

#### Lock 레벨과 Escalation
- 로우 레벨
  - 변경하려는 로우에만 Lock을 설정하는 것을 말함
- 페이지 레벨
  - 변경하려는 로우가 담긴 데이터 페이지에 Lock을 설정하는 것을 말함
  - 같은 페이지에 속한 로우는 진행중인 변경 작업과 무관하더라도 모두 잠긴 것과 같은 효과가 나타남
- 익스텐트 레벨
  - 익스텐트 전체가 잠김
  - SQL Server의 경우 하나의 익스텐트가 여덟개 페이지로 구성되므로 8개 페이지에 속한 모든 로우가 잠긴 것과 같은 효과가 나타남
- 테이블 레벨
  - 테이블 전체 그리고 관련 인덱스까지 모두 잠김
- 데이터베이스 레벨
  - 데이터베이스 전체가 잠김
  - 이는 보통 데이터베이스를 복구하거나 스키마를 변경할 때 일어남
- 위 5가지 레벨 외에 인덱스 키에 로우 레벨을 거는 경우도 있음

#### Lock Escalation
- Lock Escalation이란 관리할 Lock 리소스가 정해진 임계치를 넘으면서 로우 레벨 락이 페이지, 익스텐트, 테이블 레벨 락으로 점점 확장되는 것을 말함
- 이는 SQL Server, DB2 UDB 처럼 한정된 메모리 상에서 Lock 매니저를 통해 Lock 정보를 관리하는 DBMS에서 공통적으로 발생할 수 있는 현상
- Locking레벨이 낮을 수록 동시성은 좋지만, 관리해야 할 Lock 개수가 증가하기 때문에 더 많은 리소스를 소비함
- 반대로 Locking레벨이 높을 수록 적은 양의 Lock리소스를 사용하지만 하나의 Lock으로 수많은 레코드를 한번에 잠그기 때문에 동시성은 나빠짐


### Lock 호환성
- 호환된다는 말은 한 리소스에 두 개 이상의 Lock을 동시에 설정할 수 있음을 똣함
- 앞서 설명한 Lock 종류별로 호환성을 요약하면 아래와 같음

<img src="./img/2/2.png" width = "200" height = "400">

- 스키마 Lock의 호환성은 다음과 같음
  - Sch-S는 Sch-M을 제외한 모든 Lock과 호한
  - Sch-M은 어떤 Lock과도 호환되지 않음

## Oracle Lock
- Oracle은 공유 리소스와 사용자 데이터를 보호할 목적으로 DML Lock, DDL Lock, 래치(Latch), 버퍼 Lock, 라이브러리 캐시 Lock/Pin 등 다양한 종류의 Lock을 사용함
- 이들 중 애플리케이션 개발 측면에서 가장 중요하게 다루어야 할 Lock은 무엇보다 DML Lock임
- DML Lock은 다중 사용자에 의해 동시에 액세스 되는 사용자 데이터의 무결성을 보호해 줌
- DML LocK에는 로우 Lock과 테이블 Lock이 있음

### 로우 Lock
- Oracle에서 로우 Lock은 항상 배타적임
- insert, update, delete문이나 select...for update문을 수행한 트랜잭션에 의해 설정되며, 이 트랜잭션이 커밋 도는 롤백할 때까지 다른 트랜잭션은 해당 로우를 변경할 수 없음
- Oracle에서 일반 select문에 의해 읽힌 레코드에는 어떤 Lock도 설정되지 않음
- 다른 DBMS처럼 읽기 작업에 대한 공유 Lock을 사용하지 않기 때문에 Oracle에서 읽기와 갱신 작업은 서로 방해하지 않음
  - 읽으려는 데이터를 다른 트랜잭션이 갱신 중이더라도 기다리지 않음
  - 갱신하려는 데이터를 다른 트랜잭션이 읽는 중이더라도 기다리지 않음
  - 갱신하려는 데이터를 다른 트랜잭션이 갱신 중이면 기다림
- Oracle이 공유 Lock을 사용하지 않고도 일관성을 유지할 수 있는 것은 Undo 데이터를 이용한 다중 버전 동시성 제어 메커니즘없이 레코드의 속성으로서 로우 Lock을 구현하기 때문에 아무리 많은 레코드를 갱신하더라도 절대 Lock Escalation은 발생하지 않음

### 테이블 Lock
- 한 트랜잭션이 로우 Lock을 얻는 순간, 해당 테이블에 대한 테이블 Lock을 얻음
- 그럼으로써 현재 트랜잭션이 갱신 중인 테이블에 대한 호환되지 않는 DDL 오퍼레이션을 방지함
- 테이블 구조를 변경하지 못하도록 막는 것
- 테이블 Lock종류로는 5가지가 있음
```
Row Share(RS)
Row Exclusive(RX)
Share(S)
Share Row Exclusive(SRX)
Exclusive

```
- 대표적으로 select...for update문을 수행할 때는 RS 모드 테이블 Lock을 얻고, insert update delete문을 수행할 때 RX 모드 테이블 Lock을 얻는다
- DML 로우 Lock을 처음 얻는 순간 묵시적으로 테이블 Lock을 얻지만 아래 처럼 Lock Table명령어를 이용해 명시적으로 테이블 Lock을 얻을 수도 있음
- 테이블 lock이라고 하면 테이블 전체에 Lock이 걸린다고 생각하기 쉬움
- DML 수행 시 항상 테이블 Lock이 함께 설정된다고 했는데, 만약 이것이 SQL Server의 테이블 레벨 Lock 처럼 테이블 전체를 잠그는 기능이라면 다른 트랜잭션이 더는 레코드를 추가하거나 갱신하지 못하도록 막게 될 것임
- 하지만 RX와 RX간 호환성이 있으므로 그런일은 발생하지 않음
- Oracle에서 말하는 테이블 Lock은 Lock을 획득한 선행 트랜잭션이 해당 테이블에서 현재 어떤 작업을 수행중인지를 알리는 일종의 푯말임
- 후행 트랜잭션은 어떤 테이블 Lock이 설정돼 있는지만 보고도 그 테이블로의 진입 여부를 결정할 수 있음

## Lock과 트랜잭션 동시성 제어
- 트랜잭션은 업무 처리를 위한 논리적인 작업 단위임
- 작업의 논리적 단위가 단일연산이 아닐 수 있음
- 하나의 트랜댁션이 두개 이상의 갱신 연산 일 수 있음
- 은행의 "걔좌이체"트랜잭션을 예로 들면 하나의 예금 계좌에서 인출하여 다른 예금 계좌에 입금하는 일련의 작업을 하나의 단위로 수행헤야 함
- 데이터를 일관성 있게 처리하려면 트랜잭션에 속한 두개 이상의 갱신 연산을 동시에 실행할 수 있어야 하는데, 불행히도 이는 불가능한 일임
- 따라서 DBMS는 차선책을 사용하는데 즉 여러개의 갱신 연산이 하나의 작업처럼 전부 처리되거나 아예 하나도 처리되지 않도록 동시 실행을 구현함

## 1. 트랜잭션의 특징
- 데이터베이스의 갱신과 관련하여 트랜잭션은 아래와 같은 4가지 주요 특징을 가지며, 영문 첫 글자를 따서 ACID라고 부름
  - 원자성
    - 트랜잭션은 더이상 분해가 불가능한 업무의 최소 단위이므로 전부 처리되거나 아예 하나도 처리되지 않아야 함
  - 일관성
    - 일관된 상태에서 데이터베이스에서 하나의 트랜잭션을 성공저긍로 완료하고 나면 그 데이터베이스는 여전히 일관된 상태여야 함
    - 즉 트랜잭션 실행의 결과로 데이터베이스 상태가 모순되지 않아야 함
  - 격리성
    - 실행중인 트랜잭션의 중간결과를 다른 트랜잭션이 접근할 수 없음
  - 영속성
    - 트랜잭션이 일단 그 실행을 성공적으로 완료하면 그 결과는 데이터베이스에 영속적으로 저장됨

## 2. 트랜잭션 격리성
- 트랜잭션 격리성은 일관성가 마찬가지로 Lock을 강하게 오래 유지할수록 강화되고, Lock을 최소화할수록 약화됨
- 낮은 단계의 격리성 수준에서 어떤 현상들이 발생하는지부터 봐야 함

### 낮은 단계의 격리성 수준에서 발생할 수 있는 현상들

#### Dirty Read
- 다른 트랜잭션에 의해 수정됐지만, 아직 커밋되지 않은 데이터를 읽는 것을 말함
- 변경 후 아직 커밋되지 않은 값을 읽었을 때 변겨경을 가한 트랜잭션이 최종적으로 롤백된다면 그 값을 읽은 트랜잭션은 비일관된 상태에 놓이게 됨

#### Non-Repeatable Read
- 한 트랜잭션 내에서 같은 쿼리를 두번 수행됐는데, 그 사이에 다른 트랜잭션 값을 수정 또는 삭제하는 바람에 두 쿼리 결과가 다르게 나타나는 현상을 말함

### 트랜잭션 격리성 수준
- ANSI/ISO SQL 표준에서 정의한 4가지 트랜잭션 격리성 수준은 다음가 같음
- Read Uncommitted
  - 트랜잭션에서 처리 중인 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용
- Read Committed
  - 트랜잭션이 커밋되어 확장된 데이터만 다른 트랜잭션이 읽도록 허용함으로 Dirty Read를 방지해줌
  - 커밋된 데이터만 읽더라도 Non-Repeatable Read와 Phantom Read 현상을 막지는 못함
  - 읽는 시점에서 결과가 다를 수 있다는 것
  - 한 트랜잭션 내에서 쿼리를 두번 수행했는데 두 쿼리 사이에 다른 트랜잭션이 값을 변경/삭제하거나 새로운 레코드를 삽입하는 경우로서 TX1 트랜잭션을 참조하기 바람
- Repeatable Read
  - 트랜잭션 내에서 쿼리를 두 번 이상 수행할 떄 첫 번째 쿼리에 있던 레코드가 사라지거나 값이 바뀌는 현상을 방지해줌
  - 이 트랜잭션 격리성 수준이 Phantom Read 현상을 막지는 못함
  - 첫 번쨰 쿼리에 없던 새로운 레코드가 나타날 수 있다는 것임
  - 한 트랜잭션 내에서 쿼리를 두번 수행했는데 두 쿼리 사이에 다른 트랜잭션이 새로운 레코드를 삽입하는 경우로서 TX1 트랜잭션을 참조할 것
- Serialzable Read
  - 트랜잭션 내에서 쿼리를 두 번 이상 수행할 때 첫 번째 쿼리에 있던 레코드가 사라지거나 값이 바뀌지 않음은 물론 새로운 레코드가 나타나지도 않음
- 트랜잭션 격리성 수준은 ISO에서 정한 분류 기준일 뿐, 모든 DBMS가 4가지 레벨을 다 지원하지는 않음
- 예를 들어 SQL Server와 DB2는 4가지 레벨을 다 지원하나, Oracle 은 Read Commited 와 Serializable Read만 지원함(Oracle 에서 Repeatable Read를 구현하려면 For Update문을 구현하면 됨)
- 대부분 DBMS가 Read Committed를 기본 트랜잭션 격리성 수준으로 채택하고 있으므로 Dirty Read가 발생할 까 걱정하지 않아도 되지만, Non-RepeatableR Read, Phantom Read 현상에 대한 세심한 주의가 필요함
- 그런 현상이 발생하지 않도록 DBMS 제공 기능을 이용할 수 있지만, 많은 경우 개발자가 직접 구현해 주어야 하기 때문임
- 다중 트랜잭션 환경에서 DBMS가 제공하는 기능을 이용해 동시성을 제어하려면 트랜잭션 시작 전에 명시적으로 Set Transaction 명령어를 수행하면 됨
- 아래는 트랜잭션 격리성 수준을 Serializable Read로 상향 조정하는 예시
```
set transaction isolation level read serializable;
```
- 트랜잭션 격리성 수준을 Repeatable Read나 Serializable Read로 올리면 ISO에서 정한 기준을 만족해야 하며 대부분 DBMS가 이를 구현하기 위해 Locking 메커니즘에 의존함
- 좀 더 위까지 유지하는 방식을 사용함
- 앞서 보았던 그림을 예롤들어 TX1 트랜잭션을 Repetable Read모드에서 실행했다고 하자 , 그러면 t1 시점에 1번 쿼리에서 설정한 공유 Lock을 t6시점까지 유지하므로 Tx2의 2번 update는 t6시점까지 대기해야 함
- 문제는 동시성임 한건씩 읽어 처리할 때는 잘 느끼지 못하는 수준이겠지만, 대량의 데이터를 읽어 처리할 때는 동시성이 심각하게 나빠짐
- 완벽한 데이터 일관성 유지를 위해 심지어 테이블 레벨을 걸어야 할 때도 있음
- 이에 대한 대안으로 다중버전 동시성 제어를 채택하는 DBMS가 조금씩 늘고 있음
- 스냅샷 격리성 수준이라고 불리는 이 방식을 한마디로 요약하면 현재 진행중인 트랜잭션에 의해 변경된 데이터를 읽고자할때 변경 이전 상태로 되돌린 버전을 읽는 것임
- 변경이 아직 확정되지 않은 값을 읽으려는 것이 아니라 공유 Lock을 설정하지 않아도 됨
- 따라서 읽는 세션과 변경하는 세션이 서로 간섭현상을 일으키지 않음
- TX2 트랜잭션에 의해 새로운 고객이 등록되더라도 TX1은 트랜잭션은 그 값을 무시함
- 트랜잭션 내내 자신이 시작된 T1시점을 기준으로 읽기 떄문에 데이터 일관성은 물론 높은 동시성을 유지할 수 있음
- DBMS는 다수의 사용자를 가정함
- 따라서 동시에 작용하는 다중 트랜잭션의 상호 간섭 작용에서 데이터베이스를 보호할 수 있어야 하며, 이를 동시성 제어라고 함
- 동시성을 제어할 수 있도록 하기 위해 모든 DBMS가 공통적으로 Lock기능을 제공함
- 여러 사용자가 데이터를 동시에 액세스하는 것처럼 보이지만, 내부적으로 하나씩 실행되도록 트랜잭션을 직렬화 하는 것
- 또한 set transaction 명령어를 이용해 트랜잭션 격리성 수주능ㄹ 조정할 수 있는 기능도 제공함
- DBMS마다 구현 방식이 다르나 SQL Server 를 예로 들면 기본 트랜잭션 격리성 수준인 Read Committed 상태에선 레코드를 읽고 다음 레코드를 이동하자마자 공유 Lock을 해제하지만, Repeatable Read로 올리면 트랜잭션을 커밋될 때 까지 공유 Lock을 유지함
- 동시성 제어가 어려운 이유가 바로 여기에 있는데 동시성과 일관성은 트레이드 오프 관계인 것
- 즉 동시성을 높이려고 Lock의 사용을 최소화하면 일관성을 유지하기 어렵고, 일관성을 높이려고 Lock을 적극적으로 사용하면 동시성이 저하됨
- 따라서 동시성 제어의목표는 동시에 실행되는 트랜잭션 수를 최대화 하면서도 입력 수정 삭제 검색 시 데터 무결성이 유지되도록 하는 데에 있음
- 동시성과 일관성의 상관관계는 반비례하다.
- 데이터베이스 개발자들이 간과해선 안되는 중요한 사실은, DBMS가 제공하는 set transaction 명령어로써 모든 동시성 제어 문제를 해결할 수 없다는 점
- n-tier 아키텍쳐가 지배적인 요즘 같은 애플리케이션 환경에서 특히 그렇다
- 예를 들어 사용자가 자신의 계좌에서 잔고를 확인하고 인출을 완료할 때 까지의 논리적인 작업 단위를 하나의 트랜잭션으로 처리하고자 할 때, 잔고를 확인하는 SQL과 인출하는 SQL이 서로 다른 연결을 통해 처리될 수 있기 때문
- DB와 연결하기 위해 사용하는 라이브러리나 그리드 컴포넌트가 동시성 제어 기능을 제공하기도 하지만, 많은 경우 트랜잭션의 동시성을 개발자가 직접 구현해야만 함
- 동시성 제어 기법에는 비관적 동시성 제어와 낙관적 동시성 제어 두가지가 있음

## 1. 비관적 동시성 제어 vs. 낙관적 동시성 제어

### 비관적 동시성 제어
- 비관적 동시성 제어에서느 사용자들이 같은 데이터를 동시에 수정할 것이라고 가정함
- 따라서 데이터를 읽는 시점에 Lock을 걸고 트랜잭션이 완료될 떄 까지 이를 유지함
```
select 적립포인트, 방문횟수, 최근방문일시, 구매실적
from 고객
where 고객번호 = :cust_num for update; - 새로운 적립포인트 계산 

update 고객 set 적립포인트 =: 적립포인트 
where 고객번호 = :cust_num;
```
- select 시점에 Lock을 거는 비관적 동시성 제어는 자칫 시스템 동시성을 심각하게 떨어뜨릴 우려가 있음
- 그러므로 아래와 같이 wait 또는 nowait 옵셔능ㄹ 함꼐 사용하는 것이 바람직함
```
for update nowait -> 대기 없이 Exceptionㅇ르 던짐 for update wait 3 -> 3초 대기 후 Exception을 던짐
```
- SQL Server에서도 for update 절을 사용할 수 있지만 커서를 명시적으로 선언할 때만 가능
- 따라서 SQL 에서 비관적 동시성 제어를 구현할 때는 holdlock이나 updlock 힌트를 사용하는 것이 편리하며, 이에 대한 구체적인 활용 사례는 1집에서 공유 Lock갱신 Lock과 함께 이어 설명한다.

### 낙관적 동시성 제어
- 낙관적 동시성 제어에선 사용자들이 같으 ㄴ데이터를 동시에 수정하지 않을 것이라고 가정함
- 따라서 데이터를 읽을 때는 Lock을 설정하지 않음
- 대신 수정 싲머에 다른 사용자에 의해 값이 변경됐는지를 반드시 검사해야 함
- 아래는 낙관적 동시성 제어의 구현 예시임

```
select 적립포인트, 방문횟수, 최근방문일시, 구매실적 into a, b, C,d from 고객 Where 고객번호 =:custnum; - 새로운 적립포인트 계산 update 고객 Set 적립포 인트= 적립포인트 where 고객번호= custnum and 적립포인트 = a and 방문횟수=b and 최근방문일시 = c and 구매실적 =:d; if sql%rowcount= 0 then alert ('다른 사용자에 의해 변경되었습니다.'); end if;
```
- 최종 변경일시를 관리하는 칼럼이 있다면, 아래와 같이 좀 더 간단하게 구현할 수 있다.
```
select 적립포인트, 방문횟수, 최근방문일시, 구매실적, 변경일시 into :a, b, c, d, mod_dt from 고객 where 고객번호 = :custnum; - 새로운 적립포인트 계산 upd ate 고객 set 적립포인트 =:적립포인트, 변경일시=SYSDATE where 고객번호 =:custnum and 변경일시 =:mod_dt ;> 최종 변경일시가 앞서 읽은 값과 같은지 비교
```

## 2. 다중버전 동시성 제어

### 일반적인 Locking 매커니즘의 문제점
- 동시성 제어의 목표는 동시에 실행되는 트랜잭션 수를 최대화 하면서도, 입력 수정 삭제, 검색 시 데이터 무결성이 유지되도록 증명하는 데에 있다고 함
- 그런데 읽기 작업에 공유 Lock을 사용하는 일반적인 Locking 매커니즘에서는 읽기 작업과 쓰기 작업이 서로 방해를 일으키기 떄문에 종종 동시성에 문제가 생기곤 함
- 또한 데이터 일관성에 문제가 생기는 경우도 있어 이를 해결하려면 Lock을 더 오랫동안 유지하거나 테이블 레벨 lock을 사용해야 하므로 동시성을 더 심각하게 떨어뜨리는 결과를 낳음

### 다중버전 동시성 제어
- 읽기 작업과 쓰기 작업이 서로 방해해 동시성을 떨어뜨리고, 공유 Lock을 사용함이도 불구 데이터 일관성이 훼손될 수 있는 문제를 해결하려고 Oracle은 버전 3부터 다중버전 동시성 제어 메커니즘을 사용해왔다.
- MS SQL Server도 2005 버전부터 IBM DB2도 9.7 버전부터 이 동시성 제어 메커니즘을 제공하기 시작한다
- 이처럼 DBMS 벤더들이 MVCC 모델을 채택하는 이유는 동시성과 일관성을 동시에 높이려는 노력의 일환임
- MVCC 메커니즘을 간단히 요약하면 다음과 같음
  - 데이터를 변경할 때 마다 그 변경사항을 Undo 영역에 저장해둔다
  - 데이터를 읽다가 쿼리 시작지점 이후에 변경된 값을 발겮아면, Undo 영역에 저장된 정보들을 이용해 쿼리(또는 트랜잭션)시작 시점의 일관성 있는 버전을 생성하고 그것을 읽음
- 쿼리 도중 배타적 Lock이 걸린 즉 변경이 진행 중인 레코드를 만나더라도 대기하지 않기 때문에 동시성 측면에서 매우 유리함
- 사용자에게 제공되는 데이터의 기준 시점이 쿼리 시작 시점으로 고정되기 때문에 일관성 측면에서도 유리함
- MVCC에 장점만 있는 것이 아님
- Undo 블록 I/O, CR Copy 생성, CR 블록 캐싱 같은 부가적인 작업 때문에 생기는 오버헤드도 무시할 수 없다
- 참고로 Oracle은 Undo 세그먼트에 저장하고, SQL Server는 tempdb에 저장함
- MVCC를 이용한 읽기 일관성에는 문장수준과 트랜잭션 수준 2가지가 있음

### 문장 수준 읽기 일관성
- 문장수준 읽기 일관성은 다른 트랜잭션에 의해 데이터의 추가, 변경 삭제가 발생하더라도 단일 SQL문 내에서 일관성 있게 값을 읽는 것을 말함
- 일관성 기준 시점은 쿼리 시작 시점이 됨
- 10023 시점에 시작된 쿼리가 10023 시점 이후에 변경된 데이터 블록을 만났을 떄 Rollback 세그먼트에 저장된 정보를 이용해 10023 이전 시점으로 되돌리고서 값을 읽는 것을 표현하고 있음
- SQL Server 에서 문장수준 읽기 일관성 모드로 DB를 운영하려면 아래 명령을 수행해주면 됨
```
alter database <데이터베이스 이름>  set read_committed_snapshot on;
```

### 트랜잭션 수준 읽기
- 트랜잭션 수준 읽기 일관성은 다른 트랜잭션에 의해 데이터의 추가 변경, 삭제가 발생하더라도 트랜잭션 내에서 일관성 있게 값을 읽는 것을 말함
- 기본 트랜잭션 격리성 수준에서 완벽한 문장수준의 읽기 일관성을 보장하는 MVCC 메커니증도 트랜잭션 수준의 읽기 일관성은 보장하지 않음
- 물론 일반적인 Locking 메커니즘도 트랜잭션 수준의 읽기 일관성을 보장하지 않음
- 트랜잭션 수준으로 완벽한 읽기 일관성을 보장받으려면 격리성 수준을 Serializable Read로 올려주어야 함
- 트랜잭션 격리성 수준을 Serializable Read로 상향 조정하면, 일관성 기준 시점은 트랜잭션 시작 시점이 됨
- 물론 트랜잭션이 진행되는 동안 자신이 발생시킨 변경사항을 그대로 읽음
- SQL Server에서 트랜잭션 읽기기 알관성 모드로 DB를 운영하려면 먼저 아래 명령을 수행해 주어야 함
```
lter database <데이터베이스 이름> set allow_snapshot_isolation on;
```
- 트랜잭션을 시작하기 전에 트랜잭션 격리성 수준을 아래와 같이 'snapshot'으로 변경해주면 됨

```
set transaction isolation level snapshot begin tran select ...: update ... : commit;
```

### Snapshot too old
- 세상에 공짜는 없다
- Undo 데이터를 활용함으로 높은 수준의 동시성과 읽기 일관성을 유지하는 대신, 일반적인 Locking 메커니즘에 없는 Snapshot too old 에러가 MVCC에서 발생함
- 대용량 데이터를 처리할 때 종종 개발자를 괴롭히는 것으로 악명 높은 이 에러는 Undo 영역에 저장된 Undo 정보가 다른 트랜잭션에 의해 재사용되 필요한 CR copy을 생성할 수 없을 때 발생함
- 이 에러의 발생 가능성을 줄이기 위해 DBMS 벤더 측의 노력이 계속되고 있지만, 아직 완벽한 해결책은 마련되지 못하고 있음
- 따라서 이를 회피하기 위한 DBA또는 개발자의 노력이 여전히 필요한 상태임
- Snapshot too old 에러 발생 가능성을 줄이는 법은 다음과 같음
  1. Undo 영역의 크기를 증가시킴
  2. 불필요하게 커밋을 자주 수행하지 않음
  3. fetch across commit 형태의 프로그램 작성을 피해 다른 방식으로 구현함 ANSI 표준에 따르면 커밋 이전에 열려 있던 커서는 더는 Fetch 하면 안됨 다른방법을 찾는다
  4. 트랜잭션이 몰리는 시간대에 오래 걸리는 쿼리가 같이 수행되지 않도록 나누어 읽고 단계적으로 실행할 수 있도록 코딩함. SnapShot too old 발생 가능성을 줄일 뿐 아니라 문제가 발생을할 때 특정 부분에서 다시 시작할 수 있어 유리함. 물론 그렇게 해도 읽기 일관성이 문제가 없을 때만 적용해야 함
  5. 오랜시간 걸쳐 같은 블록을 여러번 방문하는 Nested Loop 형태의 조인문 또는 인덱스를 경유한 테이블 액세스를 수반하는 프로그램이 있는지 체크하고 이를 회피할 수 있는 방법을 찾음
  6. 소트 부하를 감수하더라도 order by 등을 강제로 삽입해 소트 연산이 발생하도록 함
  7. 대량 업데이트 후에 곧바로 해당 테이블 또는 인덱스를 Full scan 하도록 쿼리를 수행하는 것도 하나의 해결방안이 될 수 잇음
```
select /*+ full(t) */ count(*) from table_name t
select count(*) from table_name where index_column > 0
```