## 4. 데이터 모델링의 3단계 진행
- 캐시 최적화와 데이터 베이스 Call 최소화를 통한 성능 개선 방법을 알아보았음
- 본 절에는 데이터베이스 I/O 효율화 및 버퍼 캐시 최적화 방법을 이해하는데 필요한 개념과 원리를 소개함
- 데이터베이스 I/O 튜닝을 위해서는 인덱스 조인 옵티마이저 원리, 소트 원리 등에 종합적인 이해가 필요한데, 자세한 내용은 3~5장 다룸

## 4-1 블록단위 I/O
- Oracle을 포함한 모든 DBMS에서는 I/O는 블록단위로 이루어진다.
- 즉 하나의 레코드를 읽더라도 레코드가 속한 블록 전체를 읽음
- SQL 성능을 좌우하는 가장 중요한 성능지표는 액세스하는 블록 개수이며, 옵티마이저의 판단에 가장 큰 영향을 미치는 것도 액세스 해야 할 블록 개수임
- 블록 단위 I/O는 버퍼 캐시와 데이터 파일 I/O모두에 적용됨
  - 데이터 파일에서 DB 버퍼 캐시로 블록을 적재할 때
  - 데이터 파일에서 블록을 직접 읽고 쓸때
  - 버퍼 캐시에서 블록을 읽고 쓸떄
  - 버퍼 캐시에서 변경된 블록을 다시 데이터 파일에 쓸 때

## 4-2 메모리 I/O vs 디스크 I/O

### I/O 효율화 튜닝의 중요성
- 디스크를 경유한 데이터 입출력은 디스크의 액세스 암이 움직이면서 헤드를 통해 데이터를 읽고 쓰기 때문에 느린 반면, 메모리를 통한 입출력은 전기적 신호에 불과하기 때문에 디스크를 통한 I/O에 비해 비교할수 없을 정도로 빠름
- 모든 DBMS는 읽고자 하는 블록을 먼저 버퍼 캐시에서 찾아보고 없을 경우에만 디스크에서 읽어 버퍼 캐시에 적재한 후 읽기/쓰기 작업을 수행함
- 물리적인 디스크 I/O가 필요할 때면 시스템에 I/O call을 하고 잠시 대기 상태에 빠짐
- 디스크 I/O 경합이 심할수록 대기 시간도 길어짐
- 모든 데이터를 메모리에 올려 놓고 사용할 수 있다면 좋겠지만 비용과 기술 측면에 한계가 있음
- 메모리는 물리적으로 한정된 자원이므로 결국 디스크 I/O를 최소화하고 버퍼 캐시 효율을 높이는 것이 데이터 베이스 I/O튜닝의 목표가 됨

### 버퍼 캐시 히트율(Buffer Cache Hit)
- 버퍼 캐시 효율을 측정하는 지표로, 전체 읽은 블록 중 메모리 버퍼 캐시에서 찾은 비율을 나타냄
- 즉 버퍼 캐시 히트율은 물리적인 디스크 읽기를 수반하지 않고 곧바로 메모리 블록을 찾은 비율을 말함
- Direct Path Read 방식 이외의 모든 블록 읽기는 버퍼 캐시를 통해 이뤄짐
- 읽고자 하는 블록을 먼저 버퍼 캐시에서 찾아보고 없을 때만 디스크로부터 버퍼 캐시에 적재한 후 읽어드림
```
BCHR = (버퍼 캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록 수) * 100
```
- BCHR은 주로 시스템 전체적인 관점에서 측정하지만, 개별 SQL 측면에서 구해볼 수도 있는데, 이 비율이 낮은 것은 SQL 성능을 떨어뜨리는 주 원인이라고 할 수 있음
- 모든 블록 읽기는 버퍼 캐시를 경유하여 디스크 I/O가 수반되더라도 먼저 버퍼 캐시에 적재한 후 읽는다고 함
- 총 읽은 블록 수가 디스크로부터 읽은 블록 수를 이미 포함하므로, 총 읽은 블록 수를 840개(Disk+Query+Current)로 잘못 해석하지 않도록 주의하기 바람
- 논리적인 블록 요청 횟수를 줄이고, 물리적으로 디스크에서 읽어야 . 할블록 수를 줄이는 것이 I/O 효율화 튜닝이 핵심 원리임
- 같은 블록을 반복적으로 액세스하는 형태의 SQL은 논리적인 I/O 요청이 비효율적으로 많이 발생함에도 불구, BCHR은 매우 높게 나타남
- 이는 BCHR이 성능지표로서 갖는 한계점이라 할 수 있음
- 예를 들어 NL Join은 작은 Inner 테이블을 반복적으로 룩업하는 경우가 그렇음
- 작은 테이블을 반복 액세스한다면 모든 블록이 메모리에서 찾아져 BCHR은 높겠지만, 일량이 작지 않고 블록을 찾는 과정에서 래치 경합과 버퍼 경합까지 발생한다면 메모리 I/O 비용이 디스크 I/O 비용보다 커질 수 있음
- 따라서 논리적으로 읽어야 할 블록 수의 절대량이 많다면 반드시 튜닝을 통해 논리적인 블록 읽기를 최소화 해야 함

### 네트워크, 파일시스템 캐시가 I/O 효율에 미치는 영향
- 대용량 데이터를 읽고 쓰는 데 다양한 네트워크 기술(DB 서버와 스토리지간 NAS 서버나 SAN을 사용)이 사용됨에 따라 네트워크 속도도 SQL성능에 크게 영향을 미치고 있음
- 이에 하드웨어나 DBMS 벤더는 네트워크를 통한 데이터 전송속도를 향상시키려고 노력하고 있지만, 네트워크 전송량이 많을 수 밖에 없도록 SQL을 작성한다면 결코 좋은 성능을 기대할 수 없다.
- 따라서 SQL을 작성할 때는 다양한 I/O 튜닝 기법을 사용해서 네트워크 전송량을 줄이려고 노력하는 것도 중요함
- RAC같은 클러스터링 데이터베이스 환경에선 인스턴스 간 캐시된 블록을 공유하므로 메모리 I/O 성능에도 네트워크 속도가 지대햔 영향을 미치게 됨
- 같은양의 디스크 I/O가 발생하더라도 I/O 대기 시간이 크게 차이 날 때가 있음
- 디스크 경합 때문일 수도 있고, OS에서 지원하는 파일 시스템 버퍼 캐시와 SAN 캐시 때문일 수 있음
- SAN 캐시는 크다고 문제될 것이 없지만, 파일 시스템 버퍼 캐시는 최소화 해야 함
- 데이터 베이스 자체적으로 캐시 영역을 갖고 있으므로 이를 위한 공간을 크게 할당하는 것이 더 효과적.
- 네트워크 문제든, 파일 시스템 문제든 I/O 성능에 관한 가장 확실하고 근본적인 해결책은 논리적인 블록 요청 횟수를 최소화하는 것

## 3. Sequential I/O vs, Random I/O
- Sequential 액세스는 레코드간 논리적 또는 물리적인 순서를 따라 차례대로 읽어 나가는 방식임
- 인덱스 리프 블록에 위치한 모든 레코드는 포인터를 따라 논리적으로 연결돼 있고, 이 포인터를 따라 스캔하는 것
- Sequential 액세스 방식임
- 테이블 레코드 간에는 포인터로 연결되지 않지만, 테이블을 스캔할 때는 물리적으로 저장된 순서대로 읽어 나가므로 이것 또한 Sequential 액세스 방식임
- Random 액세스는 레코드간 논리적, 물리적인 순서를 따르지 않고, 한 건을 읽기 위해 한 블록 씩 접근하는 방식을 말함
- 블록단위 I/O를 하더라도 한번 액세스할 때 Sequential 방식으로 그 안에 저장된 모든 레코드를 읽는다면 비효율은 없음
- 반면, 하나의 레코드를 읽으려고 한 블록 씩 Random 액세스 한다면 매우 비효율적이라고 할 수 있음
- 여기서 I/O 튜닝의 핵심 원리 두 가지를 발견할 수 있음
  - Sequential 액세스에 의한 선택 비중을 높임
  - Random 액세스 발생량을 줄임

### Sequential 액세스에 의한 선택 비중 높이기
- Seqential 액세스 효율성을 높이려면, 읽은 총 건수 중에서 결과집합으로 선택되는 비중을 높여야 함
- 즉 같은 결과를 얻기 위해 얼마나 적은 레코드를 읽느냐로 효율성을 판단할 수 있음
- 위 SQL 에서 참조하는 칼럼이 모두 인덱스에 있으므로 인덱스만 스캔하고 결과를 구할 수 있음
- 하지만 1개의 레코드를 읽기 위해 76개의 블록을 읽어야한다
- 테이블 뿐 아니라 인덱스를 Sequential 액세스 방식으로 스캔할 때도 비효율이 나타날 . 수있고, 조건절에 사용된 칼럼과 연산자 형태 인덱스 구성에 의해 효율성이 결정됨
- 루프와 리프, 단 2개의 인덱스 블록만 읽음
- 한 건을 얻으려고 읽은 건수도 한 건일 것이므로 가장 효율적인 방식으로 Sequential 액세스를 수행했다.

### Random 액세스 발생량 낮추기
- Random 액세스 발생량을 낮추는 방법을 살펴본다.
- 인덱스에 속하지 않는 칼럼을 참조하도록 쿼리를 변경함으로써 테이블 액세스가 발생하도록 할 것임
- 인덱스로부터 조건을 만족하는 22934건을 읽어 그 횟수만큼 테이블을 Random 액세스함
- 최종적으로 한 건이 선택된 것에 비해 너무 많은 Random 액세스가 발생한다.
- 인덱스로부터 1건을 출력했으므로 테이블을 1번 방문한다.
- 실제 발생한 테이블 Random 액세스도 1(=4-3)번임.
- 같은 쿼리를 수행했는데, 인덱스 구성이 바뀌자 테이블 Random 액세스가 대폭 감소한 것임
- 지금까지 테스트 결과가 쉽게 이해되지 않을 수 있음
- 만약 그렇다면, 세부적인 인덱스 튜닝 원리를 설명한 4장을 읽고서 다시 학습하기 바란다.

## Single Block I/O vs MultiBlock I/O
- Single Block I/O는 한번의 I/O Call에서 하나의 데이터 블록만 읽어 메모리에 적재하는 방식임
- 인덱스를 통해 테이블을 액세스할 때는, 기본적으로 인덱스와 테이블 블록 모두 이 방식을 사용함
- MultiBlock I/O는 I/O Call이 필요한 시점에, 인접한 블록들을 같이 읽어 메모리에 적재하는 방식임
- Table Full Scan 처럼 물리적으로 저장된 순서에 따라 읽을 때는 인접한 블록들을 같이 읽는 것이 유리
- 인접한 블록 익스텐트 내에 속한 블록
- 달리 말하면, MultiBlock I/O 방식으로 읽더라도 익스텐트 범위를 넘어서까지 읽지는 않음
- 인덱스캔 시 Single Block I/O 방식이 효율적임
- 인덱스 블록간 논리적 순서(이중 연결 리스트 구조로 연결된 순서)는 데이터 파일에 저장된 물리적인 순서와 다르기 때문
- 물리적으로 한 익스텐트에 속한 블록들을 I/O Call 시점에 같이 메모리에 올렸는데, 그 블록들이 논리적 순서로는 한참 뒤쪽에 위치할 수 있음
- 그러면 그 블록들은 실제로 사용되지 못한 채 버퍼 상에서 밀려나는 일이 발생함
- 하나의 블록을 캐싱하려면 다른 블록을 밀어내야 하는데, 이런 현상이 자주 발생한다면 앞에서 소개한 버퍼 캐시 효율만 떨어뜨리게 됨
- 대량의 데이터를 MultiBlock I/O 방식으로 읽을 때 Single Block I/O 보다 성능상 유리한 이유는 I/O Call 발생 횟수를 줄여주기 때문임
- 똑같이 64개 블록을 디스크에서 읽었는데, I/O Call이 9번에 그침
- 위 테스트는 Oracle 9i에서 수행한 것
- Oracle 10g부터 Index Range Scan 또는 Index Scan 일 때도 Multiblock I/O 방식으로 읽는 경우가 있는데, 위처럼 테이블 액세스 없이 인덱스만 ㅇ릭고 처리할 떄가 그렇다
- 인덱스를 스캔하면서 테이블을 Random 액세스할 때는 9i 이전과 동일하게 테이블과 인덱스 블록 모두 Single Block I/O 방식으로 읽은 블록을 모두 single block I/O 방식으로 읽음
- Single block i/o방식으로 읽은 블록들은 LRU 리스트 상 MRU 쪽으로 위치하므로 한번 적재되면 버퍼 캐시에 비교적 오래 머뭄
- 반대로 MultiBlock I/O 방식으로 읽은 블록들은 LRU 리스트 상 LRU 쪽으로 연결되므로 적재된지 얼마 지나지 않아 1순위로 버퍼캐시에서 밀려남

## I/O 효율화 원리
- 논리적인 I/O 요청 횟수를 최소화하는 것이 I/O 효율화 튜닝이 핵심 원리임
- I/O 떄문에 시스템 성능이 낮게 측정될 때 하드웨어적인 방법을 통해 I/O 성능을 향상 시킬 수 있음
- 하지만 SQL 튜닝을 통해 I/O 발생 횟수 자체를 줄이는 것이 더 근본적이고 확실한 해결방안임
- 애플리케이션 측변에서의 I/O 효율화 원리는 다음과 같이 요약할 수 있음
  - 필요한 최소 블록만 읽도록 SQL 작성
  - 최적의 옵티마이징 팩터 제공
  - 필요하다면 옵티마이저 힌트를 사용해 최적의 액세스 경로로 유도

### 필요한 최소 블록만 읽도록 SQL 작성
- 데이터베이스 성능은 I/O 효율에 달렸고, 이를 달성하려면 동일한 데이터를 중복 액세스하지 않고, 필요 명령을 사용자는 최소 일량을 요구하는 형태로 논리적인 집합을 정의하고, 효율적인 처리가 가능하도록 작성하는 것이 무엇보다 중요함
- 아래는 비효율적인 중복 액세스를 없애고 필요한 최소 블록만 액세스하도록 튜닝한 사례임

### 최적의 옵티마이징 팩터 제공
- 옵티마이저가 블록 액세스를 최소화하면서 효율적으로 처리할 수 있도록 하려면 최적의 옵티마이징 팩터를 제공해 줘야 함
- 전략적인 인덱스 구성
  - 전략적인 인덱스 구성은 가장 기본적인 옵티마이징 팩터임
- DBMS가 제공하는 기능 활용
  - 인덱스 외에도 DBMS가 제공하는 다양한 기능을 적극적으로 활용함
  - 인덱스 파티션 클러스터 윈도우 함수 등 적극 활용해 옵티마이저가 최적의 선택을 할 수 있도록 함
- 옵티마이저 모드 설정
  - 옵티마이저 모드 (전체 처리속도 최적화, 최초 응답속도 최적화) 와 그 외 옵티마이저 행동에 영향을 미치는 일부 파라미터를 변경해 주는 것이 도움이 될 수 있음
- 통계정보
  - 옵티마이저에게 정확한 정보를 제공함


### 필요하다면, 옵티마이저 힌트를 사용해 최적의 액세스 경로로 유도
- 최적의 옵티마이징 팩터를 제공한다면 가급적 옵티마이저 판단에 맡기는 것이 바람직하지만 옵티마이저가 생각만큼 최적의 실행계획을 수립하지 못하는 경우가 종종 있음
- 그럴 때는 어쩔 수 없이 힌트를 사용해야 함
- 아래는 옵티마이저 힌트를 이용해 실행 계획을 제어하는 방법을 예시하고 있음
- 옵티마이저 힌트를 사용할 때는 의도한 실행계획으로 수행되는지 반드시 확인해야 함
- CBO 기술이 고도로 발전하고 있긴 하지만 여러 가지 이유로 옵티마이저 힌트의 사용은 불가피함
- 따라서 데이터베이스 애플리케이션 개발자라면 인덱스, 조인, 옵티마이저의 기본 원리를 이해하고 그것을 바탕으로 최적화 액세스 경로로 유도할 수 있는 능력을 필수적으로 갖추어야 함