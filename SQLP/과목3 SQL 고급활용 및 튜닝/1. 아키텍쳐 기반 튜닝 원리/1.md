## 1. 아키텍쳐 개관

### 모델링의 정의
- DBMS마다 데이터베이스에 대한 정의가 조금씩 다른데, Oracle에서는 디스크에 저장된 데이터 집합을 데이터베이스라고 부름
- 그리고 SGA 공유메모리 영역과 이를 액세스하는 프로세스 집합을 합쳐서 인스턴스라고 함
- 기본적으로 하나의 인스턴스가 하나의 데이터베이스만 액세스하지만 RAC(Real application cluster)환경에서는 여러 인스턴스가 하나의 데이터베이스를 액세스할 수 있음
- 하나의 인스턴스가 여러 데이터베이스를 액세스할 수 없음

### SQL Server 아키텍쳐
- SQL Server 아키텍쳐를 간단히 표현하자면 Server는 하나의 인스턴스당 최고 32767개의 데이터베이스를 정의해 사용할 수 있음
- 기본적으로 master model msdb tempdb등의 시스템 데이터베이스가 만들어지며 여기에 사용자 데이터베이스를 추가로 생성하는 구조
- 데이터베이스 하나를 만들 때마다 주(Primary 또는 main) 데이터 파일과 트랜잭션 로그 파일이 하나씩 생기는데 전자는 확장자가 mdf이고 후자는 idf임
- 저장할 데이터가 많으면 보조 데이터 파일을 추가할 수 있으며 확장자는 ndf임

## 2. 프로세스
- SQL Server는 스레드 기반 아키텍쳐 이므로 프로세스 대신 쓰레드라는 표현을 써야함
- SQL Server 뿐만 아니라 Oracle도 Windows 버전에선 쓰레드를 사용하지만 프로세스와 일일이 구분하면서 설명하려면 복잡해 지므로 특별히 쓰레드를 언급해야 할 경우가 아니라면 간단히 프로세스로 통칭 하기로 함
- 잠시 후 표로써 정리해보겠지만 주요 스레드의 역할은 Oracle 프로세스와 크게 다르지 않음
- 프로세스는 서버 프로세스와 백그라운드 프로세스 집합으로 나뉨
- 서버 프로세스는 전면에 나서 사용자가 던지는 각종 명령을 처리하고 백그라운드 프로세스는 뒤에서 묵묵히 주어진 역할을 수행함

### 서버 프로세스
- 서버 프로세스는 사용자 프로세스와 통신하면서 사용자의 각종 명령을 처리하며, SQL Server에선 Worker 쓰레드가 같은 역할을 담당
- 좀 더 구체적으로 말해, SQL를 파싱하고 필요하면 최적화를 수행하며, 커서를 열어 SQL을 실행하면서 블록을 읽고, 읽은 데이터를 정렬해서 클라이언트가 요청한 결과집합을 만들어 네트워크를 통해 전송하는 일련의 작업을 모두 서버 프로세스가 처리해줌
- 스스로 처리하도록 구현되지 않은 기능, 이를테면 데이터 파일로부터 DB 버퍼 캐시로 블록을 적재하거나 Dirty 블록을 캐시에서 밀어냄으로 Free 블록을 확보하는 일, 그리고 Redo 로그 버퍼를 비우는 일 등은 OS, I/O 서브시스템, 백그라운드 프로세스가 대신처리하도록 시스템 Call을 통해 요청함
- 클라이언트가 서버 프로세스와 연결하는 방식은 DBMS마다 다르지만 Oracle을 예로 들면 전용 서버 방식과 공유서버 방식, 두가지가 존재

#### 1. 전용서버 방식
- 순서
  - 1. 사용자가 Listener에 연결요청
  - 2. 리스너는 프로세스 생성 및 연결요청 상속
  - 3. 서버는 Resend 패킷 전송
  - 4. 연결 후 작업 요청
  - 5. 처리 후 결과 전송
- 처음 연결 요청을 받는 리스너가 서버 프로세스를 생성해주고, 이 서버 프로세스가 단 하나의 사용자 프로세스를 위해 전용(Declicated) 서비스르 지공한다는 점이 특징
- 만약 SQL을 수행할 때마다 연결 요청을 반복하면 서버 프로세스의 생성과 해제도 반복하게 되므로 DBMS에 매우  큰 부담을 주고 성능을 크게 떨어뜨려버림
- 따라서 전용 서버 방식을 사용하는 OLTP성 애플리케이션에선 Connection Pooling기법을 필수적으로 사용해야 함
- 예를들어 50개의 서버 프로세스와 연결된 50개의 사용자 프로세스를 공유해서 반복 재사용하는 방식

#### 2. 공유서버 방식
- 공유서버는 말 그대로 하나의 서버 프로세스를 여러 사용자 세션이 공유하는 방식으로 앞서 설명한 Connection Pooling 기법을 DBMS 내부에 구현해놓은 것으로 생각하면 쉬움
- 즉, 미리 여러개의 서버 프로세스를 띄워 놓고 이를 공유해서 반복 재사용한다
- 공유 서버 방식으로 Oracle에 접속하면 사용자 프로세스는 서버 프로세스와 직접 통신하지 않고 Dispatcher 프로세스를 거침
- 사용자 명령이 Dispatcher에게 전달되면 Dispatcher는 이를 SGA에 있는 요청 큐에 등록함
- 이후 가장 먼저 가용해진 서버 프로세스가 요청 큐에 있는 사용자 명령을 꺼내서 처리하고 그 결과를 응답 큐에 등록함
- 응답 큐를 모니털이하던 Dispatcher가 응답 결과를 발견하면 서용자 프로세스에게 전송해 줌

### 백그라운드 프로세스

|Oracle|SQL Server|설명|
|--|--|--|
|System Monitor </br> (SMON)|Database CleanUp</br> Shrinking thread|장애가 발생한 시스템을 재기동할 때 인스턴스 복구를 수행하고, 임시 세그먼트와 익스텐트를 모니터링|
|Process Monitor </br>(PMON)|Open Data Services(OPS)|이상이 생긴 프로세스가 사용하던 리소스를 복구한다
|Database Writer(DBWn)|Lazywriter thread|버퍼 캐시에 있는 Dirty 버퍼를 데이터 파일에 기록함|
|Log Writer(LGWR)|Log writer thread|버퍼 캐시에 있는 Dirty 버퍼를 데이터 파일에 기록|
|Archiver(ARCn)|N/A|꽉 찬 Redo 로그가 덮어 쓰여지기 전에 Archive 로그 디렉토리로 백업|
|Checkpoint(CKPT)|Database Checkpoint thread|Checkpoint 프로세스는 이전에 CheckPoint가 일어났던 마지막 시점 이후의 데이터베이스 변경 사항을 데이터 파일에 기록하도록 트리거링하고, 기록이 완료되면 현재 어디까지 기록했는지를 컨트롤 파일과 데이터 파일 헤더에 저장함 <br> 좀 더 자세히 설명하면 Write Ahead Logging 방식(데이터 변경 전에 로그부터 남기는 메커니즘)을 사용하는 DBMS는 Redo 로그에 기록해 둔 버퍼 블록에 대한 변경 사항 중 현재 어디까지를 데이터 파일에 기록했는지 체크포인트 정보를 관리해야 함. <br> 이는 버퍼 캐시와 데이터 파일이 동기화된 시점을 가리키며, 장애가 발생하면 마지막 체크포인트 이후 로그 데이터만 디스크에 기록함으로 인스턴스를 복구할 수 있도록 한느 용도로 사용됨 <br> 이 정보를 갱신하는 주기가 길수록 장애 발생 시 인스턴스 복구 시간도 길어짐
|Recoverer(RECO)|Distributed Transaction Coordinator(DTC)|분산 트랜잭션 과정에 발생한 문제를 해결함|

## 3. 파일구조

### 데이터 파일
- Oracle과 SQL Server 모두 물리적으로는 데이터 파일에 데이털르 저장하고 관리함
- 공간을 할당하고 관리하기 위한 논리적인 구조도 크게 다르지 않지만 약간의 차이는 있음

#### 블록(=페이지)
- 대부분 DBMS에서 I/O는 블록 단위로 이루어짐
- 데이터를 읽고 쓸 때의 논리적인 단위가 블록인 것
- Oracle은 블록이라고 하고, SQL Server는 페이지라고 함
- Oracle은 2KB 4KB 8KB 16KB 32KB 64KB의 다양한 블록 크기를 사용할 수 있지만, SQL Server에서는 8KB 단일 크기를 사용
- 블록 단위로 I/O한다는 것은 하나의 레코드에서 하나의 칼럼만을 읽으려 할 때도 레코드가 속한 블록 전체를 읽게 됨을 뜻함
- SQL 성능을 좌우하는 가장 중요한 성능지표로 액세스하는 블록 개수이며 옵티마이저의 판단에 가장 큰 영향을 미치는 것도 액세스해야 할 블록 개수임
- 옵티마이저의 판단에 가장 큰 영향을 미치는 것도 액세스해야 할 블록 개수
- 예를 들어 옵티마이저가 인덱스를 이용해 테이블을 액세스할지 아니면 Full Table Scan할지를 결정하는 데 있어 가장 중요한 판단 기준은 읽어야 할 레코드 수가 아니라 읽어야 하는 블록 개수

#### 익스텐트
- 데이터를 읽고 쓰는 단위는 블록이지만, 테이블 스페이스로부터 공간을 할당하는 단위는 익스텐트임
- 테이블이나 인덱스에 데이터를 입력하다가 공간이 부족해지면 해당 오브젝트가 속한 테이블 스페이스(물리적으로는 데이터 파일)로부터 추가적인 공간을 할당받는데, 이때 정해진 익스텐트 크기의 연속된 블록을 할당받음
- 예를 들어 블록 크기가 8KB인 상태에서 64KB단위로 익스텐트를 할당하도록 정의 한다면, 공간이 부족할 때마다 테이블 스페이스로부터 8개의 연속된 블록을 찾아(찾지 못하면 새로 생성) 세그먼트에 할당해줌
- 익스텐트 내 블록은 논리적으로 인접하지만, 익스텐트끼리는 서로 인접하지 않음
- 예를 들어, 어떤 세그먼트에 익스텐트 2개가 할당되는데, 데이터 파일 내에서 이 둘이 서로 멀리 떨어져 있을 수 있음
- 참고로 Oracle은 다양한 크기의 익스텐트를 사용하지만, SQL Server에선 8개 페이지의 익스텐트만 사용한다.
- 페이지 크기도 8KB로 고정이므로 익스텐트는 항상 64KB인 셈임
- 또한 Oracle은 한 익스텐트에 속한 모든 블록을 단일 오브젝트가 사용하지만, SQL Server에서는 2개 이상의 오브젝트가 나누어 사용할 수도 있음
- SQL Server는 다음 2가지 타입의 익스텐트를 사용함
  - 균일 익스텐트
    - 64KB 이상의 공간을 필요로 하는 테이블이나 인덱스를 위해 사용되며, 8개 페이지 단위로 할당된 익스텐트를 단일 오브젝트가 모두 사용됨
  - 혼합(Mixed) 익스텐트
    - 한 익스텐트에서 할당된 8개 페이지를 여러 오브젝트가 나누어 사용하는 형태임
    - 모든 테이블이 처음에는 혼합 익스텐트로 시작하지만 64kb를 넘으면서 2번째부터 균일 익스텐트를 사용함

#### 세그먼트
- SQL Server에서는 세그먼트라는 용어를 사용하지 않지만, 힙 구조 또는 인덱스 구조의 오브젝트가 여기에 속함
- 세그먼트는 테이블 인덱스 Undo처럼 저장공간을 필요로 하는 데이터베이스 오브젝트임
- 저장 공간을 필요로 한다는 것은 한 개 이상의 익스텐트를 사용함을 뜻함
- 테이블을 생성할 때 내부적으로는 테이블 세그먼트가 생성됨
- 인덱스를 생성할 떄 내부적으로 인덱스 세그먼트가 생성됨
- 달느 오브젝트는 세그먼트와 1:1 대응 관계를 갖지만 파티션은 1:M 관계를 가짐
- 즉 파티션 테이블을 만들면, 내부적으로 여러개의 세그먼트가 만들어짐
- 한 세그먼트는 자신이 속한 테이블 스페이스 내 여러 데이터 파일에 걸쳐 저장될 수 있음
- 즉 세그먼트에 할당된 익스텐트가 여러 데이터 파일이 흩어져 저장되는 것이며, 그래야 디스크 경합을 줄이고 I/O 분산 효과를 얻을 수 있음

#### 테이블 스페이스
- 테이블 스페이스는 세그먼트를 담는 콘테이너임
- 여러 데이터 파일로 구성됨, SQL Server의 파이르 그룹이 Oracle 테이블 스페이스에 해당됨
- 데이터는 물리적으로 데이터 파일에 저장되지만, 사용자가 데이터파일을 직접 선택하진 않음
- 사용자는 세그먼트를 위한 테이블 스페이스를 저장할 뿐 실제 값을 저장할 데이터 파일을 선택하고 익스텐트를 할당하는 것은 DBMS의 몫임
- 각 세그먼트는 정확히 한 테이블 스페이스에만 속하지만, 한 테이블 스페이스에는 여러 테이블 스페이스에 걸쳐 저장될 수 없다는 것
- 하지만 앞서 얘기했듯이 한 세그먼트가 여러 데이터 파일에 걸쳐 저장될 수는 있음
- 한 테이블 스페이스가 여러 데이터 파일에 걸쳐 저장될 수는 있음
- 한 테이블 스페이스가 여러 데이터 파일로 구성되기 때문임
- 지금까지 설명한 내용을 요약하면 다음과 같음

<img src="../img/1/1.png" width = "200" height = "400">

### 임시 데이터 파일
- 임시 데이터 파일으 특별한 용도로 사용됨
- 대량의 정렬이나 해시 작업을 수행하다가, 메모리 공간이 부족해지면 중간 결과 집합을 저장하는 용도
- 임시 데이터 파일에 저장되는 오브젝트는 말 그디로 임시로 저장하다 자동으로 삭제됨
- Redo 정보를 생서하지 않기 때문에 나중에 파일에 문제가 생겼을때 복구되지 않음
- 따라서 백업할 필요도 없음
- Oracle에선 임시 테이블 스페이스를 여러개 생성해두고, 사용자마다 별도의 임시 테이블 스페이스를 지정해줄 수 있음

```
create temporary tablespace big_temp tempfile '/usr/local/oracle/oradata/ora10g/big_temp.dbf' size 2000m;
alter user scott temporary tablespace big_temp;
```
- SQL Server는 단 하나의 tempdb 데이터베이스를 사용함,tempdb는 전역 리소스로서 시스템에 연결된 모든 사용자의 임시 데이터를 여기에 저장함.

### 로그 파일
- DB버퍼 캐시에 가해지는 모든 변경사항을 기록하는 파일을 Oracle은 Redo로그라고 부름, SQL Server에서는 트랜잭션 로그라고 부름
- 변경된 매모리 버퍼 블록을 디스크 사으이 데이터 블록에 기록하는 작업은 Random I/O 방식으로 이루어지기 때문에 느림
- 반면 로그 기록은 append 방식으로 이루어지기 때문에 상대적으로 매우 빠름
- 따라서 대부분 DBMS는 버퍼 블록에 대한 변경사항을 건건이 데이터 파일에 기록하기 보다 우선 로그 파일에 Append 방식으로 빠르게 기록하는 방식을 사용함.
- 그러고 나서 버퍼 블록과 데이터 파일 간 동기화는 적절한 수단을 이용해 나중에 배치. 방식으로 일괄 처리함
- 사용자의 갱신 내용이 메모리상의 버퍼 블록에만 기록된 . 채아직 디스크에 기록되지 않더라도, Redo 로그를 믿고 빠르게 커밋을 완료한다는 의미에서 이를 'Fast Commit'
- 인스턴스 장애가 발생하더라도 로그 파일을 이용해 언제든 복구 가능하므로 안심하고 커밋을 완료할 수 있는 것
- Fast commit 은 빠르게 트랜잭션을 처리해야 하는 모든 DBMS의 공통적인 메카니즘임

#### Online Redo 로그
- 캐시에 저장된 변경 사항이 아직 데이터 파일에 기록되지 않은 상태에서 정전 등으로 인스턴스가 비정상 종료이면, 그떄 까지의 작업 내용을 모두 잃게 됨
- 이러한 트랜잭션 데이터의 유실을 대비하기 위해 Oracle은 Online Redo 로그를 사용함
- 마지막 체크포인트 이후부터 사고 발생 직전까지 수행되었던 트랜잭션들을 Redo 로그를 이용해 재현하는 것이며, 이를 캐시 복구라고 함
- Online Redo 로그는 최소 두개 이상의 파일로 구성됨
- 현재 사용중인 파일이 꽉 차면 다음 파일로 로그 스위칭(log switching)이 발생하며, 계속 로그를 써 나가다가 모든 파일이 꽉 차면 다시 첫 번쨰 파일 ㅂ터 재사용하는 라운드 로빈 방식을 사용함

#### 트랜잭션 로그
- 트랜잭션 로그는 Oracle의 Online Redo 로그와 대응되는 SQL Server의 로그 파일임
- 주 데이터 파일임
- 즉 데이터베이스마다 트랜잭션 로그 파일이 하나씩 생기며 확장자는 Id임
- 트랜잭션 로그 파일은 내부적으로 '가상 로그 파일'이라 불리는 더 작은 단위의 세그먼트로 나뉘며, 이 기상 로그 파일의 갯수가 너무 많아지지 않도록(즉 조각화가 발생하지 않도록) 옵션을 지정하는게 좋음
- 예를 들어 로그 파일을 애초에 넉넉한 크기로 만들어 자동 증가가 발생하지 않도록 하거나, 어쩔 수 없이 자동 증가한다면 증가하는 단위를 크게 지정하는 것

#### Archived(Offline)Redo 로그
- Archived Redo로그는 Oracle에서 Online Redo 로그가 재사용 되기 전에 다른 위치로 백업해 둔 파일을 말함
- 디스크가 깨지는 등 물리적인 저장 매체에 문제가 생겼을 때 데이터베이스(또는 미디어) 복구를 위해 사용됨
- 참고로 SQL Server에는 Archived Redo 로그에 대응되는 개념이 없음


## 4. 메모리 구조
- 메모리 구조는 시스템 공유 메모리 영역과 프로세스 전용 메모리 영역으로 구분됨
- 지금부터 시스템 공유 메모리 영역의 구성 요소인 DB 버퍼 캐시, 공유 풀, 로그 버펄르 순서대로 살펴보고 마지막으로 프로세스 전용 메모리 영역인 Process Global Area를 살핀다.

#### 시스템 공유 메모리 영역
- 시스템 공유 메모리라는 말은 . 말그대로 여러 프로세스(또는 스레드)가 동시에 액세스할 수 있는 메모리 영역으로서, Oracle에서는 'System Global Area(SGA)', SQL Server에서는 'Memory Pool'이라고 부름
- 공유 메모리를 구성하는 캐시 영역은 그 외에 Large 풀(Large Pool), 자바 풀(Java Pool) 등을 포함하고, 시스템 구조와 제어 구조를 캐싱하는 영역도 포함함
- 시스템 공유 메모리 영역은 여러 프로세스에 공유되기 때문에, 내부적으로 래치 버퍼 Lock 라이브러리 캐시 Lock/Pin 같은 액세스 직렬화 메커니즘이 사용됨

#### 프로세스 전용 메모리 영역
- Oracle은 프로세스 기반 아키텍쳐 이므로 서버 프로세스가 자신만의 전용 메모리 영역을 가질 수 있는데 이를 Process Global  Area(PGA)
- 데이터를 정렬하고 세션과 커서에 관한 상태 정보를 저장하는 용도로 사용함
- 쓰레드 기반 아키텍쳐를 사용하는 SQL Server는 프로세스 전용 메모리 영역을 갖지 않음
- 쓰레드는 전용 메모리 영역을 가질 수 없고, 부모 프로세스의 메모리 영역을 사용하기 떄문
- 참고로 Windows 버전 Oracle도 쓰레드를 사용하지만, 프로세스 기반의 Unix 버전과 같은 인터페이스를 제공하고 구조에 대한 개념과 설명도 구별하지 않음

### DB 버퍼 캐시
- DB 버퍼 캐시는 데이터 파일로부터 읽어 드린 데이터 블록을 담는 캐시 영역
- 인스턴스에 접속한 모든 사용자 프로세스는 서버 프로세스를 통해 DB 버퍼 캐시의 버퍼 블록을 동시에 (내부적으로는 버퍼 Lock을 통해 직렬화) 해서 엑세스 할 수 있음
- 일부 Direct Path Read 메커니즘이 작동하는 경우를 제외하면 모든 블록 읽기는 버퍼 캐시를 통해 이루어짐
- 즉 읽고자 하는 블록을 먼저 버퍼 캐시에서 찾아보고 없을 때 디스크에서 읽음
- 디스크에서 읽을 때도 먼저 버퍼 캐시에 적재한 후에 읽음
- 데이터 변경도 버퍼 캐시에 적재된 블록을 통해 이루어지며, 변경된 블록(Dirty 버퍼 블록)을 주기적으로 데이터 파일에 기록하는 작업은 DBWR 프로세스의 몫임
- 디스트 I/O 는 물리적으로 액세스 암(Arm)이 움직이면서 헤드를 통해 이루어지는 방면, 메모리 I/O는 전기적 신호에 불과하기 떄문에 디스크 I/O에 비교할 수 없을 정도로 빠름
- 디스크에 읽은 데이터 블록을 메모리 상에 보관해 두는 기능이 모든 데이터베이스 시스템에 필수적인 이유임

#### 버퍼 블록의 상태
- 모든 버퍼 블록은 아래 세가지 중 하나의 상태에 놓임
- Free 버퍼
  - 인스턴스 기동 후 아직 데이터가 읽히지 않아 비어있는(Clean 버퍼)이거나, 데이터가 담겼지만 데이터 파일과 서로 동기화 돼있는 상태여서 언제든지 덮어 써도 무방한 버퍼 블록을 말함
  - 데이터 파일로부터 새롤운 데이터 블록을 로딩하려면 먼저 Free 버퍼를 확보해야 함
  - Free 상태인 버퍼에 변경이 발생하면 그 순간 Dirty 버퍼로 상태가 바뀜
- Dirty 버퍼
  - 버퍼에 캐시된 이후 변경이 발생하지만, 아직 디스크에 기록되지 않아 데이터 파일 블록과 동기화가 필요한 버퍼 블록을 말함
  - 이 버퍼 블록들이 다른 데이터 블록을 위해 재사용되려면 디스크에 먼저 기록되어야 하며, 기록되는 순간 Free 버퍼로 상태가 바뀜

#### LRU 알고리즘
- 버퍼 캐시는 유한한 자원이므로 모든 데이터를 캐싱해 둘 수 없음
- 따라서 모든 DBMS는 사용 빈도가 높은 데이터 블록 위주로 버퍼 캐시가 구성되도록 LRU(Last Recently used)알고리즘을 사용
- 모든 버퍼 블록 헤더를 LRU 체인에 연결해 사용 빈도 순으로 위치를 옮겨 가다, Free 버퍼가 필요해질 때면 액세스 빈도가 낮은 쪽(LRU end) 데이터 블록부터 밀어내는 방식임
- 아래 사진과같은 컨베이어 벨트를 생가갛면 LRU 알고리즘을 쉽게 이해할 수 있음


<img src="../img/1/1.png" width = "200" height = "400">


### 공유 풀
- 공유 풀은 딕셔너리 캐시와 라이브러리 캐시로 구성되며, 버퍼 캐시처럼 LRU 알고리즘을 사용함
- SQL Server 에서 같은 역할을 하는 메모리 영역을 프로시저 캐시라고 함

#### 딕셔너리 캐시
- 데이터베이스 딕셔너리는 테이블, 인덱스 같은 오브젝트는 물론 테이블 스페이스 , 데이터 파일, 세그먼트, 익스텐트, 사용자, 제약에 관한 메타 정보를 저장하는 곳
- 그리고 딕셔너리 캐시라는 말은 . 말그대로 딕셔너리 정보를 캐싱하는 메모리 영역
- '주문' 테이블을 예로 들면 입력한 주문 데이터는 데이터 파일에 저장하다가 버퍼 캐시를 경유해 읽히지만, 테이블 매타 정보는 딕셔너리 저장하다가 딕셔너리 캐시를 경유해 읽힘

#### 라이브러리 캐시
- 라이브러리 캐시(Library Cache)는 사용자가 수행한 SQL문과 실행계획, 저장 프로세저를 저장해 두는 캐시 영역이다.
- 사용자가 SQL 명령어를 통해 결과집합을 요청하면 이를 최적으로 (->가장 적은 리소스를 사용하면서 가장 빠르게) 수행하기 위한 처리 Plan이 있음
- 빠른 쿼리 수행을 위해 내부적으로 생성한 읽종의 프로세저와 같은 것이라고 이해하기 쉬움
- 쿼리 구문을 분석해서  문법 오류 및 실행 권한 등을 체크하고 최적화 과정을 거쳐 실행계획을 만들고, SQL 실행 엔진이 이해할 수 이쓴ㄴ 형태로 포맷팅하는 전 과정을 하드파싱이라고 함
- 특히 최적화 과정은 하드 파싱을 무겁게 만드는 가장 결정적 요인인데, 같은 SQL을 처리하고 이런 무거운 작업을 반복 수행하는 것은 매우 비효율적임
- 그것을 해결하기 위한 캐시 공간을 따로 두게 되었고, 그것이 바로 라이브러리 캐시 영역임
- 캐싱된 SQL과 그 실행계획의 재사용성을 높이는 것은 SQL 수행 성능을 높이고 DBMS 부하를 최소화하는 핵심 원리 . 중하나임

### 로그 버퍼
- DB 버퍼 캐시에 가해지는 모든 변경사항을 로그 파일에 기록한다고 앞서 설명함
- 로그 엔트리도 파일에 곧바로 기록하는 것이 아니라, 먼저 로그 버퍼에 기록함
- 건건이 디스크에 기록하기 보다 일정량을 모았다가 기록하면 훨씬 빠르기 때문
- 좀 더 자세히 설명하면 서버 프로세스가 데이터 블록 버퍼에 변경을 가하기 전에 Redo 로그 버퍼에 먼저 기록해 두면 주기적으로 LGWR 프로세스가 Redo 로그 파일에 기록함
- Oracle의 Redo 로그 Redo 로그 버퍼와 대비되는 개념이 SQL Server의 트랜잭션 로그, 로그 캐시임
- 변경이 가해진 Dirty 버퍼를 데이터 파일에 기록하기 전 항상 로그 버퍼를 먼저 로그 파일에 기록해야만 하는데 그 이유는 인스턴스 장애가 발생할 때면 로그 파일에 기록된 내용을 재현해 캐시 블록을 복구하고, 최종적으로 커밋되지 않은 트랜잭션은 롤백해야 하기 때문임
- 이때 로그 파일에는 없는 변경 내역이 이미 데이터 파일에 기록돼 있으면 사용자가 최종 커밋하지 않은 트랜잭션이 커밋되는 결과를 초래하기 때문이다.
- 정리해보면 버퍼 캐시 블록을 갱신하기 전에 변경사항을 먼저 로그 버퍼에 기록해야 하며, Dirty 버퍼를 디스크에 기록하기 전에 해당 로그 엔트리를 먼저 로그 파일에 기록해야 하는데, 이를 White Ahead Logging이라고 함
- 그리고 로그 버퍼를 주기적으로 로그 파일에 기록한다고 했는데 늦어도 커밋 시점에는 로그 파일에 기록해야 함(Log Force at commit)
- 메모리 상의 로그 버퍼는 언제든 유실될 가능성이 있기 때문
- 로그를 이용한 Fast Commit이 가능한 이유는 로그를 이용해 언제든 복구 가능하기 떄무닝라고 설명한 것을 상기하기 바람
- 다시 말하지만, 로그 파일에 기록했음이 보장돼야 안심하고 커밋을 완료할 수 있음
  
### PGA(Process Global Area)
- 각 Oracle 서버 프로세스는 자신만의 PGA(Process/Program/Private Global Area) 메모리 영역을 할당받고 이를 프로세스에 중속적인 공유 데이털르 저장하는 용도로 사용됨
- PGA는 다른 프로세스와 공유되지 않은 독립적인 메모리 공간으로서, 래치 메커니즘이 필요없어 똑같은 개수의 블록을 읽더라도 SGA 버퍼 캐시에서 읽는 것이 훨씬 빠름
- PGA 내에서 Sort Area가 할당되는 위치는 SQL 문 종류와 소트 수행 단계에 따라 다름.
- DML 문장은 하나의 Execute Call 내에서 모든 데이터 처리를 완료하였으므로 Sort Area는 UGA에 할당됨
- 앞에서 이미 설명한 것 처럼 쓰레드(Thread)기반 아키텍쳐를 사용하는 SQL Server는 프로세스 전용 메모리 영역을 갖지 않음
- 대신 데이터 정렬은 Memory Pool 안에 있는 버퍼 캐시에서 수행하며, 세션 관련 정보는 Memory Pool 안에 있는 Connection Context 영역에 저장됨

#### User Global Area(UGA)
- 전용 서버 방식으로 연결할 때는 프로세스와 세션이 1:1 관계를 갖지만, 공유 서버(Shared Server)방식으로 연결할 때는 1:M 관계를 갖는단
- 즉 세션이 프로세스 개수보다 많아질 수 있는 구조로, 하나의 프로세스가 여러개 세션을 위해 일함
- 따라서 . 각세션을 위한 독립적인 메모리 공간이 필요해지는데, 이를 UGA라고 함
- 전용 서버 방식이라과 해서 UGA를 사용하지 않는 것은 아님
- UGA는 전용 서버 방식으로 연결할 때는 PGA에 할당되고, 공유 서버 방식으로 연결할 때는 SGA에 할당됨
- 구체적으로 후자는 Large Pool이 설정됐을 때는 Large Pool에 그렇지 않을 때는 Shared Pool에 할당하는 방식임

#### Call Global Area(CGA)
- PGA에 해당하는 메모리 공간으로 CGA도 있음
- Oracle은 하나의 데이터베이스 Call을 넘어서 다음 Call 까지 계속 참조 되어야 하는 정보다 UGA에 담고, Call 이 진행되는 동안에만 데이터는 CGA에 담음
- CGA는 Parse Call, Execute Call, Fetch Call마다 매번 할당받음
- Call이 진행되는 동안 Recursive Call이 발생하면 그 안에서도 Parse Execute, Fetch 단계 별로 CGA가 추가로할당됨
- CGA에 할당된 공간은 하나의 Call이 끝나자 마자 해제되어 PGA로 반환됨

#### Sort Area
- 데이터 정렬을 위해 사용되는 Sort Area는 소트 오퍼레이션이 진행되는 동안 공간이 부족해질 때마다 청크(Chunk)단위로 조금씩 할당됨
- 세션마다 사용할 수 있는 최대 크기를 이전에는 sort_area_size 파라미터로 설정하였으나, 9I부터는 새로운 새로 생긴 workarea_size_policy 파라미터를 auto(기본 값)으로 설정하면 Oracle이 내부적으로 결정함


## 5. 대기 이벤트
- DBMS내부에서 활동하는 수 많은 프로세스 간에는 상호 작용이 필요
- 그 과정에서 다른 프로세스가 일을 마칠 때 까지 기다려야만 하는 상황이 자주 발생함
- 그 때마다 해당 프로세스는 자신이 일을 계속 진행할 수 있는 조건이 충족될 떄까지 수면 상태로 대기하는데 그 기간에 정해진 간격으로(1초 3초 등)각 대기 유형별 상태와 시간 정보가 공유 메모리 영역에 저장됨
- 대개 누적치만 저장되지만, 사용자가 원하면(10046 이벤트 트레이스를 활성화 하면)로그처럼 파일로 기록해 주기도 함
- 이러한 대기 정보를 Oracle 에서는 대기 이벤트라고 부름 SQL Server에서는 대기 유형(wait type)이라고 부름
- 대기 이벤트가 중요한 이유는, 1990년대 후반부터 이를 기반으로 한 Response Time Analysis 성능 관리 방법론이 데이터 베이스 성능 진단 분야에 일대 변혁을 가져왔기 때문
- 세션 또는 시스템 전체에 발생하는 병목 현상과 그 원인을 찾아 문제를 해결하는 방법과 과정을 다루는 이 방법론은 데이터 베이스 서버의  응답 시간을 서비스 시간과 대기 시간의 합으로 정의하고 있음

```
Response Time = Service Time + Wait Time = CPU Time + Queue Time
```
- 서비스 시간(Service Time) 은 프로세스가 정상적으로 동작하며 일을 수행한 시간을 말함
- CPU Time 과 같은 의미임
- 대기 시간(Wait Time)은 프로세스가 잠시 수행을 멈추고 대기한 시간을 말함
- 다른 말로 방법론은 Response Time을 위와 같이 정의하고, CPU Time과 Wait Time을 각각 break down하면서 서버의 일량과 대기. ㅣ간을 분석해 나감
- CPU Time은 파싱 작업에 소비한 시간인지 아니면 쿼리 본연의 오퍼레이션 수행을 위해 소비한 시간인지를 분석함
- Wait Time은 각각 발생한 대기 이벤트들을 분석해 가장 시간을 많이 소비한 이벤트 중심으로 해결 방안을 모색함
- Oracle 10g 기준으로 대기 이벤트 개수는 890여개에 이르는데, 그 중 가장 자주 발생하고 성능 문제와 직결되는 것들을 일부 소개한다
- 참고로 . 본단락은 oracle 중심으로만 설명하는데 SQL Server는 대기 유형이 잘 알려지지 않은 데다 아직 활용도가 낮은 편이기 때문
- 참고로 DB를 모니터링 하거나 성능 진단 업무를 담당하지 않는다면 아래 내용을 굳이 공부하지 않아도 됨
- 그럼에도 여기서 소개하는 이유는 DBMS 병목이 주로 어디서 발생하는지 그리고 어떤 이벤트로써 측정되는지를 간단하게나마 보여주기 위한 것이므로 부담없이 읽어 나가기 바람

### 라이브러리 캐시 부하

- 아래는 라이브러리 캐시에서 SQL 커서를 찾고 최적화 하는 과정에서 경합이 발생했음을 나타내는 대기 이벤트임
```
latch: shared pool
latch: library catch/li>
```

- 라이브러리 캐시와 관련해 자주 발생하는 대기 이벤트로는 아래 2가지가 있는데 이들은 수행중인 SQL이 참조하는 오브젝트에 다른 사용자가 DDL 문장을 수행할 때 나타남
```
library cache lock
library cache pin
```
- 라이브러리 캐시 관련 경합이 급증하면 심각한 동시성 저하를 초래하는데, 2절에서 이를 최소화하는 방안을 소개함

### 데이터베이스 Call과 네트워크 부하
- 아래 이벤트에 의해 소모된 시간은 애플리케이션과 네트워크 구간에서 소모된 시간으로 이해하면 됨
```
SQL *Net message from client
SQL *Net message to client
SQL *Net more data to client
SQL *Net more data from client

```
- SQL *Net message from client 이벤트는 사실 데이터베이스 경합과는 관련이 없음
- 클라이언트로부터 다음 명령이 올 때까지 Idle 상태로 기다릴 때 발생하기 때문
- 반면, 나머지 세개의 대기 이벤트는 실제 네트워크 부하가 원인일 수 있음
- SQL *Net message to client와 SQL *Net more data to client 이벤트는 클라이언트에게 메시지를 보냈는데 메시지를 잘 받았다는 신호가 정해진 시간보다 늦게 도착하는 경우에 나타나며 클라이언트가 너무 바쁜 경우일 수도 있음
- SQL *Net more data from client 이벤트는 클라이언트로부터 더 받을 데이터가 있는데 지연이 발생하는 경우임
- 이들 대기 이벤트를 해소하는 방안에 대해서는 3절에서 다룸

### 디스크 I/O 부하
- 아래는 모두 디스크 I/O가 발생할 때마다 나타나는 대기 이벤트임
```
db file sequential read
db file scattered read
direct path read
direct path write
direct path write temp
direct path read temp
db file parallel read
```
- 이들 중 특히 주목할 대기 이벤트는 db file sequential read와 db file scattered read임
- 전자는 Single Block I/O를 수행할 때 나타나는 대기 이벤트
- Single Block I/O는 말 그대로 한번의 I/O call 에 하나의 데이터 블록만 읽는 것을 말함
- 인덱스 블록을 읽을 때, 그리고 인덱스를 거쳐 테이블 블록을 액세스할 때 이 방식을 사용함
- 후자는 Muitiblock I/O를 수행할 때 나타나는 대기 이벤트임
- Multiblock I/O는 I/O Call이 필요한 시점에 인접한 블록들을 같이 읽어 메모리에 적재하는 것을 말함
- Table Full Scan 또는 Index Fast Full Scan 시 나타남
- 이들 대기 이벤트를 해소하는 방안에 대해서는 4절에서 다루며, 4장과 5장에서 더 자세히 다룸

### 버퍼 캐시 경합
- 아래는 버퍼 캐시에서 블록을 읽는 과정에 경합이 발생했음을 나타내는 대기 이벤트임
```
latch: cache buffers chains
latch: cache buffers lru chain
buffer busy waits
dfree buffer waits
```
- 버퍼 캐시에서 블록을 읽더라도 이들 대기 이벤트가 심하게 발생하는 순간 동시성은 현저히 저하되는데, 이들 대기 이벤트를 해소하는 방안도 디스크 I/O 부하 해소 방안과 다르지 않음
- 따라서 이들 경합의 해소 원리도 4절과 더불어 4장 5장에서 함께 다루게 됨

### Lock 관련 대기 이벤트
- 아래 enq로 시작되는 대기 이벤트는 Lock과 관련된 것으로서, 그 발생 원인과 해소 방안을 2장에서 일부 소개함
```
enq: TM - contrention
enq: TX - row lock contention
enq: TX - index contention
enq: TX - allocate ITL entry
enq: TX contention
latch free
```
- latch free는 특정 자원에 대한 래치를 여러 차례(2000 번 가량) 요청했지만 해당 자원이 계속 사용 중이어서 잠시 대기 상태로 빠질 때마다 발생하는 대기 이벤트임
- 래치(latch)는 우리가 흔히 말하는 Lock과 조금 다름
- Lock은 사용자 데이터를 보호하는 반면, 래치는 SGA에 공유돼 있는 갖가지 자료구조를 보호하는 목적으로 사용하는 가벼운 Lock임
- 래치도 일종의 Lock이지만 큐잉 메커니즘을 사용하진 않음
- 따라서 특정 자원에 액세스하려는 프로세스는 래치 획득에 성공할 때까지 시도를 반복할 뿐 우선권을 부여받지는 못함
- 이는 가장 먼저 래치를 요구했던 프로세스가 가장 늦게 래칠르 얻을 수 있음을 뜻함
- 지금까지 소개한 것 외에 자주 발생하는 대기 이벤트로는 아래와 같은 것들이 있음
```
log file sync/li
checkpoint completed
log file switch completion
log buffer space

```