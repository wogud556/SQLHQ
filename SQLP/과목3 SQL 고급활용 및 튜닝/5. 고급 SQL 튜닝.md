# 고급 SQL 튜닝
- 장에서 설명한 것처럼 데이터베이스 Call을 반복적으로 일으키는 프로그램을 One SQL 로 통합헀을 때 얻는 성능개선 효과는 매우 극적임
- 본 절에서는 복잡한 처리 절차를 One-SQL로 구현하는 데 적용할 수 있는 몇가지 유용한 기법을 소개한다

## Case문 활용
- 레코드형으로 되어있는 데이터를 항목형태로 가공하려고 함
- 효율을 고려하지 않은 One-SQL은 누구나 작성할 수 있음
- One-SQL로 작성하는 자체가 중요한 것이 아니라 어떻게 I/O 효율을 달성할 지가 중요함
- 이는 동일 레코드를 반복 액세스하지 않고 얼마만큼 블록 액세스 양을 최소화할 수 있느냐에 달림
- I/O 효율을 고려한다면 SQL을 아내롸 같이 작성해야 함
```
INSERT INTO 월별요금납부실적 (고객번호, 납입월, 지로, 자동이체, 신용카드, 핸드폰, 인터넷) SELECT 고객번호, 납입월 , NVL(SUM(CASE WHEN 납입방법코드 =
'A' THEN 납입금액 END), 0) 지로, NVL(SUM(CASE WHEN 납입방법코드 ='B' THEN 납입금액 END), ) 자동이체 , NVL(SUM(CASE WHEN 납입방법코드 ='C' TH EN 납입금액 END), 0) 신용카드 , NVL(SUM (CASE WHEN 납입방법코드 ='D' THEN 납입금액 END), 0) 핸드폰, NVL(SUM (CASE WHEN 납입방법코드 = 'E' TJEM 납입금액 END), 0) 인터넷 FROM 월별납입방법별집계 WHERE 납입월 ='200903' GROUP BY 고객번호, 납입월;
```
- 참고로  SQL Server에선 2005버전부터 Pivot 구문을 지원하고 Oracle도 11G부터 지원하기 시작했으므로 앞으로 이것을 쓰면 됨
- 그렇지만 위와 같은 CASE문이나 DECODE 함수를 활용하는 기법은 IFELSE같은 분기 조건을 포함한 복잡한 처리 절차를 One-SQL로 구현하는 데 반드시 필요하고 ,다른 비슷한 업무에도 응용할 수 있으므로 반드시 숙지하기 바람

## 2. 데이터 복제 기법 활용
- SQL을 작성하다보면 데이터 복제 기법을 활용해야 할 떄가 많음
- 전통적으로 많이 쓰던 방식은 아래와 같은 복제용 테이블을 미리 만들어두고 이를 활용하는 것임
```
create table copy_t ( no number, no2 varchar2(2) ); insert into copy_t select rownum, Ipad(rownum, 2, '0') from big_table where rownum <= 31; alter table copy tadd constraint copy tok primary key(no); create unique index copy_t no2 idx on copy_t(no2);
```
- 이 테이블과 아래와 같이 조인절 없이 조인하면 카디션 곱이 바랫ㅇ해 데이터가 2개로 복제됨
- 3배로 복제하려면 no <=3 조건으로 바꿔주면 됨


```
select * from emp a, copy_t b where b.no <=2;
```

- Oracle 9i부터 dual 테이블을 사용하면 편함
- 아래와 같이 Dual 테이블에 start with 절이 없는 Connect by 구문을 사용하면 두 레코드를 가진 집합이 자동으로 만들어 짐
- 이런 데이터 복제 기법은 다양한 업무 처리에 응ㅇㅇ할 수 있음
- 상단에 있는 break 명령어는 카드 상ㅍ무 분류가 반복적으로 출력되지 않도록 하기 위한 것으로 Oracle SQL * Plus에서만 사용 가능함

## Union All을 활용한 M:M관계의 조인
- M:M관계의 조인을 해결하거나 Full Outer Join을 대체하는 용도로 Union All을 활용할 수 있음
- 부서별 판매계획과 채널별판매실적 테이블이 있음
- 이 두 테이블을 이용해 월별로 각 상품의 계획 대비 판매 실적을 집계하려고 함
- 상품과 연월을 기준으로 볼 때 두 테이블은 M:M관계이므로 그대로 조인하려면 카디션 곱이 발생함
- 아래와 같이 상품, 연월 기준으로 group by 를 먼저 수행하고 나면 두 집합은 1:1 관계가 되므로 Full Outer Join을 통해 원하는 결과집합을 얻을 수 있음
```
select nv(a. 상품, b. 상품) as 상품 , nv(a.계획연월, b.판매연월) as 연월 , nv(계획수량, 0) 계획수량 , nvI(판매수량, 0) 판매수량 from ( select 상품, 계획연월, sum



(계획수량) 계획수량 from 부서별판매계획 Where 계획연월 between '200901' and 200903' group by 상품, 계획연월) a full outer join ( select 상품, 판매연월, sum

(판매수량) 판매수량 from 채널별판매실적 where 판매연월 between '200901' and 200903' group by 상품, 판매연월) b on a.상품 = b.상품 and a. 계획연월 = b.판매
연 월
```
- 하지만 DBMS와 버전에 따라 Full Outer Joind을 아래와 같이 비효율적으로 처리하기도 함
- 한 테이블을 두 번씩 액세스 하는 것을 확인하기 바람
- Union All을 이용하면 M:M 관계의 조인이나 Full Outer Join을 쉽게 해결할 수 있음
- SQL Server에선 NVL 대신 isnull 함수를 사용하고, to_number 대신 cast 함수를 사용할 것

## 4. 페이징 처리
- 1장에서 데이터 베이스 Call과 네트워크 부하를 설명하면서 페이징 처리 활용의 중요성을 강조함
- 조회할 데이터가 일정량 이상이고 수행 빈도가 높다면 반드시 페이징 처리를 해야 한다는 것이 결론
- 그러면 어떻게 페이징 처리를 구현하는 것이 효과적인지 살펴본다
- 페이징처리는 출력 방식에 대한 사용자 요건과 애플리케이션 아키텍쳐, 그리고 인덱스구성 등에 따라 다양한 방법이 존재하므로 여기서 소개한 기본 패턴을 바탕으로 각 개발 환경에 맞게 응용하길 바람

### 일반적인 페이징 처리용 SQL
- 아래는 관심 종목에 대해 사용자가 입력한 거래 일시 이후 거래 데이터를 페이징 처리 방식으로 조회하는 SQL
```
SELECT * FROM ( SELECT ROWNUM NO, 거래일시, 체결건수 , 체결수량, 거래대금, COUNT(*) OVER () CNT.
.... O FROM ( SELECT 거래일시, 체결건수, 체결수량, 거래대금 FROM 시간별종목거래 WHERE 종목코드 = isu_cd - 사용자가 입력한 종목코드 AND 거래일시 >=:trd_ime - 사용자가 입력한 거래일자 또는 거래일시 ORDER BY 거래일시
WHERE ROWNUM <= page*:pg
size+1
.. (3 ) WHERE NO BETWEEN (page-1) *pgsize+1 AND :pgsize*:page
```
- :pgsize 변수에는 사용자가 다음 버튼을 누를 때마다 Fetch해 올 데이터 건수를 입력하고 :page 변수에는 그 때 출력하고자 하는 페이지 번호를 입력하면 됨
  - 다음 페이지에 읽을 데이터가 더 있는지 확인하는 용도
  - 결과집합에서 CNT 값을 읽었을 때 :pgsize*:page 보다 크면 '다음' 페이지에 출력할 데이터가 더 있음을 알 수 있음
  - 전체 건수를 세지 않고도 다음 버튼이 활성화 할지 판단할 수 있어 유용함
  - 이 기능이 필요치 않을 때는 3번 라인에서 +1을 제거하면 됨
- [종목코드 + 거래일시] 순으로 정렬된 인덱스가 있을 때는 자동으로 Sort 오퍼레이션이 생략됨
  - NOSORT를 위해 활용 가능한 인덱스가 없으면 결과집합 전체를 읽는 비효율은 어쩔 수 없지만 TOP-N 쿼리 알고리즘은 잠시 후 2절 5항에서 설명함
- :pgsize = 10이고 :page = 3일 때, 거래일시 순으로 31건만 읽음
- :pgsize = 10이고 :page = 3일 떄, 안쪽 인라인 뷰에서 읽은 31건 중 21~30번째 데이터 즉 3페이지만 리턴함
- 성능과 I/O 효율을 위해서도 [종목코드 + 거래일시] 순으로 구성된 인덱스가 필요하며, 이 인덱스의 도움을 받을 수만 있다면 정렬 작업을 수행하지 않아도 되므로 전체 결과집합이 아무리 크더라도 첫 페이지 만큼은 가장 최적의 수행 속도를 보임
- 따라서 사용자가 주로 앞쪽 일부 데이터만 조회할 때 아주 효과적인 구현방식
- 실제 대부분 업무에서 앞쪽 일부만 조회하므로 표준적인 페이징 처리 구현 패턴으로 가장 적당하다고 하겠다

### 뒤쪽 페이지까지 자주 조회할 때
- 만약 사용자가 '다음' 버튼을 계속 클릭해서 뒤쪽으로 많이 이동하는 업무라면 위 쿼리는 비효율적임
- 인덱스 도움을 받아 NOSORT 방식으로 처리하더라도 앞에서 읽었던 레코드들을 계속 반복적으로 액세스 해야하기 때문
- 인덱스마저 없다면 전체 조회 대상 집합을 매번 반복적으로 액세스 하게 됨
- 뒤쪽의 어떤 페이지로 이동하더라도 빠르게 조회되도록 구현해야 한다면? 앞쪽 레코드를 스캔하지 않고 해당 페이지 레코드로 바로 찾아가도록 구현
- 아래는 첫 번째 페이지를 출력하고 나서 '다음' 버튼을 누를 때의 구현 예시

```
SELECT 거래일시, 체결건수, 체결수량, 거래대금 FROM ( SELECT 거래일시, 체결건수, 체결수량, 거래대금 FROM 시간별종목거래 A WHERE :페이지이동 ='NEXT' AND 종목코드= isu_cd AND 거래일시 >= trd_time ORDER BY 거래일시 ) WHERE ROWNUM <= 1
```
  첫