# 옵티마이저 원리

## 옵티마이저 소개

### 옵티마이저란?
- SQL을 가장 빠르고 효율적으로 수행할 최적의 처리경로를 생성해주는 DBMS 내부의 핵심 엔진임
- 사용자가 구조화된 질의언어로 결과집합을 요구하면, 이를 생성하는데 필요한 처리 경로는 DBMS에 내장된 옵티마이저가 자동으로 생성해줌
- 옵티마이저가 생성한 SQL 처리 경로를 실행계획이라 부름
- 옵티마이저의 SQL 최적화 과정을 요약하면 다음과 같음
  - 사용자가 던진 쿼리수행을 위해 후보군이 될만한 실행계획을 가짐
  - 데이터 딕셔너리에 미리 수집해놓은 오브젝트를 통계 및 시스템 통계 정보를 이용해 각 실행계획의 예상 비용을 산정함
  - 각 실행계획을 비교해서 최저비용을 갖는 하나를 선택함

### 옵티마이저 종류
- 옵티마이저는 다음 두 가지로 나뉘며, 앞서 설명한 SQL 최적화 과정은 비용기반 옵티마이저에 관한 것

#### 규칙기반 옵티마이저
- 규칙기반 옵티마이저는 다른 말로 휴리스틱 옵티마이저라고 불림
- 미리 정해놓은 규칙에 따라 액세스 경로를 평가하고 실행계획을 선택함
- 여기서 규칙이란 액세스 경로별 우선순위로서 인덱스 구조, 연산자, 조건절 형태가 순위를 결정짓는 주요인임

#### 비용 기반 옵티마이저
- 비용 기반 옵티머이저는 말 그대로 비용을 기반으로 최적화를 수행함
- 여기서 비용이란 쿼리를 수행하는 데 소요되는 일량 또는 시간을 뜻함
- CBO가 실헹계획을 수립할 때 판단 기준이 되는 비용은 어디까지나 예상치임
- 미리 구해놓은 테이블과 인덱스에 대한 여러 통계정보를 기초로 각 오퍼레이션 단계별 예상 비용을 산정하고, 이를 합산한 총비용이 가장 낮은 실행계획을 선택함
- 비용을 산정할 때 사용되는 오브젝트 통계 항목으로는 레코드 개수, 블록 개수, 평균 행 길이 칼럼 값의 수, 칼럼 값 분포, 인덱스 높이, 클러스터링 팩터 같은 것을이 있음
- 오브젝트 통계 뿐만 아니라 최근에는 하드웨어적 특성을 반영한 시스템 통계 정보까지 이용함
- 역사가 오래된 Oracle은 RBO에서 출발하였으나, 다른 상품 RDBMS는 탄생 초기부터 CBO를 채택함
- Oracle 도 10G 버전부터 RBO에 대한 지원을 중단하였으므로 본서는 CBO를 중심으로 설명함
  - 스스로 학습하는 옵티마이저
    - 전통적으로 옵티마이저는 오브젝트 통계와 시스템 통계로부터 산정한 '예상' 비용만으로 실행계획을 수립해옴
    - 하지만 앞으로 예상치와 런타임 수행 결과를 비교하고, 예상치가 빗나갔을 때 실행계획을 조정하는 옵티마이저로 발전할 것
    - 최근에 발표된 각 DBMS 버전은 이미 이런 기능을 포함하고 있음

#### SQL 최적화 과정
- Oracle 기준으로, SQL 최적화 및 수행 과정을 좀 더 자세히 표현하면 아래와 같음
  - Parser로 SQL 파싱
  - 옵티마이저로 옵티마이징
    - 쿼리 변환
    - 추정 작업
    - 계획 생성
  - 실행계획을 토대로 Row Source 생성
  - SQL 엔진으로 실행

#### 서브 엔진별 역할
- Parser
  - SQL 문장을 이루는 개별 구성요소를 분석하고 파싱해서 파싱 트리를 만듬
  - 이 과정에서 사용자 SQL에 문법적 오류가 없는지 , 의미상 오류가 없는지 확인함
- Optimizer
  - Query Transformer
    - 파싱된 SQL을 좀 더 일반적이고 표준적인 형태로 변환
  - Estimator
    - 오브젝트 및 시스템 통계정보를 이용해 쿼리 수행 각 단계의 선택도, 카디널리티, 비용을 계산하고, 궁극적으로 실행계획 전체에 대한 총 비용을 계산해냄
  - Plan Generator
    - 하나의 쿼리를 수행하는 데 있어, 후보군이 될만한 실행계획들을 생성해 냄
  - Row-Source Generator
    - 옵티마이저가 생성한 실행계획을 SQL 엔진이 실제 실행할 수 있는 코드 형태로 포매팅함
  - SQL Engine
    - SQL을 실행함
- Oracle 뿐만 아니라 다른 DBMS도 비슷한 처리 과정을 통해 실행계획을 생성함
- 참고로 M.Jarke와 J.Koch가 펴낸 책에서는 쿼리 최적화 과정을 다음과 같이 설명하고 있는데 표에서 설명한 내용이 Parser와 Optimizer역할에 해당하는 내용이다.
  - 쿼리를 내부 표현방식으로 변환
  - 표준적인 형태로 변환
  - 후보군이 될만한 프로시저를 선택
  - 실행계획을 생성하고, 가장 비용이 적은 것을 선택

### 최적화 목표

#### 전체 처리속도 최적화
- 쿼리 최종 결과집합을 끝까지 읽는 것을 전제로, 시스템 리소스를 가장 적게 사용하는 실행계획을 선택함
- Oracle SQL Server 등을 포함해 대부분 DBMS의 기본 옵티마이저 모드는 전체 처리 속도 최적화에 맞춰져 있음
- Oracle에서 옵티마이저 모드를 바꾸는 방법은 다음과 같음

```
alter system set optimizer_mode = all_rows : 시스템 레벨 변경
alter session set optimizer_mode = all_rows: - 세션 레벨 변경
```

#### 최초 응답속도 최적화
- 전체 결과집합 중 일부만 읽다가 멈추는 것을 전제로, 가장 빠른 응답속도를 낼 수 있는 실행계획을 선택함
- 만약 이 모드에서 생성한 실행계획으로 데이터를 끝까지 읽는다면 전체 처리 속도 최적화 실행계획보다 더 빠른 리소스를 사용하고 전체 수행 속도도 느려질 수 있음
- Oracle 옵티마이저에게 최초 응답속도 최적화를 요구하려면 옵티마이저 모드를 first_rows로 바꿔주면 됨
- SQL 서버에서는 테이블 힌트로 fastfirstrow를 지정하면 됨
- Oracle에서 옵티마이저 모드를 first_rows_n으로 지정하면 예를들어 시스템 또는 세션 레벨에서 first_rows_10으로 지정하면 사용자가 전체 결과집합 중 처음 10개 로우만 ㅇ릭고 머추는 것을 전제로 가장 빠른 응답을 낼 수 있는 실행계획을 선택함
- 쿼리 레벨에서 힌트를 사용하려면 아래와 같이 하면 됨

```
select /*+ first_rows(10)*/
from t
where;
```

- SQL 서버에서는 쿼리 힌트로 fast 10을 지정하면 됨

```
select *
from t
where OPTION(fast 10);
```

## 2. 옵티마이저 행동에 영향을 미치는 요소

### SQL과 연산자 형태
- 결과가 같더라도 SQL을 어떤 형태로 작성하는지 또는 어떤 연산자를 사용하는지에 따라 옵티마이저가 다른 선택을 할 수 있고, 이는 쿼리 성능에 영향을 미침

### 옵티마이징 팩터
- 쿼리를 똑같이 작성하더라도 인덱스, IOT, 클러스터링, 파티셔닝 MV등을 어떻게 구성하는지에 따라 실행계획과 성능이 크게 달라짐

### DBMS 제약 설정
- 개체 무결성, 참조 무결성, 도메인 무결성 등을 위해 DBMS가 제공하는 PK, FK, Check Not Null 같은 설정 기능을 이용할 수 있고, 이들 제약 설정은 옵티마이저가 쿼리 성능을 최적화 하는데 매우 중요한 정보를 제공함
- 예를 들어 인덱스 칼럼에 Not Null 제약이 설정돼 있으면 옵티마이저는 전체 개수를 구하는 Count 쿼리에 이 인덱스를 활용할 수 있음

### 옵티마이저 힌트
- 옵티마이저의 판단보다 사용자가 지정한 옵티마이저 힌트가 우선함
- 옵티마이저 힌트에 대해서는 뒤에 좀 더 자세히 다룸

### 통계정보
- 통계정보가 옵티마이저에게 미치는 영향력은 절대적임
- 뒤에서 통계정보를 이용한 비용계산 원리를 설명할 때 느끼겠지만, CBO의 모든 판단 기준은 통계 정보에서 나옴

### 옵티마이저 관련 파라미터
- SQL, 데이터, 통계정보, 하드웨어 등 모든 환경이 동일하더라도 DBMS 버전을 업그레이드 하면 옵티마이저가 다르게 작동할 수 있음
- 이는 옵티마이저 관련 파라미터가 추가 또는 변경되면서 나타나는 현상

### DBMS 버전과 종류
- 옵티마이저 관련 파라미터가 같더라도 버전에 따라 실행계획이 다를 수 있음
- 또한 같은 SQL 이더라도 DBMS종류에 따라 내부적으로 처리하는 방식이 다를 수 있음

## 3. 옵티마이저의 한계
- 옵티마이저가 사람이 만든 소프트웨어 엔진에 불과하며 결코 완벽할 수 없음을 이해하는 것은 매우 중요함
- 현재의 기술 수준으로 해결하기 어려운 문제가 있는가 하면, 기술적으론 가능한데 현실적인 제약(토예정보 수집량과 최적화를 위해 허락된 시간) 때문에 아직 적용하지 못하는 것들도 있음
- 옵티마이저가 완벽하지 못하게 만드는 요인이 어디에 있는지 살펴본다.

### 옵티마이징 팩터의 부족
- 옵티마이저는 주어진 환경에서 가장 최적의 실행계획을 수립하기 위해 정해진 기능을 수행할 뿐
- 옵티마이저가 아무리 정교하고 기술적으로 발전하더라도 사용자가 적절한 옵티마이징 팩터를 제공하지 않는다면 결코 좋은 실행계획을 수립할 수 있음

### 통계 정보의 부정확성
- 최적화에 필요한 모든 저보를 수집해서 보관할 수 있다면 옵티마이저도 그만큼 고성능 실행계획을 수립하겠지만, 100% 정확한 통계정보를 유지하기는 현실적으로 불가능함
- 특히 칼럼 분포가 고르지 않을 때 칼럼 히스토그램이 반드시 필요한데, 이를 수집하고 유지하는 비용이 만만치 않음
- 칼럼을 결합 할 때의 모든 결합 분포를 미리 구해두기 어려운 것도 큰 제약 중 하나임
- 이는 상관관계에 있는 두 칼럼이 조건절에 사용될 때 옵티마이저가 잘못된 실행계획을 수립하게 만드는 주 요인임
```
select * from 사원 where 직급 = '부장' and 연봉 >= 5000;
```
- 직급이(부장, 과장, 대리 사원)의 집합이고 각각 25%의 비중을 가짐
- 그리고 전체 사원이 1000명이고 히스토그램상 '연봉 >= 5000' 조건에 부합하는 사원 비중이 10퍼면 옵티마이저는 위 쿼리 조건에 해당하는 사원 수를 25(=1000*0.25+0.1)명으로 추정함
- 하지만 알다시피 직급과 연봉 간에는 상관관계가 매우 높아, 만약 모든 부장의 연봉이 5천 이상이면 실제 위 쿼리 결과는 250임
- 이런 조건절에 대비해 모든 칼럼 간 상관관계와 결합분포를 미리 저장해두면 좋겠지만 거의 불가능에 가까움
- 테이블 칼럼이 작을수록 잠재적인 칼럼 조합의 수는 기하급수적으로 증가하기 때문임

### 바인드 변수 사용 시 균등분포 가정
- 아무리 정확한 칼럼 히스토그램ㅇ르 보유하더라도 바인드 변수를 사용한 SQL 에서는 무용지물임
- 조건절에 바인드 변수를 사용하면 옵티마이저가 균등 분포를 가정하고 비용을 계산하기 때문임

### 비현실적인 가정
- 옵티마이저는 쿼리 수행 비용을 평가할 때 여러 가정을 사용하는데, 그 중 일부는 상당히 비현실적이어서 종종 이해할 수 있는 실행계획을 수립하곤 함
- 예전 Oracle 버전에선 Single Block I/O와 Multiblock I/O의 비용을 같게 평가하고 데이터 블록의 캐싱 효과도 고려하지 않았는ㄴ데, 그런 것들이 비현실적인 가정의 좋은 예시임
- DBMS 버전이 올라가면서 이런 비현실적인 가정들이 계속 보완되고 있지만 완벅하지않고, 모두 해결되리라고 기대하는 것도 무리임

### 규칙에 의존하는 CBO
- 아무리 비용기반 옵티마이저라 하더라도 부분적으로는 규칙에 의존함
- 예를 들어 최적화 목표를 최초 응답 속도에 맞추면 (Oracle을 예로 들면 Optimizer_mode = first_rows), order by 소트를 대체할 인덱스가 있을 때 무조건 그 인덱스를 사용함
- 다음 절에서 설명할 휴리스틱 쿼리 변환도 좋은 예라고 할 수 있음

### 하드웨어 성능
- 옵티마이저는 기본적으로 옵티마이저 개발팀이 사용한 하드웨어 사양에 맞춰져 있음
- 따라서 실제 운영 시스템의 하드웨어 사양이 그것과 다를 때 옵티마이저가 잘못한 실행계획을 수립할 가능성이 높아짐
- 또한 애플리케이션 특성(I/O 패턴, 부하정도 등)에 의해서도 하드웨어 성능은 달라짐

## 4. 통계정보를 이용한 비용 계산 원리
- 실행계획을 수립할 때 CBO는 SQL 문장에서 액세스할 데이터 특성을 고려하기 위해 통계정보를 이용함
- 최적의 실행계획을 위해 통계정보가 항상 데이터 상태를 정확하게 반영하고 있어야 하는 이유임
- DBMS 버전이 올라갈수록 자동 통계관리 방식으로 바뀌고 있지만, 가끔 DB 관리자가 수동으로 수집관리 해주어야 할 때도 있음
- 옵티마이저가 참조하는 통계정보 종류로 아래 네가지가 있음

### 옵티마이저 통계 유형
- 테이블 통계
  - 전체 레코드 수, 총 블록 수, 빈 블록 수, 한 행당 평균 크기 등
- 인덱스 통계
  - 인덱스 높이, 리프 블록 수, 클러스터링 팩터, 인덱스 레코드 수 등
- 칼럼 통계
  - 값의 수, 최저 값, 최고 값, 밀도 Null 값 개수, 칼럼 히스토그램 등
- 시스템 통계
  - CPU 속도, 평균적인 I/O 속도, 초당 I/O 처리량 등

### 선택도
- 선택도는 전체 대상 레코드 중에서 특정 조건에 의해 선택될 것으로 예상되는 레코드 비율을 말함
- 선택도를 가지고 카디널리티를 구하고, 다시 비용을 구해 인덱스 사용여부, 조인 순서와 방법 등을 결정하므로 선택도는 최적의 실행 계획을 수립하는데 있어 가장 중요한 요인이라고 함
- 선택도 -> 카디널리티 -> 비용 -> 액세스 방식, 조인 순서, 조인 방법 등 결정 히스토그램이 있으면 그것으로 선택도를 산정하며, 단일 칼럼에 대해서는 비교적 정확한 값을 구함
- 히스토그램이 있거나 있더라도 조건절에 바인드 변수를 사용하면 옵티마이저는 데이터 분포가 균일하다고 가정한 상태에서 선택도를 구함
- 히스토그램이 등치 조건에 대한 선택도를 구하는 공식은 다음과 같음
- 선택도 = 1/Distinct value 개수 = 1/Num distinct

### 카디널리티
- 카디널리티는 특정 액세스 단계를 거치고 난 후 출력될 것으로 예상되는 결과 건수를 말하며, 아래와 같이 총 로우 수에 선택도를 곱해서 구함
```
카디널리티 = 총 로우 수 * 선택도 칼럼 히스토그램이 나을때 '=' 조건에 대한 선택도가 1/num_distinct이므로 카디널리티는 아래와 같이 구해짐
카디널리티 = 총 로우 수 * 선택도 = num_rows / num_distinct

select * from 사원 where 부서 := 부서
```
- 예를 들어 위 쿼리에서 부서 칼럼의 Distinct Value 개수가 10이면 선택도는 0.1(=1/10)이고, 총 사원 수가 1000명일 때 카디널리티는 100이 됨
- 옵티마이저는 위 조건절에 의한 결과집합이 100건일 것으로 예상한다는 뜻
- 조건절이 두 개 이상일 때는 각 칼럼의 선택도와 전체 로우 수를 곱해 주기만 하면 됨

```
select * from 사원 where 부서 =:부서 and 직급 =: 직급
```
- 직급의 도메인이 부장, 과장, 대리, 사원 이면 Distinct Value 개수가 4이므로 선택도는 0.25임
- 따라서 위 쿼리의 카디널리트는 25(=1000 * 0.1 * 0.25)

### 히스토그램
- 미리 저장된 히스토그램 정보가 있으면 옵티마이저는 그것을 사용해 더 정확하게 카디널리티를 구할 수 있음
- 특히 분포가 균일하지 않은 칼럼으로 조회할 때 효괄르 발휘함
- 히스토그램은 아래 두가지 유형이 있음
  - 도수분포 히스토그램 그림생략
  - 높이균형 히스토그램 그림생략

### 비용
- CBO는 비용을 기반으로 최적화를 수행하고 실행계획을 생성한다고 설명한다
- 여기서 비용이란 쿼리를 수행하는데 소요되는 일량 또는 시간을 뜻함
- 어디까지나 예상치임
- 옵티마이저 비용 모델에는 I/O 비용 모델과 CPU 비용 모델 두가지가 있음
- I/O 비용 모델
  - 예상되는 I/O 요청 횟수만을 쿼리 수행 비용으로 간주해 실행계획을 평가
- CPU 비용 모델
  - I/O 비용모델에서 시간 개념을 더해 비용을 산정함
- 지면 관계상 본서는 I/O 비용 모델만 다룸

#### 인덱스를 경유한 테이블 액세스 비용
- I/O 비용 모델에서의 비용은 디스크 I/O Call 횟수(논리적/물리적으로 읽은 블록 개수가 아닌 I/O Call 횟수)를 의미함
- 그리고 인덱스를 경유한 테이블 액세스 시에는 Single Block I/O 방식이 사용됨
- 이는 디스크에서 한 블록을 읽을 때마다 한 번의 I/O Call을 일으키는 방식이므로 읽기 될 불리적 블록 개수가 I/O Call 횟수와 일치함
- 따라서 인덱스를 이용한 테이블 액세스 비용은 아래와 같은 공식으로 구할 수 있음
```
비용 = blevel --인덱스 수직적 탐색 비용 + (리프 블록 수 * 유효 인덱스 선택도) -
- 인덱스 수평적 탐색 비용 + (클러스터링 팩터 * 유효 테이블 선택도) -- 테이블 Random 액세스 비용
```

#### 인덱스를 경유한 테이블 액세스 비용 항목
- blevel
  - 브랜치 레벨을 의미하며, 리프 블록에 도달하기 전에 읽게 될 브랜치 블록 개수
- 클러스터링 팩터
  - 특정 칼럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도, 인데스를 경유해 테이블 전체 로우를 액세스할 때 읽을 것으로 예상되는 논리적인 블록 개수를 계수화함
- 유효 인덱스 선택도
  - 전체 인덱스 레코드 중에서 조건절을 만족하는 레코드를 찾기 위해 스캔할 것으로 예상되는 비율
  - 리프 블록에는 인덱스 레코드가 정렬된 상태로 저장되므로 이 비율이 곧, 방문할 리프 블록 비율
- 유효 테이블 선택도
  - 전체 레코드 중에서 인덱스 스캔을 완료하고서 최종적으로 테이블을 방문할 것으로 예상되는 비율(%), 클러스터링 팩터는 인덱스를 경유해 전체 로우를 액세스할 때 읽힐 것으로 예상되는 테이블 블록 개수이므로 여기에 유효 테이블 선택도를 곱함으로써 조건절에 대해 읽힐 것으로 예상되는 테이블 블록 개수를 구할 수 있다.

#### Full Scan에 의한 테이블 액세스 비용
- Full Scan에 대해서는 테이블 전체를 순차적으로 읽어 들이는 과정에서 발생하는 I/O Call 횟수로 비용을 계산함
- Full Scan할 때는 한 번의 I/O Call로써 여러 블록을 읽어 들이는 Multiblock I/O 방식을 사용하므로 총 블록 수를 Multiblock I/O Call이 발생함
- 예를 들어 100 블록을 8개씩 나누어 읽는다면 13번의 I/O Call이 발생하고 I/O Call 횟수로써 Full Scan 비용을 추정함
- 따라서 Multiblock I/O 단위가 증가할 수록 I/O Call 횟수가 줄고 예상 비용도 줄게 됨