## 1. 옵티마이저
- 사용자가 질의한 SQL문에 대해 최적의 실행방안을 결정하는 역할
- 최적의 실행방법을 실행계획이라고 함
- 관계형 데이터베이스에서 궁극적으로 SQL문을 통해서만 데이터를 처리할 수 있다.
- JAVA, C 등과 가은 프로그램 언어와는 달리 SQL은 사용자의 요구사항만 기술할 뿐 처리과정에 대한 기술은 하지 않는다.
- 사용자의 요구사항을 만족하는 결과를 추출하는 다양한 실행방법이 존재
- 다양한 실행 방법들 중에 최적의 실행방법을 결정하는 것이 바로 옵티마이저의 역할임
- 관계형 데이터베이스는 옵티마이저가 결정한 실행방법대로 실행 엔진이 데이터를 처리하여 결과 데이터을 사용자에게 전달할 뿐임
- 옵티마이저가 선택한 실행방법의 적절성 여부는 질의의 수행 속도에 가장 큰 영향을 미치게 함
- 이런 의미에서 관계형 데이터베이스에서 진정한 프로그래머는 옵티마이저이다.
- 최적의 실행방법 결정이라는 어떤 방법으로 처리하는 것이 최소 일량으로 동일한 일을 처리할 수 있을지 결정하는 것과 똑같음
- 이러한 결정을 옵티마이저는 실제로 SQL문을 처리해보지 않은 상태에서 결정해야하는 어려움이 있음
- 옵티마이저가 최적의 실행방법을 결정하는 방식에 따라 규칙기반 혹은 비용기반으로 구분한다.

### 1.1 규칙기반 옵티마이저
- 규칙을 가지고 실행계획을 생성한다.
- 실행계획을 생성하는 규칙을 이해하면 누구나 실행계획을 비교적 쉽게 예측할 수 있다.
- 규칙기반 옵티마이저가 실행계획을 생성할 때 참조하는 정보에는 SQL문을 실행하기 위해서 이용 가능한 인덱스유무(유이르 비유일, 단일, 복합 인덱스) 종류, SQL문에서 사용하는 연산자(=,<,>,<>,LIKE, BETWEEN 등)의 종류 그리고 SQL문에서 참조하는 객체하는 객체(힙테이블, 클러스터 테이블 등)의 종류 등이 있다.
- 이러한 정보에 따라 우선 순위(규칙)이 있고, 이 우선순위를 기반으로 실행계획 생성
- 결과적으로 규칙기반 옵티마이저는 우선 순위가 높은 규칙이 적은 일량으로 해당 작업을 수행하는 방법이라고 판단하는 것
- 아래와 같이 규칙기반 옵티마이저는 15가지 방법이 존재한다.
  1. Single row by rowid
     - ROWID를 통해서 테ㅣ블에서 하나의 행을 액세스
  2. Single row by cluster join
  3. Single row by hash cluster key with unique or primary key
  4. Single row by unique or primary key
     - 유일 인덱스를 통해서 하나의 행을 엑세스하는 방법
  5. Cluster join
  6. Hash cluster key
  7. Indexed cluster key
  8. Composite index
     - 복합 인덱스에 동등 조건으로 검색하는 경우
  9.  Single cloumn index
      - 단일 컬럼 인덱스에 '=' 조건으로 검색하는 경우
  10. Bounded range search on indexed columns
      - 인덱스가 생성되어 있는 컬럼에 양쪽 범위를 한정하는 형태로 검색하는 방식
  11. Unbounded range search in indexed columns
      - 인덱스가 생성되어 있는 칼럼에 한쪽 범위만 한정하는 형태로 검색하는 방식
  12. Sort merge join
  13. MAX or MIN of indexed column
  14. ORDER BY on indexed column
  15. Full table scan
      - 전체 테이블을 액세스하면서 조건절에 주어진 조건을 만족하는 행만을 결과로 추출한다.
- 규칙기반 옵티마이저는 인덱스를 이용한 액세스 방식이 전체 테이블 엑세스보다 우선수위가 높음
- 규칙기반 옵티마이저는 해당 SQL문에서 이용 가능한 인덱스가 존재한다면 전체 테이블 액세스 방식보다는 항상 인덱스를 사용하는 실행계획을 세움
- 조인 순서를 결정할 때는 조인 칼럼 인덱스의 존재 유무가 중요한 판단의 기준이다.
- 조인 칼럼에 대한 인덱스가 양쪽 테이블에 모두 존재한다면 앞에서 설명한 규칙에 따라 우선 순위가 높은 테이블을 선행 테이블로 선택한다.

#### 1.2 비용기반 옵티마이저
- 규칙기반의 단순한 몇개의 규칙만으로 현실의 모든사항을 정확히 예측할 수 없다는 단점을 극복하기 위해 출현
- 비용기반 옵티마이저는 SQL문을 처리하는데 필요한 비용이 가장 적은 실행계획을 선택하는 방식
- 여기서 비용이란 SQL문을 처리하기 위해 예상되는 소요시간 또는 자원 사용량을 의미한다.
- 비용기반 옵티마이저는 비용을 예측하기 위해서 규칙기반 옵티마이저가 사용하지 않는 테이블, 인덱스, 칼럼 등의 다양한 객체 통계 정보와 시스템 통계 정보 등을 이용

#### SQL 최적화 및 수행 과정
1. SQL 파싱 -> Parsed SQL
2. 옵티마이저로 실행계확 만들기
   1. 이때 쿼리 변환
   2. 계확 정의
3. 소스 실행기
   1. 옵티마이저가 생성한 실행계확을 SQL엔진이 실제 시행할 수 있는 코드 형태로 포맷팅함
4. SQL Engine
   1. SQL을 실행함

### 최적화의 목표
1. 전체 처리속도 최적화
   1. 쿼리 최종 결과집합을 끝까지 읽는 것을 전제로 시스템리소스를 가장 적게 사용하는 실행계획을 선택함
   2. 예시
   ``` 
    alter system optimizer_mode = all_rows - 시스템 레벨 변경
    alter session set optimizer_mode = all_rows - 세션 레벨 변경
    
   ```
2. 최초 응답속도 최적화
   1. 전체 결과 집합 중 일부만 읽다가 멈추는 것을 전제로 가장 빠른 응답속도를 낼 수 있는 실행계획을 선택함
   2. 만약 이 모드에서 생성한 실행계획으로 데이터를 끝까지 읽는다면 전체 처리속도 최적화를 실행계획보다 더 나은 리소스를 사용하고 전체 수행속도도 느려질 수 있음
   3. oracle에서 옵티마이저 모드를 first_rows_n으로 저장하면, 예를 들어 시스템 또는 세션 레벨에서 first_rows_10으로 지정하면 사용자가 전체 결과집합 중 처음 10개 로우만 읽고  멈추는 것을 전제로 가장 빠른 응답 속도를 낼 수 있는 실행계획을 선택함

### 옵티마이저 행동에 영향을 미치는 요소
- SQL과 연산자 형태
  - 결과가 같더라도 SQL을 어떤 형태로 작성하였는지 또는 어떤 연산자를 사용 하였는지에 따라 옵티마이저가 다른 선택을 할 수 있고, 이는 쿼리 성능에 영향을 미침
- 옵티마이징 팩터
  - 쿼리를 똑같이 작성하더라도 인덱스, IOT, 클러스터링, 파티셔닝, MV등을 어떻게 구성하는지에 따라 실행계획과 성능이 크게 달라짐
- DBMS 제약 설정
- 옵티마이저 힌트
- 통계 정보
- 옵티마이저 관련 파라미터
- DBMS버전과 종류
  - 옵티마이저 관련 파라미터가 같더라도 버전에 따라 실행 계획이 다를 수 있음
  - 또한 같은 SQL이더라도 DBMS종류에 따라 내부적으로 처리하는 방식이 다를 수 있음

### 옵티마이저의 한계
- 옵티마이저 팩터의 부족
- 통계정보의 부정확성
- 비현실적인 가정
- 규칙에 의존하는 CBO
- 하드웨어 성능

### 통계정보를 이용한 비용계산의 원리
- 실행계획을 수립할 때 CBO는 SQL문장에서 액세스할 데이터의 특성을 고려하기 위해 통계정보를 이용함
- 최적의 실행계획을 위해 통계정보가 항상 데이터 상태를 정확하게 반영하고 있어야 하는 이유
- DBMS버전이 올라갈수록 자동 통계관리방식으로 바뀌고 있지만, 가끔 DB관리자가 수동으로 수집관리해 주어야 할 때도 있음
- 옵티마이저가 참조하는 통계정보 종류로 네가지가 있음
  - 테이블 통계
  - 인덱스 통계
  - 칼럼 통계
  - 시스템 통계
- 선택도
  - 전체 대상 레코드 중에서 특정 조건에 의해 선택될 것으로 예상되는 레코드 비용
  - 선택도를 가지고 카디널리티를 구하고 다시 비용을 구해 인덱스 사용 여부, 조인 순서와 방법 등을 결정하므로 선택도는 최적의 실행계획을 수립하는데 있어 가장 중요한 요인
  - 선택도 = 1/Distinct Value= 1/num distinct

### 카디널리티
- 카디널리티는 특정 액세스 단계를 거치고 난 후 출력될 것으로 예상되는 결과 건수를 말하며, 아래와 같이 총 로우수에 선택도를 곱해서 구함
  - 카디널리티 = 총 로우수 * 선택도 칼럼 히스토그램이 있을 때 '='조건에 대한 선택도가 1/num_distinct이므로 카디널리티는 아래와 같이 구해짐
  - 카디널리티 = 총 로우수 * 선택도 = num_rows/ num_disticnt
  - SELECT * FROM 사원 WHERE 부서 = :부서

### 히스토그램
- 미리 저장된 히스토그램 정보가 있으면, 옵티마이저는 그것을 사용해 더 정확하게 카디널리티를 구할 수 있음
- 특히 분포가 균일하지 않은 칼럼으로 조회할 때 효과를 발휘함
- 히스토그램에는 아래 두가지 유형이 있음
  - 도수분포 히스토그램
  - 높이균형 히스토그램

### 비용
- CBO는 비용을 기반으로 최적화를 수행하고 실행 계확을 생성한다고 설명
- 여기서 비용이란 쿼리를 수행하는데 소요되는 일량 또는 시간을 뜻함
- 어디까지나 예상치임
- 옵티마이저 비용 모델에는 I/O 비용 모델 두가지가 있음
- I/O 비용 모델은 예상되는 I/O 요청 횟수만을 쿼리 수행 비용으로 간주해 실행계획을 평가하는 반면 CPU 비용 모델은 여기에 시간 개념을 더해 비용을 산정함
- 지면 관계상 본서는 I/O비용 모델만 다룸

#### 인덱스를 경유한 테이블 액세스 비용
- blevel
  - 브랜치 레벨을 의미, 리프 블록에 도달하기 전에 읽게 될 브랜치 블록 개수
- 클러스터링 팩터
  - 특정 칼럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도, 인덱스를 경유해 테이블 전체 로우를 액세스 할 때 읽을 것으로 예상되는 논리적인 블록 개수로 개수화
- 유효 인덱스 선택도
  - 전체 인덱스 레코드 중에서 조건절을 만족하는 레코드를 찾기 위해 스캔할 것으로 예상되는 비율, 리프 블록에는 인덱스 레코드가 정렬된 상태로 저장되므로 이 비율이 곧 방문할 리프 블록 비율
- 유효 테이블 선택도
  - 전체 레코드 중에서 인덱스 스캔을 완료하고서 최종적으로 테이블을 방문할 것으로 예상되는 비율, 클러스터링 팩터는 인덱스를 경유해 전체 로우 를 액세스할 때 읽힐 것으로 예상되는 테이블 블록 개수이므로 여기에 유효 테이블 선택도를 곱함으로써 조건절에 대해 읽힐 것으로 예상되는 테이블 블록 개수를 구할 수 있음


### 옵티마이저
- 통계정보가 정확하지 않거나 기타 다른 이유로 옵티마이저가 잘못된 판단을 할 수 있음
- 그럴 때 프로그램이나 데이터 특성 정보를 정확히 알고 있는 개발자가 직접 인덱스를 지정하거나 조인 방식으로 변경함으로써 더 좋은 실행계획으로 유도하는 매커니즘이 필요한데, 옵티마이저 힌트가 그거임
- 힌트 종류와 구체적인 사용법은 DBMS마다 천차만별이며, 지면 관계상 모두 다를 수 있으므로 Oracle과 SQL Server에 대해서만 설명하기로 함

#### 오라클 힌트
- 힌트 기술 방법
  - 예시
  ```
  SELECT /*힌트의 종류(해당하는테이블1, 2, 3...)*/
  ```
- 힌트가 무시되는 경우
  - 다음과 같은 경우에 Oracle 옵티마이저는 힌트를 무시하고 최적화를 진행함
    - 문법적으로 안 맞게 힌트를 줌
    - 의미적으로 안 맞게 힌트를 기술
    - 예를 들어 서브쿼리에 unnest와 push_subq를 같이 기술한 경우(unnest되지 않는 서브쿼리만이 Push_subq)힌트의 적용 대상자임
  - 잘못된 참조 사용
    - 이곳은 테이블이나 별칭을 사용하거나, 인덱스명을 지정한 경우 등 논리적으로 불가능한 액세스 경로
    - 조인절에 등치 조건이 하나도 없는데 hash JoiN으로 유도하거나 아래 처럼 null 허용칼럼에 대한 인덱스를 이용해 전체 건수를 세려고 시도하는 등