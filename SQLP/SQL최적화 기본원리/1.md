## 1. 옵티마이저
- 사용자가 질의한 SQL문에 대해 최적의 실행방안을 결정하는 역할
- 최적의 실행방법을 실행계획이라고 함
- 관계형 데이터베이스에서 궁극적으로 SQL문을 통해서만 데이터를 처리할 수 있다.
- JAVA, C 등과 가은 프로그램 언어와는 달리 SQL은 사용자의 요구사항만 기술할 뿐 처리과정에 대한 기술은 하지 않는다.
- 사용자의 요구사항을 만족하는 결과를 추출하는 다양한 실행방법이 존재
- 다양한 실행 방법들 중에 최적의 실행방법을 결정하는 것이 바로 옵티마이저의 역할임
- 관계형 데이터베이스는 옵티마이저가 결정한 실행방법대로 실행 엔진이 데이터를 처리하여 결과 데이터을 사용자에게 전달할 뿐임
- 옵티마이저가 선택한 실행방법의 적절성 여부는 질의의 수행 속도에 가장 큰 영향을 미치게 함
- 이런 의미에서 관계형 데이터베이스에서 진정한 프로그래머는 옵티마이저이다.
- 최적의 실행방법 결정이라는 어떤 방법으로 처리하는 것이 최소 일량으로 동일한 일을 처리할 수 있을지 결정하는 것과 똑같음
- 이러한 결정을 옵티마이저는 실제로 SQL문을 처리해보지 않은 상태에서 결정해야하는 어려움이 있음
- 옵티마이저가 최적의 실행방법을 결정하는 방식에 따라 규칙기반 혹은 비용기반으로 구분한다.

### 1.1 규칙기반 옵티마이저
- 규칙을 가지고 실행계획을 생성한다.
- 실행계획을 생성하는 규칙을 이해하면 누구나 실행계획을 비교적 쉽게 예측할 수 있다.
- 규칙기반 옵티마이저가 실행계획을 생성할 때 참조하는 정보에는 SQL문을 실행하기 위해서 이용 가능한 인덱스유무(유이르 비유일, 단일, 복합 인덱스) 종류, SQL문에서 사용하는 연산자(=,<,>,<>,LIKE, BETWEEN 등)의 종류 그리고 SQL문에서 참조하는 객체하는 객체(힙테이블, 클러스터 테이블 등)의 종류 등이 있다.
- 이러한 정보에 따라 우선 순위(규칙)이 있고, 이 우선순위를 기반으로 실행계획 생성
- 결과적으로 규칙기반 옵티마이저는 우선 순위가 높은 규칙이 적은 일량으로 해당 작업을 수행하는 방법이라고 판단하는 것
- 아래와 같이 규칙기반 옵티마이저는 15가지 방법이 존재한다.
  1. Single row by rowid
     - ROWID를 통해서 테ㅣ블에서 하나의 행을 액세스
  2. Single row by cluster join
  3. Single row by hash cluster key with unique or primary key
  4. Single row by unique or primary key
     - 유일 인덱스를 통해서 하나의 행을 엑세스하는 방법
  5. Cluster join
  6. Hash cluster key
  7. Indexed cluster key
  8. Composite index
     - 복합 인덱스에 동등 조건으로 검색하는 경우
  9.  Single cloumn index
      - 단일 컬럼 인덱스에 '=' 조건으로 검색하는 경우
  10. Bounded range search on indexed columns
      - 인덱스가 생성되어 있는 컬럼에 양쪽 범위를 한정하는 형태로 검색하는 방식
  11. Unbounded range search in indexed columns
      - 인덱스가 생성되어 있는 칼럼에 한쪽 범위만 한정하는 형태로 검색하는 방식
  12. Sort merge join
  13. MAX or MIN of indexed column
  14. ORDER BY on indexed column
  15. Full table scan
      - 전체 테이블을 액세스하면서 조건절에 주어진 조건을 만족하는 행만을 결과로 추출한다.
- 규칙기반 옵티마이저는 인덱스를 이용한 액세스 방식이 전체 테이블 엑세스보다 우선수위가 높음
- 규칙기반 옵티마이저는 해당 SQL문에서 이용 가능한 인덱스가 존재한다면 전체 테이블 액세스 방식보다는 항상 인덱스를 사용하는 실행계획을 세움
- 조인 순서를 결정할 때는 조인 칼럼 인덱스의 존재 유무가 중요한 판단의 기준이다.
- 조인 칼럼에 대한 인덱스가 양쪽 테이블에 모두 존재한다면 앞에서 설명한 규칙에 따라 우선 순위가 높은 테이블을 선행 테이블로 선택한다.

#### 1.2 비용기반 옵티마이저
- 규칙기반의 단순한 몇개의 규칙만으로 현실의 모든사항을 정확히 예측할 수 없다는 단점을 극복하기 위해 출현
- 비용기반 옵티마이저는 SQL문을 처리하는데 필요한 비용이 가장 적은 실행계획을 선택하는 방식
- 여기서 비용이란 SQL문을 처리하기 위해 예상되는 소요시간 또는 자원 사용량을 의미한다.
- 비용기반 옵티마이저는 비용을 예측하기 위해서 규칙기반 옵티마이저가 사용하지 않는 테이블, 인덱스, 칼럼 등의 다양한 객체 통계 정보와 시스템 통계 정보 등을 이용

#### SQL 최적화 및 수행 과정
1. SQL 파싱 -> Parsed SQL
2. 옵티마이저로 실행계확 만들기
   1. 이때 쿼리 변환
   2. 계확 정의
3. 소스 실행기
   1. 옵티마이저가 생성한 실행계확을 SQL엔진이 실제 시행할 수 있는 코드 형태로 포맷팅함
4. SQL Engine
   1. SQL을 실행함

### 최적화의 목표
1. 전체 처리속도 최적화
   1. 쿼리 최종 결과집합을 끝까지 읽는 것을 전제로 시스템리소스를 가장 적게 사용하는 실행계획을 선택함
   2. 예시
   ``` 
    alter system optimizer_mode = all_rows - 시스템 레벨 변경
    alter session set optimizer_mode = all_rows - 세션 레벨 변경
    
   ```
2. 최초 응답속도 최적화
   1. 전체 결과 집합 중 일부만 읽다가 멈추는 것을 전제로 가장 빠른 응답속도를 낼 수 있는 실행계획을 선택함
   2. 만약 이 모드에서 생성한 실행계획으로 데이터를 끝까지 읽는다면 전체 처리속도 최적화를 실행계획보다 더 나은 리소스를 사용하고 전체 수행속도도 느려질 수 있음
   3. oracle에서 옵티마이저 모드를 first_rows_n으로 저장하면, 예를 들어 시스템 또는 세션 레벨에서 first_rows_10으로 지정하면 사용자가 전체 결과집합 중 처음 10개 로우만 읽고  멈추는 것을 전제로 가장 빠른 응답 속도를 낼 수 있는 실행계획을 선택함

### 옵티마이저 행동에 영향을 미치는 요소
- SQL과 연산자 형태
  - 결과가 같더라도 SQL을 어떤 형태로 작성하였는지 또는 어떤 연산자를 사용 하였는지에 따라 옵티마이저가 다른 선택을 할 수 있고, 이는 쿼리 성능에 영향을 미침
- 옵티마이징 팩터
  - 쿼리를 똑같이 작성하더라도 인덱스, IOT, 클러스터링, 파티셔닝, MV등을 어떻게 구성하는지에 따라 실행계획과 성능이 크게 달라짐
- DBMS 제약 설정
- 옵티마이저 힌트
- 통계 정보
- 옵티마이저 관련 파라미터
- DBMS버전과 종류
  - 옵티마이저 관련 파라미터가 같더라도 버전에 따라 실행 계획이 다를 수 있음
  - 또한 같은 SQL이더라도 DBMS종류에 따라 내부적으로 처리하는 방식이 다를 수 있음

### 옵티마이저의 한계
- 옵티마이저 팩터의 부족
- 통계정보의 부정확성
- 비현실적인 가정
- 규칙에 의존하는 CBO
- 하드웨어 성능

### 통계정보를 이용한 비용계산의 원리
- 실행계획을 수립할 때 CBO는 SQL문장에서 액세스할 데이터의 특성을 고려하기 위해 통계정보를 이용함
- 최적의 실행계획을 위해 통계정보가 항상 데이터 상태를 정확하게 반영하고 있어야 하는 이유
- DBMS버전이 올라갈수록 자동 통계관리방식으로 바뀌고 있지만, 가끔 DB관리자가 수동으로 수집관리해 주어야 할 때도 있음
- 옵티마이저가 참조하는 통계정보 종류로 네가지가 있음
  - 테이블 통계
  - 인덱스 통계
  - 칼럼 통계
  - 시스템 통계
- 선택도
  - 전체 대상 레코드 중에서 특정 조건에 의해 선택될 것으로 예상되는 레코드 비용
  - 선택도를 가지고 카디널리티를 구하고 다시 비용을 구해 인덱스 사용 여부, 조인 순서와 방법 등을 결정하므로 선택도는 최적의 실행계획을 수립하는데 있어 가장 중요한 요인
  - 선택도 = 1/Distinct Value= 1/num distinct

### 카디널리티
- 카디널리티는 특정 액세스 단계를 거치고 난 후 출력될 것으로 예상되는 결과 건수를 말하며, 아래와 같이 총 로우수에 선택도를 곱해서 구함
  - 카디널리티 = 총 로우수 * 선택도 칼럼 히스토그램이 있을 때 '='조건에 대한 선택도가 1/num_distinct이므로 카디널리티는 아래와 같이 구해짐
  - 카디널리티 = 총 로우수 * 선택도 = num_rows/ num_disticnt
  - SELECT * FROM 사원 WHERE 부서 = :부서

### 히스토그램
- 미리 저장된 히스토그램 정보가 있으면, 옵티마이저는 그것을 사용해 더 정확하게 카디널리티를 구할 수 있음
- 특히 분포가 균일하지 않은 칼럼으로 조회할 때 효과를 발휘함
- 히스토그램에는 아래 두가지 유형이 있음
  - 도수분포 히스토그램
  - 높이균형 히스토그램

### 비용
- CBO는 비용을 기반으로 최적화를 수행하고 실행 계확을 생성한다고 설명
- 여기서 비용이란 쿼리를 수행하는데 소요되는 일량 또는 시간을 뜻함
- 어디까지나 예상치임
- 옵티마이저 비용 모델에는 I/O 비용 모델 두가지가 있음
- I/O 비용 모델은 예상되는 I/O 요청 횟수만을 쿼리 수행 비용으로 간주해 실행계획을 평가하는 반면 CPU 비용 모델은 여기에 시간 개념을 더해 비용을 산정함
- 지면 관계상 본서는 I/O비용 모델만 다룸

#### 인덱스를 경유한 테이블 액세스 비용
- blevel
  - 브랜치 레벨을 의미, 리프 블록에 도달하기 전에 읽게 될 브랜치 블록 개수
- 클러스터링 팩터
  - 특정 칼럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도, 인덱스를 경유해 테이블 전체 로우를 액세스 할 때 읽을 것으로 예상되는 논리적인 블록 개수로 개수화
- 유효 인덱스 선택도
  - 전체 인덱스 레코드 중에서 조건절을 만족하는 레코드를 찾기 위해 스캔할 것으로 예상되는 비율, 리프 블록에는 인덱스 레코드가 정렬된 상태로 저장되므로 이 비율이 곧 방문할 리프 블록 비율
- 유효 테이블 선택도
  - 전체 레코드 중에서 인덱스 스캔을 완료하고서 최종적으로 테이블을 방문할 것으로 예상되는 비율, 클러스터링 팩터는 인덱스를 경유해 전체 로우 를 액세스할 때 읽힐 것으로 예상되는 테이블 블록 개수이므로 여기에 유효 테이블 선택도를 곱함으로써 조건절에 대해 읽힐 것으로 예상되는 테이블 블록 개수를 구할 수 있음


### 옵티마이저
- 통계정보가 정확하지 않거나 기타 다른 이유로 옵티마이저가 잘못된 판단을 할 수 있음
- 그럴 때 프로그램이나 데이터 특성 정보를 정확히 알고 있는 개발자가 직접 인덱스를 지정하거나 조인 방식으로 변경함으로써 더 좋은 실행계획으로 유도하는 매커니즘이 필요한데, 옵티마이저 힌트가 그거임
- 힌트 종류와 구체적인 사용법은 DBMS마다 천차만별이며, 지면 관계상 모두 다를 수 있으므로 Oracle과 SQL Server에 대해서만 설명하기로 함

#### 오라클 힌트
- 힌트 기술 방법
  - 예시
  ```
  SELECT /*힌트의 종류(해당하는테이블1, 2, 3...)*/
  ```
- 힌트가 무시되는 경우
  - 다음과 같은 경우에 Oracle 옵티마이저는 힌트를 무시하고 최적화를 진행함
    - 문법적으로 안 맞게 힌트를 줌
    - 의미적으로 안 맞게 힌트를 기술
    - 예를 들어 서브쿼리에 unnest와 push_subq를 같이 기술한 경우(unnest되지 않는 서브쿼리만이 Push_subq)힌트의 적용 대상자임
  - 잘못된 참조 사용
    - 이곳은 테이블이나 별칭을 사용하거나, 인덱스명을 지정한 경우 등 논리적으로 불가능한 액세스 경로
    - 조인절에 등치 조건이 하나도 없는데 hash JoiN으로 유도하거나 아래 처럼 null 허용칼럼에 대한 인덱스를 이용해 전체 건수를 세려고 시도하는 등

#### 자주 사용하는 힌트

### 쿼리 변환이란?
- 쿼리 변환은 옵티마이저가 SQL을 분석해 의미적으로 통일하면서도 더 나은 성능이 기대되는 형태로 재작성하는 것
- 이는 본격적으로 실행 계획을 생성하고 비용을 계산하기 앞서 사용자 SQL을 최적화에 유리한 형태로 재작성하는 것으로서, DBMS 버전이 올라갈수록 그 종류가 다양해짐은 물론, 더 적극적인 시도가 이루어 지고 있음
- 비용 기반 옵티마이저의 서브 엔진으로서 Query Transfomer, Estimator, Plan Generator 가 있다고 설명했는데, 이 중 Query Transforme가 그런역할을 담당
- 쿼리 변환은 두가지 방식으로 작동
  - 휴리스틱 쿼리 변환 : 결과만 보장된다면 무조건 쿼리 변환을 수행 일종의 규칙 기반 최적화 기법
  - 비용기반 쿼리 변환 : 변환된 쿼리의 비용이 더 낮을 때만 그것을 사용하고, 그렇지 않을 때는 원본 쿼리 그대로 두고 최적화를 수행

### 서브쿼리 Unnesting
- 서브쿼리 Unnesting 은 중첩된 서브쿼리를 풀어내는 것을 말함
- 서브쿼리를 메인쿼리와 같은 레벨로 풀어낸다면 다양한 액세스 경로와 조인 메소드를 평가할 수 있음
- 특히 옵티마이저는 많은 조인테크닉을 가지기 때문에 조인형태로 변환했을 떄 더 나은 실행계획을 찾을 가능성이 높아짐

### 뷰 Merging
- 뷰를 Merging할 때 쿼리 수행 비율이 더 낮아지는지를 조사한 후에 적용 여부를 판단하는 폭으로 옵티마이저가 발전하고 있음
- 가급적 옵티마이저의 판단과 기능에 의존하는 것이 좋으나, 필요하다면 개발자가 이를 직접 조정할 줄도 알아야 함
- Oracle의 경우 이 기능을 제어할 수 있도록 Merge와 no_merge 힌트를 제공하는데, 이를 사용하기 앞서 실행계획을 통해 VIEW Merging이 발생했는지 그리고 그것이 적정한지를 판단하는 능력이 더 중요함

### 조건절 Pushing
- 옵티마이저가 뷰를 처리함에 있어 1차적으로 뷰 Merging을 고려하지만, 조건절 Pushing을 시도할 수도 있음
- 이는 뷰를 참조하는 쿼리 블록의 조건절을 뷰 쿼리 블록 안으로 밀어 넣는 기능을 말함
- 조건절이 가능한 빨리 처리되도록 뷰 안으로 밀어 넣는다면 뷰 안에서의 처리 일량을 최소화하게 됨은 물론 리턴되는 결과 건수를 줄임으로 다음 단계에서 처리해야 할 일량을 줄일 수 있음
- 조건절 Pushing과 관련해 DBMS가 사용하는 기술로는 다음 3가지가 있음
  - 조건절 Pushdown : 쿼리 블록 밖에 있는 조건절을 쿼리 블록 안쪽으로 밀어 넣는 것을 말함
  - 조건절 Pullup : 쿼리 블록 안에 있는 조건절을 쿼리 블록 밖으로 내오는 것을 말하며, 그것을 다시 다른 쿼리 블록에 Pushdown하는 데 사용
  - 조인 조건 Pushdown : NL join 수행 중에 드라이빙 테이블에서 읽은 값을 건건이 inner쪽 뷰 쿼리 블록 안으로 밀어 넣는 것을

#### 조건절 Pushdown
- group by 절을 포함한 아래 뷰를 처리할 때, 쿼리 블록 밖에 있는 조건절을 쿼리 블록 안쪽에 밀어 넣을 수 있다면 group by 해야 할 데이터량을 줄일 수 있음
- 인덱스 상황에 따라서 더 효과적인 인덱스선택이 가능해지기는 함
- 위 쿼리에 정의한 뷰 내부에는 조건절이 하나도 없음
- 만약 쿼리 변환이 작동하지 않는다면 emp 테이블을 Full Scan 하고서 Group by 이후에 deptno = 30 조건을 필터링 했을 것
- 하지만 조건절 pushing이 작동함으로 emp_deptno_idx 인덱스를 사용한 것을 실행계획에서 볼 수 있음

#### 조건절 pullup
- 조건절을 쿼리 블록 안으로 밀어 넣을 뿐 아니라 안쪽에 있는 조건들을 바깥 쪽으로 끄집어 내기도 하는데, 이를 조건절 Pullup이라고 함
- 그리고 그것을 다시 다른 쿼리 블록에 Pushdown 하는 데 사용함

#### 조인조건 pushdown
- 조인 조건은 말 그대로 조인 조건절을 뷰 쿼리 블록 안으로 밀어 넣는 것, NL Join 수행 중에 드라이빙 테이블에서 읽은 조인 칼럼 값을 inner 쪽 뷰 쿼리 블록 내에서 참조할 수 있도록 하는 기능
- 아래 실행계획에서 group by 절을 포함한 뷰를 액세스 하는 단계에서 view pushed predicate오퍼레이션이 나타남
- 그 아래 쪽에 emp_deptno_idx 인덱스가 사용된 것을 볼 수 있는데, 이는 dept 테이블로부터 넘겨진 deptNo에 대해서만 group by 를 수행함을 의미함

#### 조건절 이행
- 조건절 이행을 한마디로 요약하면 (A=B이고 B=C이면 A=C이다.)라는 추론을 통해 새로운 조건절을 내부적으로 생성해 주는 쿼리 변환임
- (A>B이고 B>C이면 A>C이다)와 같은 추론도 가능
- 예를들어 A테이블에 사용된 필터 조건이 조인 조건절을 타고 반대편 B테이블에 대한 필터 조건으로 이행될 수 있음
- 한 테이블 내에서도 두 칼럼간 관계 정보를 이용해 조건절이 이행됨

#### 불필요한 조인 제거
- 1:M관계인 두 테이블을 조인하는 쿼리문에서 조인문을 제외한 어디에서도 1쪽 테이블을 참조하지 않는다면, 쿼리 수행 시 1쪽 테이블은 읽지 않아도 됨
- 결과 집합에 영향을 미치지 않기 때문 옵티마이저는 이 특성을 이용해 M쪽 테이블만 읽도록 쿼리를 변환하는데, 이를 '조인제거'또는'테이블 제거'라고 함

#### OR조건을 Union으로 변환
- 아래 쿼리가 그대로 수행된다면 OR조건이므로 Full Table Scan으로 처리될 것
- 만약 Job과 Deptno에 각각 생성된 인덱스를 사용하고 싶다면 아래와 같이 Union all 형태로 바꿔주면 됨
- 사용자가 쿼리를 직접 바꿔주지 않아도 옵티마이저가 이런 작업을 대신해 주는 경우가 있는데, 이를 'OR-Expansion'이라고 함

#### 기타 쿼리 변환
- 집합연산을 조인으로 변환
  - Intersect나 Minus같은 집합 연산을 조인 형태로 변환하는 것을 말함
  - Oracle의 sys_p_map_nonnull 함수는 비공식적인 하뭇나, 가끔 유용하게 사용할 수 있음 null값끼리의 '='비교하면 false지만 true가 되도록 처리해야 하는 경우가 있고, 그럴 때 이 함수를 사용하면 됨
- 조인 칼럼에 Is Not Null조건 추가
  - 조인칼럼 deptno가 Null인 데이터는 조인 액세스가 불필요함
  - 어차피 조인에 실패하기 때문
  - 따라서 아래와 같이 필터 조건을 추가하면 불필요한 테이블 액세스 및 조인 시도를 줄일 수 있어 쿼리 성능 향상에 도움이 됨
  - is Not null 조건을 사용자가 직접 기술하지 않더라도 옵티마이저가 필요하다고 판단되면 내부적으로 추가해 줌
- 필터 조건 추가
  - 아래와 같이 바인드 변수로 between 검색하는 쿼리가 있다고 하면, 쿼리를 수행할 때 사용자가 :mx 보다 :mn 변수에 더 큰 값을 입력한다면 쿼리 결과는 공집합
  - 사전에 두 값을 비교해 알수 있음에도 쿼리를 실제 수행하고서야 공집합을 출력한다면 매우 비합리적
  - 잦은 일은 아니겠지만 초대용량 테이블을 조회하면서 사용자가 값을 거꾸로 입력하는 경우를 상상해본다
  - Oracle 9부터 이를 방지하려고 옵티마이저가 임의로 필터 조건식을 추가해 줌
  - 아래 실행계획에서 1번 오퍼레이션 단계에 사용된 Filter Predicate 정보를 확인
- 조건절 비교 순서
  - B칼럼에 대한 조건식을 먼저 평가하는 것이 유리
  - 왜냐면 대부분 레코드가 B=1000 조건을 만족하지 않아 A칼럼에 대한 비교 연산읏 수행하지 않아도 되기 때문
  - DBMS 또는 버전에 따라 다르지만, 예전 옵티마이저는 where 절에 기술된 순서 또는 반대 순서로 처리하는 내부 규칙을 따름으로 비효율을 야기하곤 했음
  - 하지만 최신 옵티마이저는 비교 연산해야할 일량을 고려해 선택도가 낮은 칼럼의 조건식부터 처리하도록 내부적으로 순서를 조정함

## 인덱스와 조인
### 인덱스 구조

#### 인덱스 기본
- 모든 DBMS는 나름의 다양한 인덱스를 제공하는데, 저장 방식과 구조, 탐색 알고리즘이 조금씩 다르긴 해도 원하는 데이터를 빨리 찾도록 돕는다는 근본적인 목적은 같음
- 여기서 가장 일반적으로 사용되는 BTree 인덱스 구조부터 살펴본다
- 좀 더 다양한 인덱스 구조는 위에서 보게 될 것

1. B-Tree 인덱스
- 이름에서 알수 있듯 B-Tree 인덱스는 나뭇잎으로 무성한 나무를 뒤집어 놓은 듯한 모습임
- 나무를 뒤집어 놓았으므로 맨 위쪽 뿌리에서부터 가지를 거쳐 맨 아래 나뭇닢까지 연결되는 구조
- 처음에는 단 하나의 루트 블록에서 시작하겠지만 데이터가 점점 쌓이면서 루트 브랜치 리프 노드를 모두 갖춘 풍성한 나무로 성장
- 중간에 물론 루트와 리프만으로 구성된 2단계 구조를 거침
- 참고로 루트에서 리프 블록까지의 거리를 인덱스 깊이라고 부르며, 인덱스를 반복적으로 탐색할 때 성능에 영향을 미침
- 루트와 브랜치 블록은 각 하위 노드들의 데이터 값 범위를 찾아가는데 필요한 주소 정보를 가짐
- 키 값이 같을 때는 ROWID순으로 정렬된다는 사실도 기억하길 바람
- 정뱡향과 역방향 스캔이 둘다 가능하도록 양방향 연결 리스트 구조로 연결 돼 있음
- 아래는 null 값을 인덱스에 저장하는데 있어 Oracle과 SQL Server의 차이점을 설명한 것
  - Oracle에서 인덱스 구성 칼럼이 모두 Null인 레코드는 인덱스에 저장하지 않음. 반대로 말하면 인덱스 구성 칼럼 중 하나라도 Null 값이 아닌 레코드는 인덱스에 저장함
  - SQL Server는 인덱스 구성 칼럼이 모두 null 인 레코드도 인덱스에 저장함
  - null 값을 Oracle은 맨 뒤에 저장하고 SQL Server는 맨 앞에 저장함
- Null값을 처리하는 방식이 이처럼 DBMS마다 다르고 이런 특성이 Null 값 조회에 인덱스가 사용될 수 있는지를 결정하므로, 인덱스를 설계하거나 SQL을 개발할 때 반드시 숙지하길 바람

#### 인덱스 탐색
- 인덱스 탐색 과정을 수직적 탐색과 수평적 탐색으로 나눠서 설명할 수 있음
- 수평적 탐색은 인덱스 리프 블록에 저장된 레코드끼리 연결된 순서에 따라 좌에서 우, 또는 우에서 좌로 스캔하기 때문에 '수평적'이라고 표현함
- 수직적 탐색은 수평적 탐색을 위한 시작 지점을 찾는 과정이라고 할 수 있으며, 루트에서 리프 블록까지 아래쪽으로 진행하기 떄문에 수직적임

#### 다양한 인덱스 스캔 방식
1. Index Range Scan
  - 인덱스 루트 블록에서 리프 블로갂지 수직적으로 탐색한 후에 리프 블록을 필요한 범위만 스캔하는 방식
  - B*Tree 인덱스의 가장 일반적이고 정상적인 형태의 액세스 방식이라고 할 수 있다
  - 인덱스를 수직적으로 탐색한 후에 리프 블록에서 필요한 범위만 스캔한다고 하는데, 이는 범위 스캔이 의미하는 바를 잘 설명해주고 있음
  - 데이터베이스 프로그래밍에 경험이 많지 않은 초보 개발자는 대개 인덱스가 사용되는 실행계획을 보면 자신이 작성한 SQL문에 문제가 없다고 판단하고 일단 줄일 수 있으냐, 그리고 테이블을 액세스하는 횟수를 얼마만큼 줄일 수 있느냐가 관건
  - 이는 인덱스 설계와 SQL 튜닝의 핵심 원리중 하나
  - Index Range Scan이 가능하게 하려면 인덱스를 구성하는 선두 컬럼이 조거절에 사용되어야 함
  - 그렇지 못한 상태에서 인덱스를 사용하도록 힌트를 강제한다면, 바로 이어서 설명한 Index Full Scan 방식으로 처리됨
  - Index Range Scan 과정을 거쳐 생성된 결과 집합은 인덱스 칼럼 순으로 정렬된 상태가 되기 때문에 이런 특징을 잘 이용하면 sort order by 연산을 생략하거나 min/max 값을 빠르게 추출할 수 있음

2. Index Full Scan
  - index full scan은 수직적 탐색 없이 인덱스 리프 블록을 처음부터 끄탂지 수평적으로 탐색하는 방식으로, 대개는 데이터 검색을 위한 최적의 인덱스가 없을 때 차선으로 선택됨
