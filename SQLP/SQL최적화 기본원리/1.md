## 1. 옵티마이저
- 사용자가 질의한 SQL문에 대해 최적의 실행방안을 결정하는 역할
- 최적의 실행방법을 실행계획이라고 함
- 관계형 데이터베이스에서 궁극적으로 SQL문을 통해서만 데이터를 처리할 수 있다.
- JAVA, C 등과 가은 프로그램 언어와는 달리 SQL은 사용자의 요구사항만 기술할 뿐 처리과정에 대한 기술은 하지 않는다.
- 사용자의 요구사항을 만족하는 결과를 추출하는 다양한 실행방법이 존재
- 다양한 실행 방법들 중에 최적의 실행방법을 결정하는 것이 바로 옵티마이저의 역할임
- 관계형 데이터베이스는 옵티마이저가 결정한 실행방법대로 실행 엔진이 데이터를 처리하여 결과 데이터을 사용자에게 전달할 뿐임
- 옵티마이저가 선택한 실행방법의 적절성 여부는 질의의 수행 속도에 가장 큰 영향을 미치게 함
- 이런 의미에서 관계형 데이터베이스에서 진정한 프로그래머는 옵티마이저이다.
- 최적의 실행방법 결정이라는 어떤 방법으로 처리하는 것이 최소 일량으로 동일한 일을 처리할 수 있을지 결정하는 것과 똑같음
- 이러한 결정을 옵티마이저는 실제로 SQL문을 처리해보지 않은 상태에서 결정해야하는 어려움이 있음
- 옵티마이저가 최적의 실행방법을 결정하는 방식에 따라 규칙기반 혹은 비용기반으로 구분한다.

### 1.1 규칙기반 옵티마이저
- 규칙을 가지고 실행계획을 생성한다.
- 실행계획을 생성하는 규칙을 이해하면 누구나 실행계획을 비교적 쉽게 예측할 수 있다.
- 규칙기반 옵티마이저가 실행계획을 생성할 때 참조하는 정보에는 SQL문을 실행하기 위해서 이용 가능한 인덱스유무(유이르 비유일, 단일, 복합 인덱스) 종류, SQL문에서 사용하는 연산자(=,<,>,<>,LIKE, BETWEEN 등)의 종류 그리고 SQL문에서 참조하는 객체하는 객체(힙테이블, 클러스터 테이블 등)의 종류 등이 있다.
- 이러한 정보에 따라 우선 순위(규칙)이 있고, 이 우선순위를 기반으로 실행계획 생성
- 결과적으로 규칙기반 옵티마이저는 우선 순위가 높은 규칙이 적은 일량으로 해당 작업을 수행하는 방법이라고 판단하는 것
- 아래와 같이 규칙기반 옵티마이저는 15가지 방법이 존재한다.
  1. Single row by rowid
     - ROWID를 통해서 테ㅣ블에서 하나의 행을 액세스
  2. Single row by cluster join
  3. Single row by hash cluster key with unique or primary key
  4. Single row by unique or primary key
     - 유일 인덱스를 통해서 하나의 행을 엑세스하는 방법
  5. Cluster join
  6. Hash cluster key
  7. Indexed cluster key
  8. Composite index
     - 복합 인덱스에 동등 조건으로 검색하는 경우
  9.  Single cloumn index
      - 단일 컬럼 인덱스에 '=' 조건으로 검색하는 경우
  10. Bounded range search on indexed columns
      - 인덱스가 생성되어 있는 컬럼에 양쪽 범위를 한정하는 형태로 검색하는 방식
  11. Unbounded range search in indexed columns
      - 인덱스가 생성되어 있는 칼럼에 한쪽 범위만 한정하는 형태로 검색하는 방식
  12. Sort merge join
  13. MAX or MIN of indexed column
  14. ORDER BY on indexed column
  15. Full table scan
      - 전체 테이블을 액세스하면서 조건절에 주어진 조건을 만족하는 행만을 결과로 추출한다.
- 규칙기반 옵티마이저는 인덱스를 이용한 액세스 방식이 전체 테이블 엑세스보다 우선수위가 높음
- 규칙기반 옵티마이저는 해당 SQL문에서 이용 가능한 인덱스가 존재한다면 전체 테이블 액세스 방식보다는 항상 인덱스를 사용하는 실행계획을 세움
- 조인 순서를 결정할 때는 조인 칼럼 인덱스의 존재 유무가 중요한 판단의 기준이다.
- 조인 칼럼에 대한 인덱스가 양쪽 테이블에 모두 존재한다면 앞에서 설명한 규칙에 따라 우선 순위가 높은 테이블을 선행 테이블로 선택한다.

#### 1.2 비용기반 옵티마이저
- 규칙기반의 단순한 몇개의 규칙만으로 현실의 모든사항을 정확히 예측할 수 없다는 단점을 극복하기 위해 출현
- 비용기반 옵티마이저는 SQL문을 처리하는데 필요한 비용이 가장 적은 실행계획을 선택하는 방식
- 여기서 비용이란 SQL문을 처리하기 위해 예상되는 소요시간 또는 자원 사용량을 의미한다.
- 비용기반 옵티마이저는 비용을 예측하기 위해서 규칙기반 옵티마이저가 사용하지 않는 테이블, 인덱스, 칼럼 등의 다양한 객체 통계 정보와 시스템 통계 정보 등을 이용

#### SQL 최적화 및 수행 과정
1. SQL 파싱 -> Parsed SQL
2. 옵티마이저로 실행계확 만들기
   1. 이때 쿼리 변환
   2. 계확 정의
3. 소스 실행기
   1. 옵티마이저가 생성한 실행계확을 SQL엔진이 실제 시행할 수 있는 코드 형태로 포맷팅함
4. SQL Engine
   1. SQL을 실행함

### 최적화의 목표
1. 전체 처리속도 최적화
   1. 쿼리 최종 결과집합을 끝까지 읽는 것을 전제로 시스템리소스를 가장 적게 사용하는 실행계획을 선택함
   2. 예시
   ``` 
    alter system optimizer_mode = all_rows - 시스템 레벨 변경
    alter session set optimizer_mode = all_rows - 세션 레벨 변경
    
   ```
2. 최초 응답속도 최적화
   1. 전체 결과 집합 중 일부만 읽다가 멈추는 것을 전제로 가장 빠른 응답속도를 낼 수 있는 실행계획을 선택함
   2. 만약 이 모드에서 생성한 실행계획으로 데이터를 끝까지 읽는다면 전체 처리속도 최적화를 실행계획보다 더 나은 리소스를 사용하고 전체 수행속도도 느려질 수 있음
   3. oracle에서 옵티마이저 모드를 first_rows_n으로 저장하면, 예를 들어 시스템 또는 세션 레벨에서 first_rows_10으로 지정하면 사용자가 전체 결과집합 중 처음 10개 로우만 읽고  멈추는 것을 전제로 가장 빠른 응답 속도를 낼 수 있는 실행계획을 선택함

### 옵티마이저 행동에 영향을 미치는 요소
- SQL과 연산자 형태
  - 결과가 같더라도 SQL을 어떤 형태로 작성하였는지 또는 어떤 연산자를 사용 하였는지에 따라 옵티마이저가 다른 선택을 할 수 있고, 이는 쿼리 성능에 영향을 미침
- 옵티마이징 팩터
  - 쿼리를 똑같이 작성하더라도 인덱스, IOT, 클러스터링, 파티셔닝, MV등을 어떻게 구성하는지에 따라 실행계획과 성능이 크게 달라짐
- DBMS 제약 설정
- 옵티마이저 힌트
- 통계 정보
- 옵티마이저 관련 파라미터
- DBMS버전과 종류
  - 옵티마이저 관련 파라미터가 같더라도 버전에 따라 실행 계획이 다를 수 있음
  - 또한 같은 SQL이더라도 DBMS종류에 따라 내부적으로 처리하는 방식이 다를 수 있음

### 옵티마이저의 한계
- 옵티마이저 팩터의 부족
- 통계정보의 부정확성
- 비현실적인 가정
- 규칙에 의존하는 CBO
- 하드웨어 성능

### 통계정보를 이용한 비용계산의 원리
- 실행계획을 수립할 때 CBO는 SQL문장에서 액세스할 데이터의 특성을 고려하기 위해 통계정보를 이용함
- 최적의 실행계획을 위해 통계정보가 항상 데이터 상태를 정확하게 반영하고 있어야 하는 이유
- DBMS버전이 올라갈수록 자동 통계관리방식으로 바뀌고 있지만, 가끔 DB관리자가 수동으로 수집관리해 주어야 할 때도 있음
- 옵티마이저가 참조하는 통계정보 종류로 네가지가 있음
  - 테이블 통계
  - 인덱스 통계
  - 칼럼 통계
  - 시스템 통계
- 선택도
  - 전체 대상 레코드 중에서 특정 조건에 의해 선택될 것으로 예상되는 레코드 비용
  - 선택도를 가지고 카디널리티를 구하고 다시 비용을 구해 인덱스 사용 여부, 조인 순서와 방법 등을 결정하므로 선택도는 최적의 실행계획을 수립하는데 있어 가장 중요한 요인
  - 선택도 = 1/Distinct Value= 1/num distinct