## 1. 옵티마이저
- 사용자가 질의한 SQL문에 대해 최적의 실행방안을 결정하는 역할
- 최적의 실행방법을 실행계획이라고 함
- 관계형 데이터베이스에서 궁극적으로 SQL문을 통해서만 데이터를 처리할 수 있다.
- JAVA, C 등과 가은 프로그램 언어와는 달리 SQL은 사용자의 요구사항만 기술할 뿐 처리과정에 대한 기술은 하지 않는다.
- 사용자의 요구사항을 만족하는 결과를 추출하는 다양한 실행방법이 존재
- 다양한 실행 방법들 중에 최적의 실행방법을 결정하는 것이 바로 옵티마이저의 역할임
- 관계형 데이터베이스는 옵티마이저가 결정한 실행방법대로 실행 엔진이 데이터를 처리하여 결과 데이터을 사용자에게 전달할 뿐임
- 옵티마이저가 선택한 실행방법의 적절성 여부는 질의의 수행 속도에 가장 큰 영향을 미치게 함
- 이런 의미에서 관계형 데이터베이스에서 진정한 프로그래머는 옵티마이저이다.
- 최적의 실행방법 결정이라는 어떤 방법으로 처리하는 것이 최소 일량으로 동일한 일을 처리할 수 있을지 결정하는 것과 똑같음
- 이러한 결정을 옵티마이저는 실제로 SQL문을 처리해보지 않은 상태에서 결정해야하는 어려움이 있음
- 옵티마이저가 최적의 실행방법을 결정하는 방식에 따라 규칙기반 혹은 비용기반으로 구분한다.

### 1.1 규칙기반 옵티마이저
- 규칙을 가지고 실행계획을 생성한다.
- 실행계획을 생성하는 규칙을 이해하면 누구나 실행계획을 비교적 쉽게 예측할 수 있다.
- 규칙기반 옵티마이저가 실행계획을 생성할 때 참조하는 정보에는 SQL문을 실행하기 위해서 이용 가능한 인덱스유무(유이르 비유일, 단일, 복합 인덱스) 종류, SQL문에서 사용하는 연산자(=,<,>,<>,LIKE, BETWEEN 등)의 종류 그리고 SQL문에서 참조하는 객체하는 객체(힙테이블, 클러스터 테이블 등)의 종류 등이 있다.
- 이러한 정보에 따라 우선 순위(규칙)이 있고, 이 우선순위를 기반으로 실행계획 생성
- 결과적으로 규칙기반 옵티마이저는 우선 순위가 높은 규칙이 적은 일량으로 해당 작업을 수행하는 방법이라고 판단하는 것
- 아래와 같이 규칙기반 옵티마이저는 15가지 방법이 존재한다.
  1. Single row by rowid
     - ROWID를 통해서 테ㅣ블에서 하나의 행을 액세스
  2. Single row by cluster join
  3. Single row by hash cluster key with unique or primary key
  4. Single row by unique or primary key
     - 유일 인덱스를 통해서 하나의 행을 엑세스하는 방법
  5. Cluster join
  6. Hash cluster key
  7. Indexed cluster key
  8. Composite index
     - 복합 인덱스에 동등 조건으로 검색하는 경우
  9.  Single cloumn index
      - 단일 컬럼 인덱스에 '=' 조건으로 검색하는 경우
  10. Bounded range search on indexed columns
      - 인덱스가 생성되어 있는 컬럼에 양쪽 범위를 한정하는 형태로 검색하는 방식
  11. Unbounded range search in indexed columns
      - 인덱스가 생성되어 있는 칼럼에 한쪽 범위만 한정하는 형태로 검색하는 방식
  12. Sort merge join
  13. MAX or MIN of indexed column
  14. ORDER BY on indexed column
  15. Full table scan
      - 전체 테이블을 액세스하면서 조건절에 주어진 조건을 만족하는 행만을 결과로 추출한다.
- 규칙기반 옵티마이저는 인덱스를 이용한 액세스 방식이 전체 테이블 엑세스보다 우선수위가 높음
- 규칙기반 옵티마이저는 해당 SQL문에서 이용 가능한 인덱스가 존재한다면 전체 테이블 액세스 방식보다는 항상 인덱스를 사용하는 실행계획을 세움
- 조인 순서를 결정할 때는 조인 칼럼 인덱스의 존재 유무가 중요한 판단의 기준이다.
- 조인 칼럼에 대한 인덱스가 양쪽 테이블에 모두 존재한다면 앞에서 설명한 규칙에 따라 우선 순위가 높은 테이블을 선행 테이블로 선택한다.

#### 1.2 비용기반 옵티마이저
- 규칙기반의 단순한 몇개의 규칙만으로 현실의 모든사항을 정확히 예측할 수 없다는 단점을 극복하기 위해 출현
- 비용기반 옵티마이저는 SQL문을 처리하는데 필요한 비용이 가장 적은 실행계획을 선택하는 방식
- 여기서 비용이란 SQL문을 처리하기 위해 예상되는 소요시간 또는 자원 사용량을 의미한다.
- 비용기반 옵티마이저는 비용을 예측하기 위해서 규칙기반 옵티마이저가 사용하지 않는 테이블, 인덱스, 칼럼 등의 다양한 객체 통계 정보와 시스템 통계 정보 등을 이용

#### SQL 최적화 및 수행 과정
1. SQL 파싱 -> Parsed SQL
2. 옵티마이저로 실행계확 만들기
   1. 이때 쿼리 변환
   2. 계확 정의
3. 소스 실행기
   1. 옵티마이저가 생성한 실행계확을 SQL엔진이 실제 시행할 수 있는 코드 형태로 포맷팅함
4. SQL Engine
   1. SQL을 실행함

### 최적화의 목표
1. 전체 처리속도 최적화
   1. 쿼리 최종 결과집합을 끝까지 읽는 것을 전제로 시스템리소스를 가장 적게 사용하는 실행계획을 선택함
   2. 예시
   ``` 
    alter system optimizer_mode = all_rows - 시스템 레벨 변경
    alter session set optimizer_mode = all_rows - 세션 레벨 변경
    
   ```
2. 최초 응답속도 최적화
   1. 전체 결과 집합 중 일부만 읽다가 멈추는 것을 전제로 가장 빠른 응답속도를 낼 수 있는 실행계획을 선택함
   2. 만약 이 모드에서 생성한 실행계획으로 데이터를 끝까지 읽는다면 전체 처리속도 최적화를 실행계획보다 더 나은 리소스를 사용하고 전체 수행속도도 느려질 수 있음
   3. oracle에서 옵티마이저 모드를 first_rows_n으로 저장하면, 예를 들어 시스템 또는 세션 레벨에서 first_rows_10으로 지정하면 사용자가 전체 결과집합 중 처음 10개 로우만 읽고  멈추는 것을 전제로 가장 빠른 응답 속도를 낼 수 있는 실행계획을 선택함

### 옵티마이저 행동에 영향을 미치는 요소
- SQL과 연산자 형태
  - 결과가 같더라도 SQL을 어떤 형태로 작성하였는지 또는 어떤 연산자를 사용 하였는지에 따라 옵티마이저가 다른 선택을 할 수 있고, 이는 쿼리 성능에 영향을 미침
- 옵티마이징 팩터
  - 쿼리를 똑같이 작성하더라도 인덱스, IOT, 클러스터링, 파티셔닝, MV등을 어떻게 구성하는지에 따라 실행계획과 성능이 크게 달라짐
- DBMS 제약 설정
- 옵티마이저 힌트
- 통계 정보
- 옵티마이저 관련 파라미터
- DBMS버전과 종류
  - 옵티마이저 관련 파라미터가 같더라도 버전에 따라 실행 계획이 다를 수 있음
  - 또한 같은 SQL이더라도 DBMS종류에 따라 내부적으로 처리하는 방식이 다를 수 있음

### 옵티마이저의 한계
- 옵티마이저 팩터의 부족
- 통계정보의 부정확성
- 비현실적인 가정
- 규칙에 의존하는 CBO
- 하드웨어 성능

### 통계정보를 이용한 비용계산의 원리
- 실행계획을 수립할 때 CBO는 SQL문장에서 액세스할 데이터의 특성을 고려하기 위해 통계정보를 이용함
- 최적의 실행계획을 위해 통계정보가 항상 데이터 상태를 정확하게 반영하고 있어야 하는 이유
- DBMS버전이 올라갈수록 자동 통계관리방식으로 바뀌고 있지만, 가끔 DB관리자가 수동으로 수집관리해 주어야 할 때도 있음
- 옵티마이저가 참조하는 통계정보 종류로 네가지가 있음
  - 테이블 통계
  - 인덱스 통계
  - 칼럼 통계
  - 시스템 통계
- 선택도
  - 전체 대상 레코드 중에서 특정 조건에 의해 선택될 것으로 예상되는 레코드 비용
  - 선택도를 가지고 카디널리티를 구하고 다시 비용을 구해 인덱스 사용 여부, 조인 순서와 방법 등을 결정하므로 선택도는 최적의 실행계획을 수립하는데 있어 가장 중요한 요인
  - 선택도 = 1/Distinct Value= 1/num distinct

### 카디널리티
- 카디널리티는 특정 액세스 단계를 거치고 난 후 출력될 것으로 예상되는 결과 건수를 말하며, 아래와 같이 총 로우수에 선택도를 곱해서 구함
  - 카디널리티 = 총 로우수 * 선택도 칼럼 히스토그램이 있을 때 '='조건에 대한 선택도가 1/num_distinct이므로 카디널리티는 아래와 같이 구해짐
  - 카디널리티 = 총 로우수 * 선택도 = num_rows/ num_disticnt
  - SELECT * FROM 사원 WHERE 부서 = :부서

### 히스토그램
- 미리 저장된 히스토그램 정보가 있으면, 옵티마이저는 그것을 사용해 더 정확하게 카디널리티를 구할 수 있음
- 특히 분포가 균일하지 않은 칼럼으로 조회할 때 효과를 발휘함
- 히스토그램에는 아래 두가지 유형이 있음
  - 도수분포 히스토그램
  - 높이균형 히스토그램

### 비용
- CBO는 비용을 기반으로 최적화를 수행하고 실행 계확을 생성한다고 설명
- 여기서 비용이란 쿼리를 수행하는데 소요되는 일량 또는 시간을 뜻함
- 어디까지나 예상치임
- 옵티마이저 비용 모델에는 I/O 비용 모델 두가지가 있음
- I/O 비용 모델은 예상되는 I/O 요청 횟수만을 쿼리 수행 비용으로 간주해 실행계획을 평가하는 반면 CPU 비용 모델은 여기에 시간 개념을 더해 비용을 산정함
- 지면 관계상 본서는 I/O비용 모델만 다룸

#### 인덱스를 경유한 테이블 액세스 비용
- blevel
  - 브랜치 레벨을 의미, 리프 블록에 도달하기 전에 읽게 될 브랜치 블록 개수
- 클러스터링 팩터
  - 특정 칼럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도, 인덱스를 경유해 테이블 전체 로우를 액세스 할 때 읽을 것으로 예상되는 논리적인 블록 개수로 개수화
- 유효 인덱스 선택도
  - 전체 인덱스 레코드 중에서 조건절을 만족하는 레코드를 찾기 위해 스캔할 것으로 예상되는 비율, 리프 블록에는 인덱스 레코드가 정렬된 상태로 저장되므로 이 비율이 곧 방문할 리프 블록 비율
- 유효 테이블 선택도
  - 전체 레코드 중에서 인덱스 스캔을 완료하고서 최종적으로 테이블을 방문할 것으로 예상되는 비율, 클러스터링 팩터는 인덱스를 경유해 전체 로우 를 액세스할 때 읽힐 것으로 예상되는 테이블 블록 개수이므로 여기에 유효 테이블 선택도를 곱함으로써 조건절에 대해 읽힐 것으로 예상되는 테이블 블록 개수를 구할 수 있음


### 옵티마이저
- 통계정보가 정확하지 않거나 기타 다른 이유로 옵티마이저가 잘못된 판단을 할 수 있음
- 그럴 때 프로그램이나 데이터 특성 정보를 정확히 알고 있는 개발자가 직접 인덱스를 지정하거나 조인 방식으로 변경함으로써 더 좋은 실행계획으로 유도하는 매커니즘이 필요한데, 옵티마이저 힌트가 그거임
- 힌트 종류와 구체적인 사용법은 DBMS마다 천차만별이며, 지면 관계상 모두 다를 수 있으므로 Oracle과 SQL Server에 대해서만 설명하기로 함

#### 오라클 힌트
- 힌트 기술 방법
  - 예시
  ```
  SELECT /*힌트의 종류(해당하는테이블1, 2, 3...)*/
  ```
- 힌트가 무시되는 경우
  - 다음과 같은 경우에 Oracle 옵티마이저는 힌트를 무시하고 최적화를 진행함
    - 문법적으로 안 맞게 힌트를 줌
    - 의미적으로 안 맞게 힌트를 기술
    - 예를 들어 서브쿼리에 unnest와 push_subq를 같이 기술한 경우(unnest되지 않는 서브쿼리만이 Push_subq)힌트의 적용 대상자임
  - 잘못된 참조 사용
    - 이곳은 테이블이나 별칭을 사용하거나, 인덱스명을 지정한 경우 등 논리적으로 불가능한 액세스 경로
    - 조인절에 등치 조건이 하나도 없는데 hash JoiN으로 유도하거나 아래 처럼 null 허용칼럼에 대한 인덱스를 이용해 전체 건수를 세려고 시도하는 등

#### 자주 사용하는 힌트
<img src="./img/src/1.png" width = "200" height = "400">


#### SQL Server 힌트
- SQL Server 옵티마이저 힌트를 지정하는 방법으로는 크게 3가지가 이씅ㅁ
- 테이블 힌트
  - 테이블 명 다음 with절을 통해 지정(fastfirstrow, holdlock, nolock)등
- 조인 힌트
  - From절에 지정하며, 두 테이블 간 조인 전략에 영향을 미침, Loop, hash, merge, remote
- 쿼리 힌트
  - 쿼리당 맨 마지막에 한번만 지정할 수 있는 쿼리 힌트는 아래와 같이 option절을 이용함


### 쿼리 변환이란?
- 쿼리 변환은 옵티마이저가 SQL을 분석해 의미적으로 통일하면서도 더 나은 성능이 기대되는 형태로 재작성하는 것
- 이는 본격적으로 실행 계획을 생성하고 비용을 계산하기 앞서 사용자 SQL을 최적화에 유리한 형태로 재작성하는 것으로서, DBMS 버전이 올라갈수록 그 종류가 다양해짐은 물론, 더 적극적인 시도가 이루어 지고 있음
- 비용 기반 옵티마이저의 서브 엔진으로서 Query Transfomer, Estimator, Plan Generator 가 있다고 설명했는데, 이 중 Query Transforme가 그런역할을 담당
- 쿼리 변환은 두가지 방식으로 작동
  - 휴리스틱 쿼리 변환 : 결과만 보장된다면 무조건 쿼리 변환을 수행 일종의 규칙 기반 최적화 기법
  - 비용기반 쿼리 변환 : 변환된 쿼리의 비용이 더 낮을 때만 그것을 사용하고, 그렇지 않을 때는 원본 쿼리 그대로 두고 최적화를 수행

### 서브쿼리 Unnesting
- 서브쿼리 Unnesting 은 중첩된 서브쿼리를 풀어내는 것을 말함
- 서브쿼리를 메인쿼리와 같은 레벨로 풀어낸다면 다양한 액세스 경로와 조인 메소드를 평가할 수 있음
- 특히 옵티마이저는 많은 조인테크닉을 가지기 때문에 조인형태로 변환했을 떄 더 나은 실행계획을 찾을 가능성이 높아짐

### 뷰 Merging
- 뷰를 Merging할 때 쿼리 수행 비율이 더 낮아지는지를 조사한 후에 적용 여부를 판단하는 폭으로 옵티마이저가 발전하고 있음
- 가급적 옵티마이저의 판단과 기능에 의존하는 것이 좋으나, 필요하다면 개발자가 이를 직접 조정할 줄도 알아야 함
- Oracle의 경우 이 기능을 제어할 수 있도록 Merge와 no_merge 힌트를 제공하는데, 이를 사용하기 앞서 실행계획을 통해 VIEW Merging이 발생했는지 그리고 그것이 적정한지를 판단하는 능력이 더 중요함

### 조건절 Pushing
- 옵티마이저가 뷰를 처리함에 있어 1차적으로 뷰 Merging을 고려하지만, 조건절 Pushing을 시도할 수도 있음
- 이는 뷰를 참조하는 쿼리 블록의 조건절을 뷰 쿼리 블록 안으로 밀어 넣는 기능을 말함
- 조건절이 가능한 빨리 처리되도록 뷰 안으로 밀어 넣는다면 뷰 안에서의 처리 일량을 최소화하게 됨은 물론 리턴되는 결과 건수를 줄임으로 다음 단계에서 처리해야 할 일량을 줄일 수 있음
- 조건절 Pushing과 관련해 DBMS가 사용하는 기술로는 다음 3가지가 있음
  - 조건절 Pushdown : 쿼리 블록 밖에 있는 조건절을 쿼리 블록 안쪽으로 밀어 넣는 것을 말함
  - 조건절 Pullup : 쿼리 블록 안에 있는 조건절을 쿼리 블록 밖으로 내오는 것을 말하며, 그것을 다시 다른 쿼리 블록에 Pushdown하는 데 사용
  - 조인 조건 Pushdown : NL join 수행 중에 드라이빙 테이블에서 읽은 값을 건건이 inner쪽 뷰 쿼리 블록 안으로 밀어 넣는 것을

#### 조건절 Pushdown
- group by 절을 포함한 아래 뷰를 처리할 때, 쿼리 블록 밖에 있는 조건절을 쿼리 블록 안쪽에 밀어 넣을 수 있다면 group by 해야 할 데이터량을 줄일 수 있음
- 인덱스 상황에 따라서 더 효과적인 인덱스선택이 가능해지기는 함
- 위 쿼리에 정의한 뷰 내부에는 조건절이 하나도 없음
- 만약 쿼리 변환이 작동하지 않는다면 emp 테이블을 Full Scan 하고서 Group by 이후에 deptno = 30 조건을 필터링 했을 것
- 하지만 조건절 pushing이 작동함으로 emp_deptno_idx 인덱스를 사용한 것을 실행계획에서 볼 수 있음

#### 조건절 pullup
- 조건절을 쿼리 블록 안으로 밀어 넣을 뿐 아니라 안쪽에 있는 조건들을 바깥 쪽으로 끄집어 내기도 하는데, 이를 조건절 Pullup이라고 함
- 그리고 그것을 다시 다른 쿼리 블록에 Pushdown 하는 데 사용함

#### 조인조건 pushdown
- 조인 조건은 말 그대로 조인 조건절을 뷰 쿼리 블록 안으로 밀어 넣는 것, NL Join 수행 중에 드라이빙 테이블에서 읽은 조인 칼럼 값을 inner 쪽 뷰 쿼리 블록 내에서 참조할 수 있도록 하는 기능
- 아래 실행계획에서 group by 절을 포함한 뷰를 액세스 하는 단계에서 view pushed predicate오퍼레이션이 나타남
- 그 아래 쪽에 emp_deptno_idx 인덱스가 사용된 것을 볼 수 있는데, 이는 dept 테이블로부터 넘겨진 deptNo에 대해서만 group by 를 수행함을 의미함

#### 조건절 이행
- 조건절 이행을 한마디로 요약하면 (A=B이고 B=C이면 A=C이다.)라는 추론을 통해 새로운 조건절을 내부적으로 생성해 주는 쿼리 변환임
- (A>B이고 B>C이면 A>C이다)와 같은 추론도 가능
- 예를들어 A테이블에 사용된 필터 조건이 조인 조건절을 타고 반대편 B테이블에 대한 필터 조건으로 이행될 수 있음
- 한 테이블 내에서도 두 칼럼간 관계 정보를 이용해 조건절이 이행됨

#### 불필요한 조인 제거
- 1:M관계인 두 테이블을 조인하는 쿼리문에서 조인문을 제외한 어디에서도 1쪽 테이블을 참조하지 않는다면, 쿼리 수행 시 1쪽 테이블은 읽지 않아도 됨
- 결과 집합에 영향을 미치지 않기 때문 옵티마이저는 이 특성을 이용해 M쪽 테이블만 읽도록 쿼리를 변환하는데, 이를 '조인제거'또는'테이블 제거'라고 함

#### OR조건을 Union으로 변환
- 아래 쿼리가 그대로 수행된다면 OR조건이므로 Full Table Scan으로 처리될 것
- 만약 Job과 Deptno에 각각 생성된 인덱스를 사용하고 싶다면 아래와 같이 Union all 형태로 바꿔주면 됨
- 사용자가 쿼리를 직접 바꿔주지 않아도 옵티마이저가 이런 작업을 대신해 주는 경우가 있는데, 이를 'OR-Expansion'이라고 함

#### 기타 쿼리 변환
- 집합연산을 조인으로 변환
  - Intersect나 Minus같은 집합 연산을 조인 형태로 변환하는 것을 말함
  - Oracle의 sys_p_map_nonnull 함수는 비공식적인 하뭇나, 가끔 유용하게 사용할 수 있음 null값끼리의 '='비교하면 false지만 true가 되도록 처리해야 하는 경우가 있고, 그럴 때 이 함수를 사용하면 됨
- 조인 칼럼에 Is Not Null조건 추가
  - 조인칼럼 deptno가 Null인 데이터는 조인 액세스가 불필요함
  - 어차피 조인에 실패하기 때문
  - 따라서 아래와 같이 필터 조건을 추가하면 불필요한 테이블 액세스 및 조인 시도를 줄일 수 있어 쿼리 성능 향상에 도움이 됨
  - is Not null 조건을 사용자가 직접 기술하지 않더라도 옵티마이저가 필요하다고 판단되면 내부적으로 추가해 줌
- 필터 조건 추가
  - 아래와 같이 바인드 변수로 between 검색하는 쿼리가 있다고 하면, 쿼리를 수행할 때 사용자가 :mx 보다 :mn 변수에 더 큰 값을 입력한다면 쿼리 결과는 공집합
  - 사전에 두 값을 비교해 알수 있음에도 쿼리를 실제 수행하고서야 공집합을 출력한다면 매우 비합리적
  - 잦은 일은 아니겠지만 초대용량 테이블을 조회하면서 사용자가 값을 거꾸로 입력하는 경우를 상상해본다
  - Oracle 9부터 이를 방지하려고 옵티마이저가 임의로 필터 조건식을 추가해 줌
  - 아래 실행계획에서 1번 오퍼레이션 단계에 사용된 Filter Predicate 정보를 확인
- 조건절 비교 순서
  - B칼럼에 대한 조건식을 먼저 평가하는 것이 유리
  - 왜냐면 대부분 레코드가 B=1000 조건을 만족하지 않아 A칼럼에 대한 비교 연산읏 수행하지 않아도 되기 때문
  - DBMS 또는 버전에 따라 다르지만, 예전 옵티마이저는 where 절에 기술된 순서 또는 반대 순서로 처리하는 내부 규칙을 따름으로 비효율을 야기하곤 했음
  - 하지만 최신 옵티마이저는 비교 연산해야할 일량을 고려해 선택도가 낮은 칼럼의 조건식부터 처리하도록 내부적으로 순서를 조정함

## 인덱스와 조인
### 인덱스 구조

#### 인덱스 기본
- 모든 DBMS는 나름의 다양한 인덱스를 제공하는데, 저장 방식과 구조, 탐색 알고리즘이 조금씩 다르긴 해도 원하는 데이터를 빨리 찾도록 돕는다는 근본적인 목적은 같음
- 여기서 가장 일반적으로 사용되는 BTree 인덱스 구조부터 살펴본다
- 좀 더 다양한 인덱스 구조는 위에서 보게 될 것

1. B-Tree 인덱스
- 이름에서 알수 있듯 B-Tree 인덱스는 나뭇잎으로 무성한 나무를 뒤집어 놓은 듯한 모습임
- 나무를 뒤집어 놓았으므로 맨 위쪽 뿌리에서부터 가지를 거쳐 맨 아래 나뭇닢까지 연결되는 구조
- 처음에는 단 하나의 루트 블록에서 시작하겠지만 데이터가 점점 쌓이면서 루트 브랜치 리프 노드를 모두 갖춘 풍성한 나무로 성장
- 중간에 물론 루트와 리프만으로 구성된 2단계 구조를 거침
- 참고로 루트에서 리프 블록까지의 거리를 인덱스 깊이라고 부르며, 인덱스를 반복적으로 탐색할 때 성능에 영향을 미침
- 루트와 브랜치 블록은 각 하위 노드들의 데이터 값 범위를 찾아가는데 필요한 주소 정보를 가짐
- 키 값이 같을 때는 ROWID순으로 정렬된다는 사실도 기억하길 바람
- 정뱡향과 역방향 스캔이 둘다 가능하도록 양방향 연결 리스트 구조로 연결 돼 있음
- 아래는 null 값을 인덱스에 저장하는데 있어 Oracle과 SQL Server의 차이점을 설명한 것
  - Oracle에서 인덱스 구성 칼럼이 모두 Null인 레코드는 인덱스에 저장하지 않음. 반대로 말하면 인덱스 구성 칼럼 중 하나라도 Null 값이 아닌 레코드는 인덱스에 저장함
  - SQL Server는 인덱스 구성 칼럼이 모두 null 인 레코드도 인덱스에 저장함
  - null 값을 Oracle은 맨 뒤에 저장하고 SQL Server는 맨 앞에 저장함
- Null값을 처리하는 방식이 이처럼 DBMS마다 다르고 이런 특성이 Null 값 조회에 인덱스가 사용될 수 있는지를 결정하므로, 인덱스를 설계하거나 SQL을 개발할 때 반드시 숙지하길 바람

#### 인덱스 탐색
- 인덱스 탐색 과정을 수직적 탐색과 수평적 탐색으로 나눠서 설명할 수 있음
- 수평적 탐색은 인덱스 리프 블록에 저장된 레코드끼리 연결된 순서에 따라 좌에서 우, 또는 우에서 좌로 스캔하기 때문에 '수평적'이라고 표현함
- 수직적 탐색은 수평적 탐색을 위한 시작 지점을 찾는 과정이라고 할 수 있으며, 루트에서 리프 블록까지 아래쪽으로 진행하기 떄문에 수직적임

#### 다양한 인덱스 스캔 방식
1. Index Range Scan
  - 인덱스 루트 블록에서 리프 블로갂지 수직적으로 탐색한 후에 리프 블록을 필요한 범위만 스캔하는 방식
  - B*Tree 인덱스의 가장 일반적이고 정상적인 형태의 액세스 방식이라고 할 수 있다
  - 인덱스를 수직적으로 탐색한 후에 리프 블록에서 필요한 범위만 스캔한다고 하는데, 이는 범위 스캔이 의미하는 바를 잘 설명해주고 있음
  - 데이터베이스 프로그래밍에 경험이 많지 않은 초보 개발자는 대개 인덱스가 사용되는 실행계획을 보면 자신이 작성한 SQL문에 문제가 없다고 판단하고 일단 줄일 수 있으냐, 그리고 테이블을 액세스하는 횟수를 얼마만큼 줄일 수 있느냐가 관건
  - 이는 인덱스 설계와 SQL 튜닝의 핵심 원리중 하나
  - Index Range Scan이 가능하게 하려면 인덱스를 구성하는 선두 컬럼이 조거절에 사용되어야 함
  - 그렇지 못한 상태에서 인덱스를 사용하도록 힌트를 강제한다면, 바로 이어서 설명한 Index Full Scan 방식으로 처리됨
  - Index Range Scan 과정을 거쳐 생성된 결과 집합은 인덱스 칼럼 순으로 정렬된 상태가 되기 때문에 이런 특징을 잘 이용하면 sort order by 연산을 생략하거나 min/max 값을 빠르게 추출할 수 있음

2. Index Full Scan
  - index full scan은 수직적 탐색 없이 인덱스 리프 블록을 처음부터 끄탂지 수평적으로 탐색하는 방식으로, 대개는 데이터 검색을 위한 최적의 인덱스가 없을 때 차선으로 선택됨
  - 수직적 탐색 없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로만 탐색한다고 하는데, 이는 개념적으로 설명하기 위한 것일 뿐 실제로는 수직적 탐색이 먼저 일어남
  - 루트 블록과 브랜치 블록을 거치지 않고는 가장 왼쪽에 위치한 첫 번쨰 리프 블록을 찾아갈 방법이 없기 때문
  - 그래서 이 과정을 점선으로 표시한다
  - 인덱스 선두 컬럼이 조건절에 없으면 옵티마이저는 우선적으로 Table Full Scan을 고려
  - 그런데 대용량 테이블이어서 Table Full Scan의 부담이 크다면 옵티마이저는 인덱스를 활용하는 방법을 다시 생각해 보지 않을 수 없음
  - 데이터 저장 공간은 가로 * 세로 즉 칼럼길이 * 레코드 수에 의해 결정되므로 대개 인덱스가 차지하는 면적은 테이블보다 훨씬 적게 마련임
  - 만약 인덱스 스캔 단계에서 대부분 레코드를 필털이하고 일부에 대해서만 테이블 액세스가 발생하는 경우라면 테이블 전체를 스캔하는 것보다 나음
  - 이럴 때 옵티마이저는 Index Full Scan방식을 선택할 수 있음
  - 아래는 index Full Scan이 효과를 발휘하는 전형적인 케이스

3. Index Unique Scan
  - Index Unique Scan은 수지걱 탐색만으로 데이터를 찾는 스캔방식
  - Unique 인덱스를 '='조건으로 탐색하는 경우에 작동
  - SQL 실행계획에는 Oracle의 Range Scan과 Unique Scan을 구분하지 않고 똑같이 Index Seek라고 표시함

4. Index Skip Scan
  - 인덱스 선두 컬럼이 조건절로 사용되지 않으면 옵티마이저는 기본적으로 Tabke Full Scan을 선택함
  - 또는 Table Full Scan보다 I/O를 줄일 수 있거나 정렬된 결과를 쉽게 얻을 수 있다면 Index Full Scan 뱡식을 사용한다고 한다
  - Oracle인덱스 선두 컬럼이 조건절에 빠졌어도 인덱스를 활용하는 새로운 스캔 방식을 9i 버전에서 선보였었는데 바로 Index Skip Scan이 그것임
  - Index Skip Scan 내부 수행 원리를 간단히 요약하면, 루트 또는 브랜치 블록에서 읽은 칼럼 값 정보를 이용해 조건에 부합하는 레코드를 포함할 "가능성이 있는"하위 블록만 골라서 액세스 하는 방식이라고 할 수 있음
  - 이 스캔 방식은 조건절에 빠진 인덱스 선두 컬럼의 Distinct Value 개수가 적고 후행 칼럼의 Distinct Value 개수가 많을 때 유용함
  - 쿼리 작성자가 직접 성별에 대한 조건식을 추가해 주면 Index Skip Scan에 의존하지 않고도 빠르게 결과집합을 얻을 수 있음
  - 단, 이처럼 In-List를 명시하려면 성별값이 종류가 더이상 늘지않아 효과를 발휘하려면 in-List로 제공하는 값의 종류가 적어야 함
  - In-List를 제공하는 튜닝 기법을 익히 알던 독자라면 Index Skip Scan이 옵티마이저가 내부적으로 In-List를 제공해 주는 방식이라고 생각하기 쉽지만 내부 수행 원리는 전혀 다름

5. Index Fast Full Scan
  - 말 그대로 Index Fast Full Scan은 index Full Scan보다 빠름
  - Index Fast Full Scan이 Index Full Scan보다 빠른 이유는 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 Multiblock Read 방식으로 스캔하기 때문
  - Index Full scan과의 차이점을 요약하면 아래와 같음

|Index Full Scan|Index Fast Full Scan|
|--|--|
|1. 인덱스 구조를 따라 스캔 <br> 2. 결과 집합 순서 보장 <br> 3. Single Block I/O <br> 4. 병렬스캔 불가(파티션 돼 있지 않다면) <br> 5. 인덱스에 포함되지 않은 칼럼 조회 시에도 사용 가능|1. 세그먼트 전체를 스캔 <br> 2. 결과집합 순서 보장 안됨 <br> 3. Multiblock I/O <br> 4. 병렬스갠 가능 <br> 5. 인덱스에 포함된 칼럼으로만 조회할 때 사용가능

6. Index Range Scan Descending
   - Index Range Scan과 기본적으로 동일한 스캔 방식
   - 인덱스를 뒤에서부터 앞쪽으로 스캔하기 힘들기 때문에 내림차순으로 정렬된 결과 집합을 얻는다는 점만 다름

## 인덱스 종류
### B-Tree 인덱스
- 모든 DBMS가 B-Tree 인덱스를 기본적으로 제공하며, 추가적으로 제공하는 인덱스 구조는 모두 B*Tree 인덱스의 단점을 보완하기 위해 개발된 것
- B-Tree 인덱스 구조와 다양한 스캔 방식에 대해서는 이미 설명
- 뒤에서 튜닝 원리를 설명할 때도 계속 B-Tree를 기준으로 설명할 것이므로 여기서는 B*Tree인덱스 구조에서 나타날 수 있는 index Fragementation에 대한 개념만 잠시 살펴본다

#### Unbalanced Index
- delete 작업 때문에 인덱스가 불균형 상태에 놓일 수 있다고 설명한 자료들을 볼 수 잇음
- 다른 리프 노드에 비해 루트 블록과의 거리가 더 멀거나 가가운 리프 노트다 생길 수 있다는 것인데 B-tree에서는 발생하지 않음
- B-tree 인덱스의 B는 Balanced의 약자로 인덱스 루트에서 리프 블로갂지 어떤 값으로 탐색하더라도 읽는 블록수가 같음을 의미함
- 즉 루트로부터 모든 리프 블록까지의 높이가 동일

#### Index Skew
- 불균형은 생길 수 없지만 index Fragmentatio에 의한 index Skew 또는 Sprse 현상이 생기는 경우는 종종 있고, 이는 인덱스 스캔 효율에 영향을 미칠 수 있음
- Index SKew는 인덱스 엔트리가 왼쪽 또는 오른쪽에 치우치는 현상을 말함
- 예를들어 아래와 같이 대량의 delete 작업을 마치고 인덱스 왼쪽에 있는 리프 블록들은 텅 비는 반면 오른족은 꽉 찬 상태가 됨ss
- 오라클의 경우 텅 빈 인덱스 블록은 커밋하는 순간 freelist 로 반환되지만 인덱스 구조 상에는 그대로 남음
- 상위 브랜치에서 해당 리프 블록을 가리키는 엔트리가 그대로 남아 있어 인덱스 정렬 순서상 그 곳에 입ㄹ겨될 새로운 값이 들어오면 언제든 재사용할 수 있음
- 새로운 값이 하나라도 입력되기 전 다른 노드에 인덱스 분???용됨
- 이때는 상위 브랜치에서 해당 리프 블록을 가리키는 엔트리가 제거돼 다른 쪽 브랜치의 자식 노드로 이동하고, Freelist에서도 제거됨
- 레코드가 모두 삭제된 블록은 이처럼 언제든 재사용 가능하나, 문제는 다시 채워질 떄까지 인덱스 스캔 효율이 낮다는데 있음
- SQL Server 에서는 Index Skew 현상이 발생하지 않음
- 주기적으로 B*Tree 인덱스를 체크함으로 지워진 레코드와 페이지를 정리해주는 메커니즘을 갖기 때문
- 인덱스 레코드를 지우면 리프 코드로 마크 되었다가 이를 정리해주는 별도 쓰레드에 의해 비동기 방식으로 제거되는데, 그 과정에서 텅 빈 페이지가 발견되면 인덱스 구조에서 제거됨

#### index Sparse
- Index Sparse는 인덱스 블록 전반에 걸쳐 밀도가 떨어지는 현상
- delete작업을 수행하고 나면 t_idx블록의 밀도는 50%정도 밖에 안되는데 100만건 중 50만건을 지우고 나서도 스캔한 인덱스 블록 수가 동일하게 2001개인 것을 확인하길 바람
- delete 작업이 있고 난 후 한동안 인덱스 스캔 효율이 낮다는 데에 문제가 잇음
- index sparse는 지워진 자리에 새로운 값이 입력되지 않으면 영영 재사용되지 않을 수 있음
- 총 레코드 건수가 일정한데도 인덱스 공간 사용량이 계속 커지는 것은 대개 이런 현상에 기인함

#### 인덱스 재생성
- Fragmentation때문에 인덱스 크기가 계속 증가하고 스캔 효율이 나빠지면 인덱스를 재생성하거나 DBMS가 제공하는 명령어를 이용해 빈 공간을 제거하는 것이 유용할 수 있음
- 하지만 일반적으로 인덱스 블록에는 어느 저도 공간을 남겨두는 것이 좋음
- 왜냐면, 빈 공간을 제거해 인덱스 구조를 슬림화하면 저장 효율이나 스캔 효율엔 좋겠지만, 인덱스 분할이 자주 발생해 DML 성능이 나빠질 수 있기 때문
- 인덱스 분할에 의한 경합을 줄일 목적으로 초기부터 빈공간을 남기도록 옵션을 주고 인덱스를 재생성할 수도 있음
- 하지만 그 효과는 일시적
- 언젠가 빈 공간이 다시 채워지기 때문이며, 결국 적당한 시점마다 재생성 작업을 반복하지 않는 한 근본적인 해결책이 되지는 못함
- 인덱스를 재생성하는 데 걸리는 시간과 부하도 무시할 수 없음
- 따라서 인덱스의 주기적인 재생성 작업은 아래와 같이 예상 효과가 확실할 때만 시행하는 것이 바람직함
  - 인덱스 분할에 의한 경합이 현저히 높을 때
  - 자주 사용되는 인덱스 스캔 효율을 높이고자 할 때, 특히 NL Join에서 반복 엑세스되는 인덱스 높이가 증가했을 때
  - 대량의 delete 작업을 수행한 이후 다시 레코드가 입력되기까지 오랜 기간이 소요될 때
  - 총 레코드 수가 일정한데도 인덱스가 계속 커질 때


### 비트맵 인덱스
- Oracle은 비트맵(Bitmap)인덱스 구조를 제공하며, 보면 그 구조를 쉽게 이해할 수 있음
- Distinct Value 개수가 적을 대 비트맵 인덱스를 사용하면 저장 효율이 매우 좋음
- B*tree 인덱스보다 훨씬 적은 용량을 차지하므로 인덱스가 여러개 필요한 대용량 테이블에 유용
- 다양한 분석 관점을 가진 팩트성 테이블이 주로 여기에 속함
- 반대로 Distinct Value가 아주 많은 칼럼이면 오히려 B*Tree 인덱스보다 많은 공간을 차지함
- Distinct Value 개수가 적은 칼럼일 때 저장 효율이 좋지만 테이블 Random 액세스 발생 측면에서 B*Tree 인덱스와 똑같기 때문에 그런 칼럼을 비트맵 인덱스로 검색하면 그다지 좋은 성능을 기대하기는 어려움
- 스캔할 인덱스 블록이 줄어드는 정도의 성능 이점만 얻을 수 있고, 따라서 하나의 비트맵 인덱스 단독으로는 쓰임새가 별로 없다
- 그 대신 여러 비트맵 인덱스를 동시에 사용할 수 있는 특징 때문에 대용량 데이터 검색 성능을 향상시키는 데에 효과가 있음
- 비트맵 인덱스는 여러 인덱스를 동시에 활용할 수 있다는 장점 때문에 다양한 조건절이 사용되는, 특히 정형화 되지 않은 임의 질의가 많은 환경에 적합
- 다만 비트맵 인덱스는 Lock에 의한 DML 부하가 심한 것이 단점
- 레코드 하나만 변경되더라도 해당 비트맵 범위에 속한 모든 레코드에 Lock이 걸림
- OLTP 환경에 비트맵 인덱스를 쓸 수 없는 이유가 여기에 있고 비트맵 인덱스는 읽기 위주의 대용량 DW 환경이 적합함

### 함수 기반 인덱스
- Oracle이 제공하는 함수기반 인덱스는 칼럼 값 자체가 아닌, 칼럼에 특정 함수를 적용한 값으로 B*Tree 인덱스를 만듬
- 조건절에 NVL 함수를 씌워 아래처럼 인덱스를 만들면 인덱스 사용이 가능
- 주문수량이 Null인 레코드는 인덱스에 0으로 저장됨
- 함수 기반 인덱스가 유용한 가장 흔한 사례는, 대소문자를 구분해서 입력받은 데이터를 대소문자 구분 없이 조회할 때
- upper함수를 씌워 인덱스를 생성하고 upper 조건으로 검색하는 것
- 함수 기반 인덱스는 데이터의 입력 수정 시 함수를 적용해야 하기 때문에 다소 부하가 있을 수 있으며, 사용된 함수가 사용자 정의 함수 일 때는 부하가 더 심함
- 따라서 남용하지 말고 꼭 필요한 때만 사용하길 바람

### 리버스 키 인덱스
- 일련번호나 주문 일시 같은 컬럼에 인덱스를 만들면, 입력되는 값이 순차적으로 증가하기 때문에 가장 오른쪽 리프 블록에만 데이터가 쌓임
- 이런 현상이 발생하는 인덱스를 흔히 'Right Growing(또는 Right Hand)인덱스'라고 부름
- 동시에 inser가 심할 때 인덱스 블록 경합을 일으켜 초당 트랜잭션 처리량을 크게 감소시킴
- 그럴 때 리버스 키 인덱스가 유용할 수 있는데 이것은 말 그대로 입력된 키 값을 거꾸로 변환해서 저장하는 인덱스
- 조금 전에 설명한 함수기반 인덱스를 상기하면서, 아래와 같이 reverse 함수에서 반환된 값을 저장하는 인덱스
- 순차적으로 입력되는 값을 거꾸로 변환해서 저장하면 데이터가 고르게 분산
- 따라서 리프 블록 맨 우측에만 집중되는 트랜잭션을 리프 블록 전체에 고르게 분산시키는 효과를 얻을 수 있음
- 하지만, 리버스 키 인덱스는 데이터를 거꾸로 입력하기 때문에 '='조건으로만 검색이 가능
- 즉, 부등호나 between, like 같은 범위검색 조건에는 사용할 수 없음

### 클러스터 인덱스
- oracle에는 클러스터 테이블이라는 오브젝트가 있음
- 클러스터 테이블에는 인덱스 클러스터와 해시 클러스터 두가지가 있는데, 지금 설명하는 클러스터 인덱스는 인덱스 클러스터와 관련이 있음
- 인덱스 클러스터 테이블은 클러스터키 값이 같은 레코드가 한 블록에 모이도록 저장하는 구조를 말함
- 한 블록에 모두 담을 수 없을 때는 새로운 블록을 할당해 클러스터 체인으로 연결
- 심지어 여러 테이블 레코드가 물리적으로 같은 블록에 저장되도록 클러스터를 할당할 수도 있음
- 여러 테이블을 서로 조인된 상태로 저장해 두는 것인데, 일반적으로 하나의 데이터 블록이 여러 테이블에 의해 공유될 수 없음을 상기
- Oracle에서 인덱스 클러스터를 만들고 거기에 클러스터 인덱스를 정의하는 방법은 아래 쿼리와 같음

```
SQL > create cluster c_deptno# ( deptno number(2) index: SQL > create index i_deptno# on cluster c_deptno#;)
```
- 방금 생성한 클러스터에 아래와 같이 테이블을 담기만 하면 됨

```
SQL > create table emp2 cluster c_deptno# (deptno) 3 as 4 select * from scott.emp;
```

- 클러스터 인덱스도 일반적인 B*tree 인덱스 구조를 사용하지만, 해당 키 값을 저장하는 첫 번째 데이터 블록만 가리킨다는 점에서 다름
- 클러스터 인덱스의 키 값은 항상 Unique(중복 값이 없음)하며, 테이블 레코드와 1:M 관계를 갖음
- 일반 테이블에 생성한 인덱스 레코드는 테이블 레코드와 1:1 대응 관계를 갖는다는 사실을 상기
- 이런 구조적 특성 때문에 클러스터 인덱스를 스캔하면서 값을 찾을 때는 Random 액세스가 (클러스터 체인을 스캔하면서 발생하는 Random 액세스는 제외) 값 하나당 한 번씩만 발생
- 클러스터에 도달해서는 sequential 방식으로 스캔하기 대문에 넓은 범위를 검색할대 유리
- 새로운 값이 자주 입력 (새 클러스터 할당) 되거나 수정이 자주 발생하는 칼럼(클러스터 이동)은 클러스터 키로 선정하지 않는 것이 좋음

### 클러스터형 인덱스/IOT
- SQL Server에서 지원되는 인덱스로는 클러스터형 인덱스(Cluster Index)와 비클러스터형 인덱스(Non-Clustered Index)두가지가 있음
- 비 클러스터형 인덱스는 지금까지 설명한 B*Tree인덱스와 100%같으므로 다로 설명하지는 않겠음

#### 클러스터형 인덱스/IOT구조
- 클러스터형 인덱스도 구조적으로 B*Tree 인덱스와 같은 형태임
- 차이가 있다면 별도의 테입르을 생성하지 않고 모든 행 데이터를 인덱스 리프 페이지에 저장한다는 점
- 일반적인 힙 구조 테이블에 데이터를 삽입할 때는 정해진 순서 없이 Random 방식으로 이루어짐
- 클러스터형 인덱스는 정렬 상태를 유지하며 데이터를 삽입
- 따라서 클러스터형 인덱스는 테이블마다 단 하나만 생성할 수 있음
- 한 테이블이 두개의 정렬 순서를 가질 수 없으므로 너무나 당연한 제약임
- 테이블에 클러스터링 인덱스를 생성하면 항상 정렬된 상태를 유지해야 하기 때문에 데이터 입력 시 성능이 느린 단점을 가짐
- 비 클러스터형 인덱스를 생성해도 정렬을 유지해야한다는 점은 같고, 클러스터형 인덱스는 인덱스 키 값 외에도 많은 데이터를 나누는 상황이 자주 발생하고, 이때문에 DML 부하가 더 심하게 발생함
- 이런 단점에도 불구 클러스터링 인덱스를 사용하는 이유는 넓은 범위의 데이터를 검색할때 유리
- 이런 특징은 같은 값을 가진 레코드가 100% 정렬된 상태로 모여 있고 리프 렙레이 곧 데이터 페이지라는 데서 나옴
- 즉 정렬된 리프 페이지를 Sequential 방식으로 스캔하면서 검색 값을 모두 찾을 수 있고, 찾은 레코드에 대해서는 추가적인 테이블 Random액세스가 필요하지 않다.
- 클러스터형 인덱스를 Oracle의 클러스터 인덱스와 햇갈리면 안됨
- 이름떄문에 클러스터형 인덱스를 Oracle의 클러스터 인덱스와 같아도 생각하기 쉽지만 클러스터형 인덱스는 오히려 Oracle IOT에 가까움
- 차이가 있다면 Oracle IOT는 PK에만 생성할 수 있다는 점
- SQL Server 클러스터형 인덱스는 중복 값이 있는 칼럼에도 생성할 수 있기 때문에 중복된 키 값을 내부적으로 식별하기 위해 uniquifier라는 값을 함께 저장함

### 2. 클러스터형 인덱스/IOT 활용
- 클러스터형 인덱스는 아래와 같은 상황에서 유용
  - 넓은 범위를 주로 검색하는 테이블
  - 크기가 작고 NL Join으로 반복 룩업하는 테이블
  - 칼럼 수가 작고 로우 수가 많은 테이블
  - 데이터 입력과 조회 패턴이 서로 다른 테이블
- 마지막 항목에 대해서는 보충 설명이 필요한 것 같음
- 어떤 회사에 100명의 영업 사원이 있다고 함
- 영업 사원들의 일별 실적을 집계하는 테이블이 있는데, 한 페이지에 100개 레코드가 담김
- 그러면 매일 한 페이지씩 1년이면 365개 페이지가 생김
- 실적 등록은 이처럼 일자별로 진행되지만 실적 조회는 주로 사원별로 이루어짐
- 만약 비클러스터형 인덱스를 이용한다면 사원마다 365개 데이터 페이지를 Random액세스 방식으로 읽어야 함
- 특정 사원의 1년치 영업실적이 365개 페이지에 흩어져 저장돼 있기 때문
- 이처럼 데이터 입력과 조회 패턴이 서로 다를 때, 아래와 같이 사번이 첫번째 정렬 기준이 되도록 클러스터형 인덱스를 생성해주면 한 페이지만 읽고 처리를 완료할 수 있음
- 지금까지 설명한 클러스터형 인덱스 특징은 Oracle IOT에도 똑같이 적용

### 3. 2차 인덱스로부터 클러스터형 인덱스/IOT 참조하는 방식
- SQL Server는 클러스터형 인덱스를 가리키는 2차 인덱스를 비 클러스터형 인덱스라 부름
- Oracle에선 IOT를 가리키는 2차 인덱스를 Secondary Index라 부름
- 2차 인덱스는 클러트러형 인덱스나 IOT를 가리키는 키 값을 내부적으로 포함
- 버전마다 구조가 조금씩 다름
- SQL 서버 6.5이전에는 비클러스터형 인덱스가 클러스터형 인덱스 레코드를 직접 가리키는 Rowid를 갖도록 설계
- 문제는 인덱스 분할에 인해 클러스터형 인덱스 레코드 위치가 변경될때마다 비클러스터형 인덱스가 갖는 rowid대신 클러스터형 인덱스의 키 값을 갖도록 구조가 변경됨
- 이제 클러스터형 인덱스의 키 값을 갱신하지 않는 한, 인덱스 분할 대문에 비 클러스터형 인덱스를 갱신할 필요가 없어진 것
- 그런데 DML 부하가 줄어든 대신, 비 클러스터형 인덱스를 이용할 때 이전보다 더 많은 I/O가 발생하는 부작용을 안게 됨
- 비 클러스터형 인덱스에서 읽히는 레코드마다 건건이 클러스터형 인덱스 수직 탐색을 반복하기 때문
- 당연히 클러스터형 인덱스 높이(height)가 증가할수록 블록 I/O도 증가함
- Oracle은 IoT를 개발하면서 SQL 서버 6.5 이전과 7.0이후 버전이 갖는 두 가지 액세스 방식을 모두 사용할 수 있도록 설계
- IoT레코드의 위치는 영구적이지 않기 때문에 Oracle은 Secondary 인덱스로부터 IOT레코드를 가리킬 때 물리적 주소 대신 Logical Rowid를 사용함
- Logical Rowid는 PK와 physical guess로 구성됨
```
Logical Rowid = PK + physical guessd
```
- physical guess는 Secondary 인덱스를 "최초 생성하거나 재생성(Rebuild) 한 시점"에 IOT 레코드가 위치했던 데이터 블록 주소(DBA)
- 인덱스 분할에 의해 IOT 레코드가 다른 블록으로 이동하더라도 Secondary 인덱스에 저장된 physical guess 값은 갱신되지 않음
- SQL 서버 6.5에서 발생한 것과 같은 DML 부하를 없애기 위함이고, 레코드 이동이 발생하면 정확한 값이 아닐 수 있기 때문에 guess란 표현을 사용한 것임
- 이처럼 두 가지 정보를 다 가짐으로 Oracle은 상황에 따라 다른 방식으로 IOT를 액세스할 수 있게 함
- 경우에 따라서는 두 가지 방식을 다 사용하기도 하는데, physical guess가 가리키는 블록을 찾아 갔다가 찾는 레코드가 없으면 PK로 다시 탐색하는 식임

### 인덱스 튜닝 기초
- 범위 스캔이 불가능하거나 인덱스 사용아 아예 불가능한 경우
- 아래와 같이 인댁스 선두 칼럼을 조건절에서 가공하면(FBI 인덱스를 정의하지 않는 한)정상적으로 인덱스를 사용할 수 없음
```
select * from 업체 where substr(업체명, 1, 2) = '대한'
```
- 또한 아래처럼 부정형 비교를 사용해도 마찬가지다
```
select * from 고객 where 직업 <> '학생'
```
- is not null 조건도 부정형 비교에 해당하므로 정상적인 인덱스 사용은 어려움
```
select * from 사원 where 부서코드 is not null
```
- 위 세 경우 모두 정상적인 인덱스 범위 스캔이 불가능할 따름이지 인덱스 사용 자체가 불가능하지는 않음
- index Full Scan은 가능
- 맨 마지막 SQL을 예를 들어 Oracle에서 '부서코드'에 단일 칼럼 인덱스가 존재한다면 그 인덱스 전체를 스캔하면서 얻은 레코드는 모두 부서코드 is not null 조건을 만족함
- 1절에서 설명했듯이 Oracle은 단일 칼럼 인덱스에 null값은 저장하지 않기 때문
- 결합 인덱스일 때는 인덱스 구성 칼럼 중 하나라도 값이 null이 아닌 레코드는 인덱스에 저장하는데 그래도 필터링을 통해 부서코드 is not null 조건에 해당하는 레코드를 모두 찾을 수 있음
- SQL Server 는 단일 결합을 가리지 않고 null이 아닌 레코드를 인덱스에서 모두 찾을 수 있음
- 인덱스 사용이 불가능한 경우도 있는데 ,Oracle에서 아래와 같이 is null 조건만으로 검색할 때가 그렇다
- 인덱스도 구성칼럼이 모두 Null인 레코드는 인덱스만 뒤져선 찾을 수 없기 때문
- SQL Server 는 당연히 is null 검색 시에도 인덱스를 사용할 수 있음

```
select from 사원 where 연락처 is null
```

- 다른 인덱스 칼럼에 is null이 아닌 조건식이 하나라도 있거나 not null 재약이 있으면, Oracle에서도 is null 조건에 대한 index Range Scan이 가능하다.(물론 인덱스 선두 칼럼이 조건절에 누락되지 않아야 함)

### 인덱스 칼럼의 가공
- 인덱스 칼럼을 가공하면 정상적인 Index Range Scan이 불가능해진다고 함
- 가장 흔한 인덱스 칼럼 가공 사례는 아래 그림과 같고 오른쪽 칼럼은 각 사례에 대한 튜닝 방안임

<img src="./img/src/2.png" width = "200" height = "400">


### 묵시적 형변환
- 인덱스 칼럼을 사용자가 명시적으로 가공하지 않더라도 조건절에서 비교되는 두 값의 데이터 타입이 다르면 내부적으로 형변환이 일어남
- 예를들어 emp deptno 칼럼은 number혀임
- 이 칼럼에 대한 검색조건으로 숫자형이 옳지만, 자칫 실수로 아래와같은 문자형으로 코딩하는 일이 종종 생김
- 다행히 문자형과 숫자형이 만나면 옵티마이저는 문자형을 숫자형으로 변환하여 위 Predicate Information에서 그런 사실을 발견할 수 있음
- 덕분에 인덱스도 정상적으로 사용할 수 있게 된 것
- 이번에는 cdeptno라는 문자형 칼럼을 추가하고 인덱스까지 생성한 다음 아래와 같이 테스트해본다.

```
select * from emp where cdeptno = 20
```
- 문자형 cdeptno 칼럼이 숫자형으로 변환된 것을 볼 수 있고, 이 때문에 emp 테이블을 Full Scan하는 실행 계획이 수립됨
- 묵시적 형변환은 사용자가 코딩을 쉽게 하도록 도울 목적으로 대부분 DBMS가 제공하는 기능
- 위와 같은 부작용을 피하려면 가급적 명시적으로 변환함수를 사용하는 것이 좋음
- 문자형과 숫자형이 만나면 숫자형으로 , 문자형과 날짜형이 만나면 날짜형으로 변환하는 등 데이터 타입 간고 노력할 필요도 없음
- 성능을 위해서라면 인덱스 칼럼과 비교되는 반대쪽을 인덱스 칼럼 데이터 타입에 맞춰주면 됨
- 묵시적 형변환은 주로 성능 측면에서 언급되곤 하나, 올바른 결과집합을 업디 위해서라도 변환함수를 명시하는 것이 바람직함
- 묵시적 형변환은 쿼리 수행 도중 에러를 발생시키거나 결과집합을 틀리게 만드는 요인일 수 있음ㄴ

### 2. 테이블 Random 액세스 최소화

#### 인덱스 ROWID 에 의한 테이블 Random 액세스
- 쿼리에서 참조되는 칼럼이 인덱스에 모두 포함되는 경우가 아니라면 테이블 Random 액세스가 일어남
- 아래 실행계획에서 Table Access By Index ROWID라고 표시된 부분을 말함
- 지금부터 Table Access By Index Rowid 또는 RID Lookup으로 표현되는 테이블 Random 액세스의 내부 메커니즘을 자세히 살펴본다.
- 인덱스 Rowid에 의한 테이블 액세스 구조
  - 인덱스에 저장돼 있는 Rowid는 흔히 물리적 주소정보 라고 일컬어 지는데, 오브젝트 번호, 데이터 파일 번호, 블록 번호 같은 물리적 요소들로 구성돼 있기 때문일 것
  - 하지만 보는 시각에 따라서는 논리적 주소정보라고 표현하기도 함
  - Rowid가 물리적 위치 정보로 구성되지만 인덱스에서 테이블 레코드로 직접 연결되는 구조는 아니기 때문
  - 어떤 것이 맞든 중요한 것은 rowid가 메모리 상의 위치정보가 아니라 디스크 상의 위치정보라는 사실임
  - 그리고 데이터 블록을 읽을 때는 항상 버퍼 캐시를 경유하므로 메모리 상에서 버퍼 블록을 찾기 위해 해시 구조와 알고리즘을 사용
  - 해시 키 값으로는 rowid에 내포된 데이터 블록 구조를 사용함
  - 인덱스 Rowid를 이용해 테이블 블록을 읽는 매커니즘을 간단히 요약하면 아래와 같음
    - 인덱스 REOWID에 의한 테이블 액세스 구조
    - 인덱스에서 하나의 rowid를 읽고 DBA(디스크 상의 블록 위치 정보)를 해시 함수에 적용해 해시 값을 확인함
    - 해시 값을 이용해 해시 버킷을 찾아감
    - 해시 버킷에 연결된 해시 체인을 스캔하면서 블록 헤더를 찾음
    - 해시 체임에서 블록 헤더를 찾으면 거기 저장된 포인터를 이용해 버퍼 블록을 읽음
    - 해시 체인을 스캔하고도 블록 헤더를 찾지 못하면 LRU 리스트를 스캔하면서 Free 버퍼를 찾음
    - 디스크에서 읽은 블록을 적재하기 위해 빈 캐시 공간을 찾는 것
    - LRU 리스트에서 Free 버퍼를 얻지 못하면 Dirty 버퍼를 디스크에 기록해 Free 버퍼를 확보함
    - Free 버퍼를 확보하고 나면 디스크에서 블록을 읽어 캐시에 적재함
  - 위 처리 과정 중 래치 버퍼같은 Lock같은 Internal Lock을 획득하거나 다른 백그라운드 프로세스의 선처리 결과를 기다리는 내부 메커니즘이 작동함
  - 그런 과정에서 경합까지 발생한다면 블록 하나를 읽더라도 생각보다 큰 비용을 치르게 됨
  - Oracle이나 SQL Server 같은 디스크 기반 DBMS에서 인덱스 Rowid에 의한 테이블 액세스가 생각만큼 ㅏㅃ르지 않은 이유가 여기에 있음
  - 특히 다량의 테이블 레코드를 읽을 때의 성능 저하가 심각함
  - 앞으로 실행계획에서 아래와 같이 Table Access By Index ROWID나 RID Lookup 오퍼레이션을 볼 때면 방금 설명한 복잡한 처리과정을 항상 떠올리기 바람
  - Oracle은 클러스터링 팩터라는 개념을 사용해 인덱스 Rowid에 의한 테이블 액세스 비용을 평가함
  - SQL Server 는 공식적으로 이 용어를 사용하진 않지만, 내부적인 비용 계산식에 이런 개념이 포함돼 있을 것
  - 클러스터링 팩터는 군집성 계수 쯤으로 번역될 수 있는 용어로 특정 칼럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미함
  - 좋은 상태를도식화 한것으로서 인덱스 레코드 정렬 순서와 거기서 가리키는 테이블 레코드 정렬 순서가 100% 일치하는 것을 볼 수 있다

<img src="./img/src/3.png" width = "200" height = "400">

  - 반면 인덱스 클러스터링 팩터가 가장 안좋은 상태를 도식화 한것으로서 인덱스 레코드 정렬 순서와 테이브 레코드 정렬 순서가 전혀 일치하지 않음

<img src="./img/src/4.png" width = "200" height = "400">

  - 클러스터링 효율이 매우 좋은데 예를 들어 거주지역=제주 에 해당하는 고객 데이터가 물리적으로 근접해 있다면 흩어져 있을 때보다 데이터를 찾는 속도가 빨라지기 마련임

### 인덱스 손익 분기점
- 앞서 설명한 것처럼 인덱스 rowid에 의한 테이블 액세스는 생각보다 고비용 구조이고, 따라서 일정량을 넘는 순가 테이블 전체를 스캔할 때보다 오히려 느려짐
- Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점을 흔히 '손익 분기점'이라고 부름
- 예를 들어 인덱스 손익 분기점이 10%라는 의미는 1000개 중 100개 레코드 이상을 읽을 때는 인덱스를 이용하는 것보다 테이블 전체를 스캔하는 것이 더 빠르다는 것
- 인덱스 손익 분기점은 일반적으로 5~20%의 낮은 수준에서 결정되지만 클러스터링 팩터에 따라 크게 달라짐
- 클러스터링 팩터가 나쁘면 손익분기점은 5%미만에서 결정되며 싱할때는 (BCHR가 매우 안좋을 때) 1%미만으로 떨어짐
- 반대로 클러스터링 팩터가 아주 좋을 때는 손익 분기점이 90% 수준까지 올라가기도 함
- 인덱스에 의한 액세스가 Full Table Scan보다 더 느리게 만드는 가장 핵심적인 두가지 요인은 다음과 같다.
  - 인덱스 rowid에 의한 테이블 액세스는 Random액세스인 반면 Full Table Scan은 Sequential 엑세스 방식으로 이루어짐
  - 디스크 I/O시 인덱스 Rowid에 의한 테이블 액세스는 Single Block Read 방식을 사용하는 반면 Full Table Scan은 Multiblock Read방식을 사용한다

#### 손익분기점 극복하기
- 손익분기점 원리에 따르면 선택도(Slectivity)가 높은 인덱스는 효용가치가 낮지만, 그렇다고 테이블 전체를 스캔하는 것은 부담스러울 때가 많음
- 그럴 때 DBMS가 제공하는 기능을 잘 활용하면 인덱스의 손익분기점 한계를 극복하는 데 도움이 됨
- 첫 번째는 SQL Server의 클러스터링 인덱스와 Oracle IOT로서, 테이블을 인덱스 구조로 생성하는 것이라고 앞서 설명함
- 테이블 자체가 인덱스 구조이므로 항상 정렬된 상태를 유지함
- 그리고 인덱스 리프 블록이 곧 데이터 블록이어서 인덱스를 수직 탐색한 다음 테이블 레코드를 읽기 위한 추가적인 Random 액세스가 불필요함
- 두 번째는 
