## 1-6 문장 수준 읽기 일관성

### 1. 문장수준 읽기 일관성이란?
- 문장수준 읽기 일관성은, 단일 SQL문이 수행되는 도중에 다른 트랜잭션에 의해 데이터의 추가, 변경, 삭제가 발생하더라도 일관성있는 결과집합을 리턴
- 예
  - 변경이 진행중인 값, 즉 아직 커밋되지 않은 값을 다른 트랜잭션이 읽도록 Dirty Read를 허용한다면 읽기 일관성을 보장하지 않음
- 오라클을 제외한 다른 DBMS는 모두 로우 Lock을 사용해 Dirty Read를 방지한다.
- 즉 읽기 작업에 대해 Shared Lock을 사용함으로 Exclusive Lock이 걸린 로우를 읽지 못하도록 한다.
- 테이블 단위인 Lock을 사용하지 않는 한 Dirty Read를 방지하는 것만으로 문장수준 읽기 일관성이 완벽하게 보장되지 않음

### 테이블 레벨 Lock을 통한 읽기 일관성 확보
- 위와 같은 비일관성 읽기 문제를 해결하기 위한 일반적인 해법은 트랜잭션 고립화 수준을 상향 조정하는 것
- SQL Server, Sybase 등은 Lock을 사용해 읽기 일관성을 구현하는데 기본 트랜잭션 고립화 수준(Level 1, Read Committed)에서는 값을 읽는 순간에만 Shared Lock 에 걸었다가 다음 레코드로 이동할 때 Lock을 해제
- Shared Lock이 해제되기 떄문에 이미 읽고 지나간 레코드를 다른 트랜잭션이 변경할 수 있게 됨
- 이때문에 문장수준 읽기 일관성이 보장되지 않은 문제가 생김
- 트랜잭션 고립화 수준을 레벨2로 조정하면 TX1 쿼리가 진행되는 동안 읽은 레코드는 Shared Lock이 계속 유지되며 심지어 쿼리가 끝나고 다음 쿼리가 진행되는 동안 Lock를 풀지 않음
- 트랜잭션 고립화 수준을 조정하면 Lock이 발생하는 범위가 넓어지고 더 오래 유지되기 떄문에 동시성 저하를 초래, 교착상태가 발생할 가능성이 높아짐
- 오라클은 높은 수준의 동시성을 유지하면서, 완벽한 문장수준 읽기 일관성을 보장하기 때문에 걱정 안해도됨

### 2. Consistent 모드 블록 읽기
- 오라클은 쿼리가 시작된 시점을 기준으로 데이터를 읽어 드린다.
- 쿼리가 시작되기 전에 이미 커밋된 데이터만 읽고, 쿼리 시작 이후 커밋된 변경사항은 읽어드리지 않음
- 변경이 발생한 블록을 읽을 때는 현재의 Current 블록으로부터 CR 블록을 생성해서 쿼리가 시작된 시점으로 되돌린 후 그것을 읽음
#### Current 블록
- 디스크로부터 읽혀진 후 사용자의 갱신사항이 반영된 최종상태의 원본블록

#### CR블록
- Current 블록에 대한 복사본
- 여러 버전이 존재하겠지만, Current 블록은 오직 하나뿐

#### 다중 버전 읽기 일관성 모델
- CR Copy 블록으로 복사해 읽기 일관성을 지원하는 오라클만의 독특한 메커니즘을 다중 버전 읽기 일관성 모델이라고 함

#### RAC 환경에서의 Current 블록
- 단일 인스턴스 환경이라면 캐싱된 Current 블록은 오직 한개뿐
- RAC 환경이라면 Share 모드의 Current 블록이 여러 노드에 동시에 캐싱돼 있을 수 있다.
- 로컬 캐시 관점에서는 여전히 하나지만, 글로벌 캐시 관점에서 보면 Current 블록이 여러개인 셈
- Exclusive모드의 Current 블록은 오직 한 노드에만 존재할 수 있다.
- 예를들어