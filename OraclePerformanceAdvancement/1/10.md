## 10. 대기 이벤트

### 1. 대기 이벤트란
- 함께 일을 하는 동안 프로세스간 커뮤니케이션과 상호작용이 필요하고 떄로는 다른 프로세스가 일을 마칠 때까지 기다려야 하는 상황이 발생함
- 오라클 프로세스는 일을 계속 진행할 수 있는 조건이 충족될 때 까지 수면 상태에 빠진다. 이러한 현상이 발생
- 이런 현상을 대기 이벤트라고 함
  - 이럴떄마다 오라클은 그 상태정보를 파일 또는 SGA 메모리에 저장함

#### 대기 이벤트의 용도
- 오라클 개발자들이 디버깅 용도로 사용하던 것
- 옵션처럼 사용하는 건데 옵션을 활성화하면 콘솔에 프로그램 진행상황을 출력하거나 별도 파일에 로그를 남김
- 오라클 개발자들도 공유 자원에 대한 경합이나 기타 원인에 의한 대기가 발생할 때마다 관련 로그를 생성하도록 커널 코드에 기능을 추가
- 그것이 오늘에 이르러 OWI 라는 이름을 덧입으면서 성능관리분야에 일대 번혁을 가져오게 됨
- 오라클에서는 대기이벤트라고 하지만, SQL Server 에서는 대기 유형이라고 부름

#### 시스템 커널 레벨에서의 대기이벤트
- 프로세스가 할일을 다 마쳤거나 다른 프로세스를 기다려야 하는 상황에서 CPU를 쥔 채 대기하면 불필요하게 CPU 자원을 낭비하는 것
- CPU를 OS에 반환하고 수면상태로 빠지는 것
- 수면에 빠진다는 것은 프로세스가 wait queue로 옮겨지는 것을 말함
- wait queue에 놓인 프로세스에게는 CPU를 할당해 줄 필요가 없으므로, OS는 해당 프로세스를 스케줄링 대상에서 제외
- 선행 프로세스가 일을 마치면 OS에게 그 사실을 알려 자신을 기다리던 수면 상태의 프로세스를 꺠우도록 신호를 보냄
- 그러면 OS는 그 프로세스를 runnable queue에 옮김으로써 가능한 빨리 CPU를 할당받아 일을 재개할 수 있도록 스케줄링함

#### 유닉스에서 vmstat 유틸리티를 통해 시스템 상황을 모니터링한 것
- 사진 하나 추가
- 왼쪽에 보이는 r은 현재 일을 수행중이거나 runnable queue에서 CPU 리소스를 기다리는 프로세스 갯수임
- 이 수치가 CPU개수를 초과하고 CPU 사용률이 100%에 근접한다면 CPU 병목현상이 발생한 것으로서, 할 일ㅇ리 산적해 있는데 프로세스들이 빨리 빨리 CPU를 할당받지 못해 runnable queue에서 오래 대기하고 있음ㅇ르 의미
- w는 wait queue에 놓인 프로세스 개수를 의미, 즉 Sleep 상태의 프로세스의 개수로서 이 값이 큰 것도 병목일 수 있음
- 특히 오라클 입장에서는 대기 이벤트가 많이 발생한 것이므로 어떤 종류의 대기 이벤트가 발생중인지 뷰를 통해 봐야 함
- 위 vmstat 결과 화면에는 idle cpu % 가 낮을 뿐 아니라 paging도 많이 발생하고 있어 시스템 부하가 매우 극심한 상황임

### 2 대기 이벤트는 언제 발생하나
- 대기 이벤트가 지속적으로 많이 발생하면 데이터베이스에 병목이 있음을 알리는 신호지만 모든 대기 이벤트가 그렇지는 않음.
- 예를들어 SQL*Net message from client와 SQL*Net more data from client 이벤트는 서버 프로세스가 사용자의 명령이나 신호를 기다릴떄 나타나므로 병목이 발생했다고 볼 수 없음
- 그 외에도 pmon timer, smon timer, px idle 대기 등은 서버 프로세스가 할 일이 없기 떄문에 발생하는 idle 대기 이벤트이기 때문에 데이터베이스 튜닝 시 무시해도 된다.
- 대기 이벤트가 발생하는 상황을 아래와 같이 3가지로 요약할 수 있음
  1. 자신이 필요로 하는 특정 리소스가 다른 프로세스에 의해 사용중일떄
  2. 
  3. 할일이 없을 때
- 서버 프로세스는 쿼리 결과를 사용자에게 전송하는 동안 Array 단위로 일을 처리하는데, array 크기만큼 데이터를 전송하면 다음 Fetch Call을 받을 때 까지 기다림
- 쿼리 결과집합을 모두 전송(End of Fetch)하고 나서도 다음 Parse Call 또는 Execute Call을 받을 때 까지 기다림
- 또 다른 예로서, 병렬 쿼리를 수행하면 자신이 맡은 일을 먼저 끝마치는 병렬 Slave  프로세스가 생기는데 그럴 때면 다른 Slave들이 일을 마칠 때 까지 대기 상태에서 기다림
- SQL*Net message from client, PX Deq: Excution Msg 등이 여기 속함

#### 3 대기 이벤트는 언제 사라질까
- 오라클 프로세스도 수면 상태로 들어갈 때 타이머를 설정함
- 선행 프로세스가 자신을 흔들어 깨우지 않더라도 타이머에 설정된 시간이 도래할 때마다 한번씩 깨어나 자신이 기다리던 리소스가 사용 가능해졌거나 해야 할일이 생겼는지 확인함
- 타임아웃 설정 값은 대기 이벤트마다 모두 다름
- 예를들어 앞에서 설명한 DBWR 와 LGWR간 상호 작용에 의한 대기 이벤트 발생 시 타임아웃은 둘 다 3초로 설정됨
커밋 할 때마다 LGWR를 꺠워 Redo 버퍼를 비우도록 할 때 발생하는 log file sync 대기 이벤트의 타임아웃은 1초, buffer busy wait 대기 이벤트도 1초임
- enqueue 관련 lock 대기 이벤트의 타임아웃은 3초임
- 알람에 의해 깨어났는데 리소스가 아직 사용중이거나 선행 프로세스가 일을 마치지 못했다면 다시 수면상태로 빠짐
- 대기가 자주 발생하는 것도 문제지만 타임아웃이 자주 발생한다면 대기 이벤트에 의한 지연(latency) 시간이 길어지는 것이므로 더 큰 적신호로 받아 들여야 함

#### 대기중이던 프로세스가 활동을 재개하는 시점
1. 대기 상태에 빠진 프로세스가 기다리던 리소스가 사용 가능해 지거나
2. 작업을 계속 진행하기 위한 선행작업이 완료되거나
3. 해야 할 일이 생겼을 때
- 대기 이벤트를 이용한 분석과 활용법에 대해서는 3장 3절과 6~9절에서 상세히 다룸

### 4 래치와 대기 이벤트 개념 명확화

#### 래치란?
- 래치를 얻는 과정 자체가 경합을 의미하지 않음
- 공유된 자원을 읽으려면 래치를 얻는 것이 당연한 일이므로 v$latch 뷰에서 gets 횟수가 증가한다고 해서 문제될 것은 없다
- 그저 공유 자원에 대한 접근요청이 많았던 것으로 이해하면 됨
- 다만 그 과정에서 다른 프로세스와 경합이 발생하는지를 관심있게 살펴봐야 하며, 만약 그렇다면 시스템의 동시성이 저하되므로 문제임

#### 래치의 종류
- v$latch 뷰를 조회해보면, 각 래치 종류별로 gets, misses, spin_gets, sleeps 항목들이 집계됨
  1. gets : 래치 요청 횟수를 말함
  2. misses : 래치를 요청했는데 다른 프로세스에 의해 자원이 사용중이어서 첫 번째 시도에서 곧바로 래치를 얻지 못한 횟수
- 래치 miss를 만난 프로세스는, 이후 spin 과정에서 래치 획득에 성공하거나 정해진 횟수만큼 spin 후에도 래치 획득에 실패해 대기 상태에 들어가는 둘 중 하나의 길을 걷게됨
- gets 에서 misses 횟수를 빼면 다른 프로세스의 래치 해제를 기다리지 않고 곧바로 래치 획득에 성공한 횟수(simple_gets)가 구해짐
```
simple_gets = gets - misses
```
  3. sleeps : 래치를 요청했는데 자원이 사용중이어서 고답로 래치를 얻지 못하고 정해진 횟수만큼 계속 spin 했는데도 결국 래치를 얻지 못해 대기 상태로 빠진 횟수
- 이떄 발생하는 것이 latch free 대기 이벤트임
- 잠시 후에 깨어나 다시 spin을 했는데도 래치 획득에 실패하면 또 다시 latch free 대기 상태로 빠지게 됨
- 래치는 Lock처럼 큐잉 메커니즘이 작동하지 않기 때문에 래치 획득에 성공할 때 까지 반복적인 액세스 시도가 있을 뿐, 우선권을 부여받지는 못함
- 따라서 가장 먼저 래치를 요구했던 프로세스가 가장 늦게 래치를 얻을 수 있음
- 오라클 9i 까지는 모든 래치에 대한 대기 이벤트를 latch free 하나로 통합해서 보여주었기 때문에 분석이 쉽지 않았는데, 10g 부터는 이를 세분화해 자주 발생하는 래치에 대해서는 예를들면, ‘latch: cache buffers chain’, ‘latch: library cache lock’ 처럼 별도의 이벤트 명을 부여함
- 상대적으로 중요도가 떨어지는 래치에 대한 대기 이벤트는 기존 latch free 이벤트로 집계됨
