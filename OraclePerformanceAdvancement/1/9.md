## 9 Snapshot too old

### 정의
- 데이터를 읽어 내려가다가 쿼리 SCN 이후에 변경된 블록을 만나(이미 앞서 읽었던 블록을 다시 방문하는 경우일 수도 있음) 과거 시점으로 롤백한 "Read Consistent" 이미지를 얻으려고 하는데, Undo 블록이 다른 트랜잭션에 의해 이미 재사용돼 필요한 Undo 정보를 얻을 수 없는 경우
  - 프로그램 코딩 패턴에 문제가 없다면 Undo 세그먼트가 너무 작다는 신호
- 커밋된 트랜잭션 테이블 슬롯이 다른 트랜잭션에 의해 재사용돼 커밋 정보를 확인할 수 없는 경우로, Undo 세그먼트 개숙 적다는 신호일 수 있음

### 9-1 Undo 실패
- Undo 블록을 찾을 수 없어 에러가 발생하는 경우
- 사진하나
- 해당 쿼리는 고객별 미납금액을 계산하는 쿼리이며 1시간정도 걸림 
  1. SCN 123시점에 이 쿼리가 시작함
  2. 쿼리가 진행되는 동안 은행으로부터 고객의 입금내역을 전송받아 일괄 처리하는 배치 프로그램이 수행됨
     1. 해당프록램은 각 건별로 커밋되도록 작성
  3. 시간이 흘러 홍길동 고객의 수납액 변경내역을 담은 Undo 블록이 다른 트랜잭션에 의해 재사용됨
  4. 위 쿼리를 수행중인 프로세스가 홍길동 고객의 수납액이 담긴 블록에 도달했을 때 블록 SCN이 자신의 쿼리 SCN 123보다 큰 129임을 확인하고 변경된 undo 레코드를 찾으려고 ITL 엔트리에 기록된 UBA를 읽어 Undo 세그먼트 블록을 찾아감
  5. 하지만 Undo 블록은 이미 다른 트랜잭션에 의해 재사용된 상태이므로 ORA-01555 에러를 발생시키며 진행을 멈춤
- 다른 예로 여러 세션에서 동시에 트랜잭션이 몰리지 않더라도 아래와 같은 프로그램이 한 세션에서 독립적으로 수행되는 도중에 Snapshot too old 에러가 발생할 수 있음
- 사진하나만 추가하고 설명은 생략한다.
- 해당 사진과 같은 코딩 패턴을 fetch across commit 이라고 하는데 명시적으로 커서를 열어 로우를 하나씩 fetch 하면서 값을 변경하고 루프 내에서 계속해서 커밋을 날리는 방식임
- ANSI 표준에 따르면 열려 있던 커서는 커밋하는 시점에서 무효화되어야 하므로 사용자는 계쏙해서 fetch 해선느 안됨
- 오라클은 ansi 표준에도 불구, 사용자가 fetch across commit을 할 수 있도록 허용하고 있지만, 그렇게 할 경우 에러가 발생할 수 있는 사실을 인지한 상태에서 프로그램을 작성해야함

### 9-2 블록 클린아웃 실패
#### 트랜잭션 테이블 슬롯이 재사용돼 에러가 발생하는 경우
- 사진하나 추가
- 대량 업데이트 이후 커밋된 트랜잭션은 변경했던 블록들을 모두 클린아웃하지 않은 상태에서 자신이 사용하던 트랜잭션 테이블 슬롯을 Free 상태로 변경하고 트랜잭션을 완료함
- 이때부터 그 트랜잭션 테이블 슬롯은 다른 트랜잭션에 의해 재사용될 수 있음
- 시간이 흘러 그 변경된 블록들이 읽혀야 하는 시점에 Delayed 블록 클린아웃을 위해 트랜잭션 테니블 슬롯을 찾아갔는 데, 해당 슬롯이 다른 트랜잭션에 의해 이미 재사용되고 없다면 정상적인 블록 클린아웃과 일관성 모드 읽기가 불가능해질 수 있음

#### Undo 세금너트 헤더 블록을 갱신한 내용도 Undo 레코드로서 기록함
- 따라서 트랜잭션 테이블 슬롯이 덮어 쓰인 것을 발견하면 우선 Undo 세그먼트 헤더 블록에 가해진 변경사항을 롤백하려고 시도함
- 다행히 찾고자 하는 트랜잭션에 대한 커밋 정보가 Undo 블록에 남아있다면, 현재 읽고자 하는 블록의 정확한 커밋 SCN을 가지고 블록 클린아웃을 수행할 수 있음.
- 하지만 Undo 레코드를 뒤졌는데 그마저도 덮어쓰이고 없는 상태라면?

#### Undo 레코드가 덮어 쓰이고 없는 상태라면
- Delayed 블록 클린아웃에 의한 Snapshot too old문제를 잘못 이해하면 이 처리 프로세스에 치명적인 결함이 있다고 오해하기 쉬움
- 클린아웃에 필요한 트랜잭션 테이블과 Undo 정보는 언젠간 필연적으로 덮어 쓰이기 마련
- 갱신 후에 오랫동안 읽히지 않았던 블록이 언젠간 읽히면서 예외없이 Snapshot too old가 발생한다고 생각할 수 있을 것임
- 하지만 블록 클린아웃에 의한 Snapshot too old에러는 거의 발생하지 않음

### 트랜잭션 슬롯이 필요해지면
커밋 SCN이 가장 낮은 트랜잭션 슬롯부터 재사용하는데, 그 슬롯에 기록돼 있던 커밋 SCN이 가장 낮은 트랜잭션 슬롯부터 재사용함
그 슬롯에 기롯돼있던 커밋 SCN을 Undo 세그먼트 헤더에 ‘최저 커밋 SCN’으로서 기록해 둠
트랜잭션 슬롯이 재사용되고 나면 그 슬롯을 사용하던 이전 트랜잭션의 정확한 커밋 SCN을 확인하는 것이 불가능해 지지만, Undo 세그먼트 헤더에 기록돼 있는 ‘최저 커밋 SCN’이전에 커밋되ㅓㅆ다는 사실만큼 짐작할 수 있음
따라서 아직 클린아웃되지 않은 블록을 클린아웃하려고 ITL이 가리키는 트랜잭션테이블 슬롯을 찾아갔을 때 
	커밋 정보가 이미 지워지고 없으면 Undo 세그먼트 헤더에 있는 최저 커밋 SCN을 블록 ITL엔트리에 커밋 SCN으로 기록함으로  블록 클린아웃을 마무리하고 블록 SCN도 변경함

### 클린아웃 시점에 일관성 모드 읽기 가능여부 문제
쿼리가 진행되는 동안, 많은 트랜잭션이 한꺼번에 몰리지만 않는다면 ‘최저 커밋 SCN’이 갑자기 많이 증가하지는, 않을 것므로, 최저 커밋 SCN에 의해 추정된 블록은 SCN은 대개 쿼리 SCN이 적다
따라서 쿼리가 시작된 이후에 해당 블록에 변경이 가해지지 않았음을 확인되므로 일관성 모드 읽기도 가능

### Snapshot too old가 발생하는 원인
최저 커밋 SCN이 쿼리 SCN보다 높아질정도로 갑자기 트랜잭션이 몰리는데 있음
이때는 추정에 의한 블록 SCN이 쿼리 SCN보다 높아지게 됨
실제로 이 에러를 발생시킨 블록은 훨씬 오래전 시점에 커밋된 것일수도 있지만, 이를 확인할 방법이 없으며, 그동안 한 번도 읽히지 않다가 불행하기도 트랜잭션이 몰리는 시점에 읽히다 보니 문제를 유발함

### 9-3 Snapshot too old 회피방법
- 재현이 어려워 문제 발생 원인부터 찾기가 힘듬
- 과거 버전에서는 undo 세그먼트를 수도으로 관리했기 때문에 Snapshot too old 에러 발생을 최소화하기 위해 시스템과 애플리케이션 특성에 맞는 Undo 튜닝을 DB관리자가 직접 해야만 했다.
- 9i부터는 AUM(automatic undo management)이 도입돼 트랜잭션 발생 상황에 따라 Undo 세그먼트 크기와 개수를 오라클이 동적으로 자동 조절해줌
  - 따라서 DBA의 수고가 많이 줄었고, Snapshot too old 에러가 발생할 가능성도 확실히 줄음
- DBA가 할 일이라고는 커밋된 Undo 정보가 충분히 오랫동안 보존될 수 있을 정도의 큰 Undo Space를 준비해 주는 것이 고작임
- 9i에서 도입된 Undo_retention 기능까지도 10g부터는 오라클이 알아서 스스로 튜닝해주고 있음

### Snapshot too old 에러 발생 가능성을 줄이기 위한 애플리케이션 측면에서의 솔루션
1. 불필요하게 커밋을 자주 수행하지 않음
2. fetch across commit 형태의 프로그램 작성을 피해 다른 방식으로 구현함
   - Ansi 표준에 따르면 커밋 이전에 열려 있던 커서는 더는 Fetch 하면 안됨
   - 다른 방식으로 구현하기 어렵다면 커밋 횟수를 줄여봄
3. 트랜잭션이 몰리는 시간대에 오래 걸리는 쿼리가 같이 수행되지 않도록 시간을 조정
4. 큰 테이블을 일정 범위로 나누어 읽고 단계적으로 실행할 수 있도록 코딩
   - Snapshot too old 발생 가능성을 줄일 뿐 아니라 문제가 발생했을 때 특정 부분부터 다시 시작할 수 있어 유리.
   - 물론 그렇게 해도 읽기 일관성에 문제가 없을 때에만 적용해야 함
5. 오랜 시간에 걸쳐 같은 블록을 여러 번 방문하는 Nested Loop 형태의 조인문 또는 인덱스를 경유한 테이블 액세스를 수반하는 프로그램이 있는지 체크., 이를 회피할 수 있는 방법을 찾음
6. 소트 부하를 감수하더라도 order by 등을 강제로 삽입해 소트 연산이 발생하도록 함
- 많은 데이터를 오랜시간에 걸쳐 Fetch 하는 동안 Undo 정보를 지속적으로 참조하기 때문에 문제가 발생하는 것이므로, 서버 내에서 빠르게 데이터를 읽어 세그먼트에 저장하는 뎅에만 성공하면 이후에는 같은 블록을 아무리 재방문하더라도 더는 에러가 발생할까 걱정하지 않아도 됨
7. 만약 delayed 블록 클린아웃에 의해 Snapshot too old가 발생하는 것으로 의심되면, 대량 업데이트 후에 해당 테이블에 대해 Full Scan 하도록 쿼리를 날리는 것도 하나의 해결방법이 됨

```
SELECT /*+ full(t)*/ count(*) from table_name t
```
- 만약에 인덱스 블록에서 문제가 발생한다고 판단되면 인덱스 리프 블록을 모두 스캔하도록 쿼리함
- 예를들어 index_column이 숫자형 컬럼이고 0 보다 큰 값을 갖는다면 대량 업데이트 후에 아래와 같은 쿼리를 날림
```
select count(*) from table_name where index_column>0
```