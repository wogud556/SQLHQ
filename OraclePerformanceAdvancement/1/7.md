### 1-7 Consistent vs. Current 모드 읽기
- 아래와 같은 내용에 대해 설명할 것
  1. Consistent모드 읽기와 Current 모드 읽기의 차이점
  2. Consistent모드로 갱신할 때 생기는 현상
  3. Current 모드로 갱신할 때 생기는 현상
  4. Consistent 모드로 읽고 Current 모드로 갱신할때 생기는 현상
  5. Consistent 모드로 갱신대상을 식별하고, Current모드로 갱신
  6. 오라클에서 일관성 없게 값을 갱신하는 사례

#### 1. Consistent 모드 읽기와 Current모드 읽기의 차이점
- Consistent 모드 읽기란?
   - SCN확인 과정을 거치며, 쿼리가 시작된 지점을 기준으로 일관성 있는 상태로 블록을 액세스 하는 것을 말함
    - 이 모드로 데이터를 읽을 때는 쿼리가 1시간 걸리든 10시간 걸리든 항상 쿼리가 시작된 시점의 데이터를 가져옴
- Query 항목과 AuthTrace에서의 consistent gets 항목이 지금 설명한 Consistent 모드에서 읽은 블록 수를 의미함
  - 읽는 중에 CR copy를 생성할 필요가 없어 Current 블럭을 읽더라도 Consistent모드에서 읽었다면, query 항목에 집계됨
  - Select 문에서 읽은 블록은 대부분 여기에 해당, 여기에는 CR블록을 생성하려고 Undo세그먼트로부터 읽어드리는 블록수도 더해짐
- 사진 하나 추가함
- Current 모드 읽기란?
  - SQL문이 시작된 시점이아니라, 데이터를 찾아간 바로 그 시점의 최종 값을 읽으려고 블록을 액세스하는 것을 말함
  - 블록 SCN이 쿼리 SCN보다 높고 낮음을 따지지 않으며, 그 시점에서 이미 커밋된 값이라면 그대로 받아들이고 읽음
- SQL 트레이스에서 Call 통계 레포트를 통해 볼 수 있는 Current 항목과 AutoTrace에서의 db block gets 항목이 Current 모드에서 읽은 블록 수를 의미하며, 주로 다음 상황에 나타남
  - DML문을 수행할 때 주로 나타남
  - select for update문을 수행할 때도 Current 모드 읽기를 발견할 수 있음
  - 8i 이전 버전에서는 Full 스캔을 포함하는 select 문에서도 Current 모드 읽기가 나타난 이력이 있다.
    - Full 할 익스텐트 맵(extent map) 정보를 읽으려고 세그먼트 헤더에 접근할 때 익스텐트에 대한 바로 현재 시점의 정보가 필요하기 때문
    - Locally Managed 테이블 스페이스를 주로 사용하기 시작한 9i 이상부터는 Full Table Scan을 하더라도 Current 모드 읽기가 발생하지 않는다.
    - index rowid를 이용한 테이블 액세스 시에는 테이블 익스텐트 정보가 불필요하므로 버전에 상관없이 Current 모드 읽기가 발생하지 않음
  - 디스크 소트가 필요할 정도의 대량의 데이터를 정렬해도 Current 모드 읽기가 나타남

#### 2. Consistent 모드로 갱신할 때 생기는 현상
- 사례는 생략함
- 모든 오라클 사용자는 항상 Consistent 모드 읽기 중심으로 생각할것
- Consistent모드로 값을 읽고 갱신한다면 쿼리 기준으로 읽어드리면 첫번째로 발생한 트랜잭션엗 대한 처리결과는 사라진다.
- 이걸 Lost update라고 함
- 해당 문제를 피하기 위해 갱신 작업만큼은 Current 모드를 사용한다.
- 사례 요약하면
  - TX2 update는 Exclusive Lock때문에 대기했다가 TX1트랜잭션이 커밋한 후 Current 모드로 그 값을 읽어 진행을 계속함
  - 그럼으로써 Lock Update문제를 피할 수 있다.

#### 3. Current 모드로 갱신할 때 생기는 현상
- Current 모드로 갱신해야 Lost Update를 회피할 수 있다고 했다.
- 사례 생략
- Consistent의 경우는 쿼리를 한번에 실행시키고 commit을 따로하는 경항이 있지만, current 방식은 하나실행시키고 commit을 실행시켜 대부분 쿼리의 손실을 방지할 수 있다.

#### 4. Consistent 모드로 읽고, Current 모드로 갱신할 떄 생기는 현상
- update문 수행시 consistent모드로 읽고, 값 변경 시 Current 모드로 읽음.
- 대상 레코드를 읽기위한 블록 액세스는 SQL 트레이스에서 query 항목으로 계산, 값을 변경하기 위한 블록 액세스는 current 항목에서 계산함
- 단순히 이해하면 안됨 다른 오류에 빠질 수 있을것
- 값을 읽고 변경할때 모드가 다르기 때문에 update문 실행시 실패할 수 있다.

#### 5. Consistent 모드로 갱신대상을 식별하고 Current 모드로 갱신
```
단계 1. where절에 기술된 조건에 따라 수정/삭제할 대상 레코드의 rowid를 Consistent모드로 찾음

단계 2. 앞에서 읽은 rowid가 가리키는 레코드를 찾아가 로우 Lock을 설정한 후에 Current 모드로 실제 Update/delete를 수행
이 단계에서 Current 모드로 다시 한번 조건을 체크하고 갱신할 값을 수정/삭제함
```
- update/delete대상건을 모두 추출하고 나서 단계 2를 수행한다고 생각하면 안됨
- 단계 1은 update/delete가 시작된 시점 기준으로 수정/삭제할 대상을 식별하려고 Consistent 모드 읽기를 사용할 뿐임
- 거기서 읽은 값을 단계2에서 갱신하는데 사용하지는 않음
- 단계 1이 필요한 이유는 갱신이 진행되는 동안 추가되거나 변경을 통해 범위안에 새로 들어오는 레코드를 제외하고자 하는 것
- 단계 2에서 변경이 이루어지는 바로그 시점으로 값을 읽고 갱신
- 이떄는 블록 SCN이 쿼리 SCN보다 높고 낮음을 따지지 않으며, 그 시점에 이미 커밋된 값이라면 그대로 받아드리려고 읽음
- 이때문에 update에 실패하는 것
- 요약
  - select는 Consistent 모드로 읽음
  - insert, update, delete, merge는 Current모드로 읽고 씀
  - 다만 갱신할 대상 레코드를 식별하는 작업만큼은 Consistent모드로 이루어짐

#### white consistency
- 데이터 정합성에 문제가 생기는 경우가 있고, 이를 방지하려고 오라클은 Restart 메커니즘을 사용함
- 그때까지 갱신을 롤백하고 update를 처음부터 다시 실행하는 것
- 이 기능은 데이터 베이스 일관성을 유지하려고 오라클이 사용하는 아주 내부적인 매커니즘으로 중요하게 다룰 내용은 아님
- Consistent모드로 찾은 레코드를 Current모드로 읽어 갱신한다는 기본 컨셉만 이해해도 충분함
- 갱신 대상 레코드의 값이 중간에 바뀌었다고 항상 Restart 메커니즘이 작동하는 것도 아님
- where절에 사용된 컬럼 값이 바뀌었을 때만 작동한다.
- restart 메커니즘이 작동하더라도 대개는 처리 결과가 달라지지 않음
- 위 사례만 보더라도 데이터베이스 일관성 문제가 생기는 사례를 찾기가 오히려 어렵다.
- 트랜잭션 유형, 데이터 저장 위치, 그리고 갱신 시점의 미묘한 차이 때문에 일관성 없게 값이 갱신되는 현상을 방지하려고 구현된 기능

#### Restart없이 처리했을때
- 일관성에 문제가 있다고 느끼는가?
- 읽기 작업이 쿼리 시작 시점 기준으로 일관성 있게 진행하는 것처럼 쓰기 작업도 기준 시점이 존재해야함
- 그런데 조금 전 트랜잭션 처리 결과는 그렇지가 못함
- 이 문제를 해결하려고 Restart방식을 선택, Restart 시점이 일관성 기준 시점이 됨
- 