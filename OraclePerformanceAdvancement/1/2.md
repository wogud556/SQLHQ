## 2절  DB 버퍼캐시

- 빠른 데이터 입출력을 위해 SGA 공유 메모리를 이용한다고 설명했다.
- 좀더 구체적으로 말해 사용자가 입력한 데이터를 데이터파일에 저장하고 이를 다시 읽는 거쳐가는 캐시 영역은 SGA 구성요소 중 하나인 DB 버퍼 캐시(DB Buffer Cache)다.

### (1) 블록단위 I/O
- 오라클에서는 I/O는 블록 단위로 이루어진다.
  - 메모리 버퍼 캐시에서 버퍼블록 액세스할 때
  - 데이터파일에 저장된 데이터 블록을 DB버퍼 캐시로 적재할 때
  - 캐시에서 변경된 블록을 다시 데이터파일에 저장할 때
- 데이터파일에서 버퍼 캐시로 블록을 적재할 때, 인덱스를 경유한 테이블 액세스 시 한번에 한블록씩 읽어드림
- Full Scan 시 성능 향상을 위해 한번에 여러개 블록을 읽어드림
- DBWR 프로세스는 버퍼 캐시로부터 변경된 블록(Dirty 버퍼 블록)을 주기적으로 데이터파일에 기록하는 작업 수행 시 성능 향상을 위해 한번에 여러 블록을 처리한다.
- 블록 단위로 읽는다는 의미는 하나의 레코드에 하나의 컬럼만을 읽고자 하더라도 레코드 전체를 읽게 됨을 의미
- SQL 성능을 좌우하는 가장 중요한 성능지표는 액세스하는 블록갯수
- 옵티마이저의 판단에 가장 큰 영향을 미치는 것도 액세스해야 할 블록 갯수.
- 옵티마이저가 인덱스를 이용해 테이블을 엑세스할지 아니면 Full Table Scan 할지를 결정하는데 있어 가장 중요한 판단 기준은, 읽어야 할 레코드 수가 아니라 블록 갯수

### (2) 버퍼 캐시 구조
- DB 버퍼 캐시를 설명할 때 흔히 그림 1-8처럼 바둑판 모양으로 표현하는데, 가장 직관적이면서 이해하기 쉬운 그림임이 틀림없다.
- 버퍼 캐시에서 읽고자 하는 데이터블록이 담긴 버퍼 블록을 찾아내는 방법
SGA내에 수없이 많은 자료구조(Data Structure)가 사용되고 있으며 그 중 가장 많이 사용되는 것이 해시테이블(또는 해시 탭)이고, DB 버퍼 캐시도 해시 테이블 구조로 관리된다.
- 해싱(hasing)알고리즘을 설명할 때 흔히 주소록에 비유한다.
- 고객의 주소와 전홰번호를 관리하는 주소록에서 성씨가 같은 고객은 같은 페이지(=해시 버켓)에 묶여서 관리한다.
- 고객 번호가 입수되는 시점이 다르므로 같은 성씨 안에서는 대개 정렬된 상태를 유지하지 않는다.
- 이때문에 해시 버킷 내에서는 스캔 방식으로 값을 찾음.
- 그렇더라도 키 값을 해시 값으로 변환해 해시 버킷을 찾아가는 속도가 빨라 각 버킷에 기록되는 엔트리 개수를 일정 수준으로 유지할 수만 있다면 해싱에 의한 검색 속도가 가장 빠르다고 알려짐


### DB버퍼내에서 해싱
- DB버퍼 캐시 내에서 데이터 블록은 해싱하기 위해 사용되는 키 값은 데이터 블록 주소(DBA, Data Block Address)다. 즉, 해시 함수에 데이터 블록 주소를 입력해 리턴받은 해시 값이 같은 블록들을 같은 해시 버킷(Bucket)에 연결 리스트(Linked List)구조로 연결하는 것
- 각각의 연결 리스트를 해시 체인
- 찾고자 하는 데이터블록 주소로 해시 값으로 변환하여 해당 해시 버킷에서 체인을 따라 스캔하다 거기서 찾아지면 바로 읽고, 찾지 못하면 디스크에서 읽어 해시 체인에 연결 후 읽으면 됨
- 자신만 읽고 버리는 것이 아니라 다른 사용자들도 사용할 수 있도록 캐싱

지금까지 버퍼 블록이 통째로 해시 구조로 관리되는 것처럼 설명했지만, 정확히 표현하면 버퍼 헤더(Buffer header)만 해시 체인에 연결되며, 실제의 데이터 값이 필요해지면 버퍼 헤더에 있는 포인터를 이용해 다시 버퍼 블록을 찾아가는 구조

### (3) 캐시 버퍼 체인
해시체인은 래치(Latch)에 의해 보호됨
DB 버퍼 캐시는 공유 메모리 영역인 SGA 내에 존재하므로 여러 프로세스에 의한 동시 액세스가 일어날 가능성이 큼
같은 리소스에 대한 액세스를 반드시 직렬화 해야 하고, 이를 위해 구현된 일종의 lock 메커니즘을 래치 라고 부른다.
래치를 획득한 프로세스만이 그 래치에 의해 보호되는 자료구조로 진입이 허용
예를 들어 두개 이상의 프로세스가 같은 해시 체인으로 진입해 새로운 버퍼 블록을 연결하고 해제하는 작업을동시에 진행한다면 문제가 발생할 수 있다.
이를 방지하기 위해 사용하는 것이 cache buffer chains래치이다.
이외에도 래치 종류는 9i 기준 241개 10g 기준 394정보 11g기준 496개나 된다.
```
select count(*) from v$latchnme;

COUNT(*)
—————
          394
```
하나의 cache buffers chains 래치가 여러개 해시 체인을 동시에 관리한다는 사실도 기억할 필요가 있다
저자의 해시 버킷개수가 2097152 인데 해시체인을 관리하는 래치 개수는 65536
따라서 하나의 래치가 32개 버킷을 관리한다는 것을 알 수 있으며, 이는 버퍼 캐시크기와 버전에 따라 달라짐
하나의 체인에 여러개 버퍼가 연결되도록 그렸지만, 실제로는 하나의 체인에 하나의 버퍼만 달리는 것을 목표로 삼아야 한다.
그래야 목표한 해시 체인을 찾고서 추가적으로 스캔하는 비용을 최소화할 수 있음
그러려면 목표한 해시 체인을 찾고서 추가적으로 스캔하는 비용을 최소화할 수 있다.
그러려면 버킷 개수가 충분히 많아야 하고, 현재 필자가 접속한 시스템에서도 블록 버퍼가 836684개이므로 해시 버킷 개수가 2.5개가량 많아짐.
오라클 i9부터 읽기전용 작업일때는 cache buffers chain래치를 share 모드로 획득할 수 있다고 한다.
주의할 것은 여기서 읽기전용 작업이란 select문을 의미하는 것이 아니라 해시 체인을 스캔하면서 필요한 블록을 찾는 작업을 말함
그러므로 i9 이후 버전에서 share 모드 래치를 사용하는 것과 상관없이 select문장을 동시에 수행하면 여전히 cache buffer chain 래치 경합이 발견됨
다시 얘기하지만 래치는 데이터 자체를 보호하는 것이 아니라 SGA에 공유돼있는 자료구조를 보호하는 것
그중 cache buffer chains 래치는 
버퍼 캐시에 연결된 체인 구조를 보호
버퍼 헤더에 pin을 설정할 때.
9i부터 해시 체인을 스캔할 때는 share 모드로 래치를 획득했다가 체인 구조를 변경(블록을 찾지 못해 디스크로부터 읽은 블록을 추가)하거나 share 모드로 래치를 획득했다가 체인 구조를 변경하거나 버퍼 헤더에 pin을 설정할 때만 exclusive 모드로 올리도록 커널 코드가 변경된 것 같다.
해시체인을 스캔하거나 거기에 블록을 추가, 제거할 때 래치가 요구됨

### (4) 캐시 버퍼 LRU 체인
버퍼 헤더는 해시 체인 뿐 아니라 LRU 체인에 의해서도 연결됨
DB버퍼 캐시는 한번 읽은 데이터 블록을 캐싱해 두는 메모리 공간이지만, 메모리는 유일한 자원이라 모든 데이터를 캐싱할 수 없다.
따라서 버퍼 캐시가 사용 빈도가 높은 데이터 블록들 위주로 구성될 수 있도록 LRU(least recently used) 알고리즘을 사용해 관리한다.
즉, 모든 버퍼 블록 헤더를 LRU 체인에 연결해 사용 빈도 순으로 위치를 옮겨가다가, Free 버퍼가 필요해질 때마다 액세스 빈도가 낮은 데이터 블록들을 우선하여 밀어냄으로 자주 액세스 되는 블록들이 캐시에 더 오래남아 있도록 관리하는 것.

#### LRU 리스트에는 내부적으로 두개의 리스트를 갖음
Dirty 리스트 : 캐시 내에서 변경됐지만, 아직 디스크에 기록되지 않은 Dirty 버퍼 블록들을 관리하여 “LRUW(LRU write)리스트”라고도 한다.
LRU 리스트 : 아직 Dirty 리스트로 옮겨지지 않은 나머지 버퍼 블록들을 관리한다.